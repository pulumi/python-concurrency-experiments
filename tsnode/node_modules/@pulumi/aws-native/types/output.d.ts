import * as outputs from "../types/output";
import * as enums from "../types/enums";
export declare namespace accessanalyzer {
    /**
     * An Access Analyzer archive rule. Archive rules automatically archive new findings that meet the criteria you define when you create the rule.
     */
    interface AnalyzerArchiveRule {
        filter: outputs.accessanalyzer.AnalyzerFilter[];
        /**
         * The archive rule name
         */
        ruleName: string;
    }
    interface AnalyzerFilter {
        contains?: string[];
        eq?: string[];
        exists?: boolean;
        neq?: string[];
        property: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface AnalyzerTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace acmpca {
    /**
     * Structure that specifies fields to be overridden in a certificate at the time of issuance. These requires an API Passthrough template be used or they will be ignored.
     */
    interface CertificateApiPassthrough {
        extensions?: outputs.acmpca.CertificateExtensions;
        subject?: outputs.acmpca.CertificateSubject;
    }
    /**
     * Structure that contains X.509 AccessDescription information.
     */
    interface CertificateAuthorityAccessDescription {
        accessLocation: outputs.acmpca.CertificateAuthorityGeneralName;
        accessMethod: outputs.acmpca.CertificateAuthorityAccessMethod;
    }
    /**
     * Structure that contains X.509 AccessMethod information. Assign one and ONLY one field.
     */
    interface CertificateAuthorityAccessMethod {
        accessMethodType?: string;
        customObjectIdentifier?: string;
    }
    /**
     * Your certificate authority can create and maintain a certificate revocation list (CRL). A CRL contains information about certificates that have been revoked.
     */
    interface CertificateAuthorityCrlConfiguration {
        customCname?: string;
        enabled?: boolean;
        expirationInDays?: number;
        s3BucketName?: string;
        s3ObjectAcl?: string;
    }
    /**
     * Structure that contains CSR pass though extensions information.
     */
    interface CertificateAuthorityCsrExtensions {
        keyUsage?: outputs.acmpca.CertificateAuthorityKeyUsage;
        subjectInformationAccess?: outputs.acmpca.CertificateAuthorityAccessDescription[];
    }
    /**
     * Structure that contains X.500 attribute type and value.
     */
    interface CertificateAuthorityCustomAttribute {
        objectIdentifier: string;
        value: string;
    }
    /**
     * Structure that contains X.509 EdiPartyName information.
     */
    interface CertificateAuthorityEdiPartyName {
        nameAssigner: string;
        partyName: string;
    }
    /**
     * Structure that contains X.509 GeneralName information. Assign one and ONLY one field.
     */
    interface CertificateAuthorityGeneralName {
        directoryName?: outputs.acmpca.CertificateAuthoritySubject;
        dnsName?: string;
        ediPartyName?: outputs.acmpca.CertificateAuthorityEdiPartyName;
        ipAddress?: string;
        otherName?: outputs.acmpca.CertificateAuthorityOtherName;
        registeredId?: string;
        rfc822Name?: string;
        uniformResourceIdentifier?: string;
    }
    /**
     * Structure that contains X.509 KeyUsage information.
     */
    interface CertificateAuthorityKeyUsage {
        cRLSign?: boolean;
        dataEncipherment?: boolean;
        decipherOnly?: boolean;
        digitalSignature?: boolean;
        encipherOnly?: boolean;
        keyAgreement?: boolean;
        keyCertSign?: boolean;
        keyEncipherment?: boolean;
        nonRepudiation?: boolean;
    }
    /**
     * Helps to configure online certificate status protocol (OCSP) responder for your certificate authority
     */
    interface CertificateAuthorityOcspConfiguration {
        enabled?: boolean;
        ocspCustomCname?: string;
    }
    /**
     * Structure that contains X.509 OtherName information.
     */
    interface CertificateAuthorityOtherName {
        typeId: string;
        value: string;
    }
    /**
     * Certificate Authority revocation information.
     */
    interface CertificateAuthorityRevocationConfiguration {
        crlConfiguration?: outputs.acmpca.CertificateAuthorityCrlConfiguration;
        ocspConfiguration?: outputs.acmpca.CertificateAuthorityOcspConfiguration;
    }
    /**
     * Structure that contains X.500 distinguished name information for your CA.
     */
    interface CertificateAuthoritySubject {
        commonName?: string;
        country?: string;
        customAttributes?: outputs.acmpca.CertificateAuthorityCustomAttribute[];
        distinguishedNameQualifier?: string;
        generationQualifier?: string;
        givenName?: string;
        initials?: string;
        locality?: string;
        organization?: string;
        organizationalUnit?: string;
        pseudonym?: string;
        serialNumber?: string;
        state?: string;
        surname?: string;
        title?: string;
    }
    interface CertificateAuthorityTag {
        key?: string;
        value?: string;
    }
    /**
     * Structure that contains X.500 attribute type and value.
     */
    interface CertificateCustomAttribute {
        objectIdentifier: string;
        value: string;
    }
    /**
     * Structure that contains X.509 extension information for a certificate.
     */
    interface CertificateCustomExtension {
        critical?: boolean;
        objectIdentifier: string;
        value: string;
    }
    /**
     * Structure that contains X.509 EdiPartyName information.
     */
    interface CertificateEdiPartyName {
        nameAssigner: string;
        partyName: string;
    }
    /**
     * Structure that contains X.509 ExtendedKeyUsage information.
     */
    interface CertificateExtendedKeyUsage {
        extendedKeyUsageObjectIdentifier?: string;
        extendedKeyUsageType?: string;
    }
    /**
     * Structure that contains X.500 extensions for a Certificate.
     */
    interface CertificateExtensions {
        certificatePolicies?: outputs.acmpca.CertificatePolicyInformation[];
        customExtensions?: outputs.acmpca.CertificateCustomExtension[];
        extendedKeyUsage?: outputs.acmpca.CertificateExtendedKeyUsage[];
        keyUsage?: outputs.acmpca.CertificateKeyUsage;
        subjectAlternativeNames?: outputs.acmpca.CertificateGeneralName[];
    }
    /**
     * Structure that contains X.509 GeneralName information. Assign one and ONLY one field.
     */
    interface CertificateGeneralName {
        directoryName?: outputs.acmpca.CertificateSubject;
        dnsName?: string;
        ediPartyName?: outputs.acmpca.CertificateEdiPartyName;
        ipAddress?: string;
        otherName?: outputs.acmpca.CertificateOtherName;
        registeredId?: string;
        rfc822Name?: string;
        uniformResourceIdentifier?: string;
    }
    /**
     * Structure that contains X.509 KeyUsage information.
     */
    interface CertificateKeyUsage {
        cRLSign?: boolean;
        dataEncipherment?: boolean;
        decipherOnly?: boolean;
        digitalSignature?: boolean;
        encipherOnly?: boolean;
        keyAgreement?: boolean;
        keyCertSign?: boolean;
        keyEncipherment?: boolean;
        nonRepudiation?: boolean;
    }
    /**
     * Structure that contains X.509 OtherName information.
     */
    interface CertificateOtherName {
        typeId: string;
        value: string;
    }
    /**
     * Structure that contains X.509 Policy information.
     */
    interface CertificatePolicyInformation {
        certPolicyId: string;
        policyQualifiers?: outputs.acmpca.CertificatePolicyQualifierInfo[];
    }
    /**
     * Structure that contains X.509 Policy qualifier information.
     */
    interface CertificatePolicyQualifierInfo {
        policyQualifierId: string;
        qualifier: outputs.acmpca.CertificateQualifier;
    }
    /**
     * Structure that contains a X.509 policy qualifier.
     */
    interface CertificateQualifier {
        cpsUri: string;
    }
    /**
     * Structure that contains X.500 distinguished name information.
     */
    interface CertificateSubject {
        commonName?: string;
        country?: string;
        customAttributes?: outputs.acmpca.CertificateCustomAttribute[];
        distinguishedNameQualifier?: string;
        generationQualifier?: string;
        givenName?: string;
        initials?: string;
        locality?: string;
        organization?: string;
        organizationalUnit?: string;
        pseudonym?: string;
        serialNumber?: string;
        state?: string;
        surname?: string;
        title?: string;
    }
    /**
     * Validity for a certificate.
     */
    interface CertificateValidity {
        type: string;
        value: number;
    }
}
export declare namespace amazonmq {
    interface BrokerConfigurationId {
        id: string;
        revision: number;
    }
    interface BrokerEncryptionOptions {
        kmsKeyId?: string;
        useAwsOwnedKey: boolean;
    }
    interface BrokerLdapServerMetadata {
        hosts: string[];
        roleBase: string;
        roleName?: string;
        roleSearchMatching: string;
        roleSearchSubtree?: boolean;
        serviceAccountPassword: string;
        serviceAccountUsername: string;
        userBase: string;
        userRoleName?: string;
        userSearchMatching: string;
        userSearchSubtree?: boolean;
    }
    interface BrokerLogList {
        audit?: boolean;
        general?: boolean;
    }
    interface BrokerMaintenanceWindow {
        dayOfWeek: string;
        timeOfDay: string;
        timeZone: string;
    }
    interface BrokerTagsEntry {
        key: string;
        value: string;
    }
    interface BrokerUser {
        consoleAccess?: boolean;
        groups?: string[];
        password: string;
        username: string;
    }
    interface ConfigurationAssociationConfigurationId {
        id: string;
        revision: number;
    }
    interface ConfigurationTagsEntry {
        key: string;
        value: string;
    }
}
export declare namespace amplify {
    interface AppAutoBranchCreationConfig {
        autoBranchCreationPatterns?: string[];
        basicAuthConfig?: outputs.amplify.AppBasicAuthConfig;
        buildSpec?: string;
        enableAutoBranchCreation?: boolean;
        enableAutoBuild?: boolean;
        enablePerformanceMode?: boolean;
        enablePullRequestPreview?: boolean;
        environmentVariables?: outputs.amplify.AppEnvironmentVariable[];
        pullRequestEnvironmentName?: string;
        stage?: enums.amplify.AppAutoBranchCreationConfigStage;
    }
    interface AppBasicAuthConfig {
        enableBasicAuth?: boolean;
        password?: string;
        username?: string;
    }
    interface AppCustomRule {
        condition?: string;
        source: string;
        status?: string;
        target: string;
    }
    interface AppEnvironmentVariable {
        name: string;
        value: string;
    }
    interface AppTag {
        key: string;
        value: string;
    }
    interface BranchBasicAuthConfig {
        enableBasicAuth?: boolean;
        password: string;
        username: string;
    }
    interface BranchEnvironmentVariable {
        name: string;
        value: string;
    }
    interface BranchTag {
        key: string;
        value: string;
    }
    interface DomainSubDomainSetting {
        branchName: string;
        prefix: string;
    }
}
export declare namespace amplifyuibuilder {
    interface ComponentBindingProperties {
    }
    interface ComponentChild {
        children?: outputs.amplifyuibuilder.ComponentChild[];
        componentType: string;
        events?: outputs.amplifyuibuilder.ComponentEvents;
        name: string;
        properties: outputs.amplifyuibuilder.ComponentProperties;
    }
    interface ComponentCollectionProperties {
    }
    interface ComponentEvents {
    }
    interface ComponentOverrides {
    }
    interface ComponentProperties {
    }
    interface ComponentTags {
    }
    interface ComponentVariant {
        overrides?: outputs.amplifyuibuilder.ComponentOverrides;
        variantValues?: outputs.amplifyuibuilder.ComponentVariantValues;
    }
    interface ComponentVariantValues {
    }
    interface ThemeTags {
    }
    interface ThemeValue {
        children?: outputs.amplifyuibuilder.ThemeValues[];
        value?: string;
    }
    interface ThemeValues {
        key?: string;
        value?: outputs.amplifyuibuilder.ThemeValue;
    }
}
export declare namespace apigateway {
    interface ApiKeyStageKey {
        /**
         * The ID of a RestApi resource that includes the stage with which you want to associate the API key.
         */
        restApiId?: string;
        /**
         * The name of the stage with which to associate the API key. The stage must be included in the RestApi resource that you specified in the RestApiId property.
         */
        stageName?: string;
    }
    interface ApiKeyTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ClientCertificateTag {
        key: string;
        value: string;
    }
    interface DeploymentAccessLogSetting {
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with amazon-apigateway-.
         */
        destinationArn?: string;
        /**
         * A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
         */
        format?: string;
    }
    interface DeploymentCanarySetting {
        /**
         * The percent (0-100) of traffic diverted to a canary deployment.
         */
        percentTraffic?: number;
        /**
         * Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
         */
        stageVariableOverrides?: any;
        /**
         * Whether the canary deployment uses the stage cache or not.
         */
        useStageCache?: boolean;
    }
    interface DeploymentCanarySettings {
        /**
         * The percentage (0-100) of traffic diverted to a canary deployment.
         */
        percentTraffic?: number;
        /**
         * Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values. Duplicates are not allowed.
         */
        stageVariableOverrides?: any;
        /**
         * Whether the canary deployment uses the stage cache.
         */
        useStageCache?: boolean;
    }
    interface DeploymentMethodSetting {
        /**
         * Indicates whether the cached responses are encrypted
         */
        cacheDataEncrypted?: boolean;
        /**
         * The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses.
         */
        cacheTtlInSeconds?: number;
        /**
         * Indicates whether responses are cached and returned for requests. You must enable a cache cluster on the stage to cache responses.
         */
        cachingEnabled?: boolean;
        /**
         * Indicates whether data trace logging is enabled for methods in the stage. API Gateway pushes these logs to Amazon CloudWatch Logs.
         */
        dataTraceEnabled?: boolean;
        /**
         * The HTTP method.
         */
        httpMethod?: string;
        /**
         * The logging level for this method. For valid values, see the loggingLevel property of the Stage resource in the Amazon API Gateway API Reference.
         */
        loggingLevel?: string;
        /**
         * Indicates whether Amazon CloudWatch metrics are enabled for methods in the stage.
         */
        metricsEnabled?: boolean;
        /**
         * The resource path for this method. Forward slashes (/) are encoded as ~1 and the initial slash must include a forward slash.
         */
        resourcePath?: string;
        /**
         * The number of burst requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
         */
        throttlingBurstLimit?: number;
        /**
         * The number of steady-state requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
         */
        throttlingRateLimit?: number;
    }
    interface DeploymentStageDescription {
        /**
         * Specifies settings for logging access in this stage.
         */
        accessLogSetting?: outputs.apigateway.DeploymentAccessLogSetting;
        /**
         * Indicates whether cache clustering is enabled for the stage.
         */
        cacheClusterEnabled?: boolean;
        /**
         * The size of the stage's cache cluster.
         */
        cacheClusterSize?: string;
        /**
         * The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses.
         */
        cacheDataEncrypted?: boolean;
        /**
         * The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses.
         */
        cacheTtlInSeconds?: number;
        /**
         * Indicates whether responses are cached and returned for requests. You must enable a cache cluster on the stage to cache responses.
         */
        cachingEnabled?: boolean;
        /**
         * Specifies settings for the canary deployment in this stage.
         */
        canarySetting?: outputs.apigateway.DeploymentCanarySetting;
        /**
         * The identifier of the client certificate that API Gateway uses to call your integration endpoints in the stage.
         */
        clientCertificateId?: string;
        /**
         * Indicates whether data trace logging is enabled for methods in the stage. API Gateway pushes these logs to Amazon CloudWatch Logs.
         */
        dataTraceEnabled?: boolean;
        /**
         * A description of the purpose of the stage.
         */
        description?: string;
        /**
         * The version identifier of the API documentation snapshot.
         */
        documentationVersion?: string;
        /**
         * The logging level for this method. For valid values, see the loggingLevel property of the Stage resource in the Amazon API Gateway API Reference.
         */
        loggingLevel?: string;
        /**
         * Configures settings for all of the stage's methods.
         */
        methodSettings?: outputs.apigateway.DeploymentMethodSetting[];
        /**
         * Indicates whether Amazon CloudWatch metrics are enabled for methods in the stage.
         */
        metricsEnabled?: boolean;
        /**
         * An array of arbitrary tags (key-value pairs) to associate with the stage.
         */
        tags?: outputs.apigateway.DeploymentTag[];
        /**
         * The number of burst requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
         */
        throttlingBurstLimit?: number;
        /**
         * The number of steady-state requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
         */
        throttlingRateLimit?: number;
        /**
         * Specifies whether active tracing with X-ray is enabled for this stage.
         */
        tracingEnabled?: boolean;
        /**
         * A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: [A-Za-z0-9-._~:/?#&=,]+.
         */
        variables?: any;
    }
    interface DeploymentTag {
        /**
         * The key name of the tag
         */
        key: string;
        /**
         * The value for the tag
         */
        value: string;
    }
    interface DocumentationPartLocation {
        /**
         * The HTTP verb of a method.
         */
        method?: string;
        /**
         * The name of the targeted API entity.
         */
        name?: string;
        /**
         * The URL path of the target.
         */
        path?: string;
        /**
         * The HTTP status code of a response.
         */
        statusCode?: string;
        /**
         * The type of API entity that the documentation content applies to.
         */
        type?: enums.apigateway.DocumentationPartLocationType;
    }
    interface DomainNameEndpointConfiguration {
        types?: string[];
    }
    interface DomainNameMutualTlsAuthentication {
        truststoreUri?: string;
        truststoreVersion?: string;
    }
    interface DomainNameTag {
        key?: string;
        value?: string;
    }
    interface MethodIntegration {
        /**
         * A list of request parameters whose values API Gateway caches.
         */
        cacheKeyParameters?: string[];
        /**
         * An API-specific tag group of related cached parameters.
         */
        cacheNamespace?: string;
        /**
         * The ID of the VpcLink used for the integration when connectionType=VPC_LINK, otherwise undefined.
         */
        connectionId?: string;
        /**
         * The type of the network connection to the integration endpoint.
         */
        connectionType?: enums.apigateway.MethodIntegrationConnectionType;
        /**
         * Specifies how to handle request payload content type conversions.
         */
        contentHandling?: enums.apigateway.MethodIntegrationContentHandling;
        /**
         * The credentials that are required for the integration.
         */
        credentials?: string;
        /**
         * The integration's HTTP method type.
         */
        integrationHttpMethod?: string;
        /**
         * The response that API Gateway provides after a method's backend completes processing a request.
         */
        integrationResponses?: outputs.apigateway.MethodIntegrationResponse[];
        /**
         * Indicates when API Gateway passes requests to the targeted backend.
         */
        passthroughBehavior?: enums.apigateway.MethodIntegrationPassthroughBehavior;
        /**
         * The request parameters that API Gateway sends with the backend request.
         */
        requestParameters?: any;
        /**
         * A map of Apache Velocity templates that are applied on the request payload.
         */
        requestTemplates?: any;
        /**
         * Custom timeout between 50 and 29,000 milliseconds.
         */
        timeoutInMillis?: number;
        /**
         * The type of backend that your method is running.
         */
        type: enums.apigateway.MethodIntegrationType;
        /**
         * The Uniform Resource Identifier (URI) for the integration.
         */
        uri?: string;
    }
    interface MethodIntegrationResponse {
        /**
         * Specifies how to handle request payload content type conversions.
         */
        contentHandling?: enums.apigateway.MethodIntegrationResponseContentHandling;
        /**
         * The response parameters from the backend response that API Gateway sends to the method response.
         */
        responseParameters?: any;
        /**
         * The templates that are used to transform the integration response body. Specify templates as key-value pairs (string-to-string mappings), with a content type as the key and a template as the value.
         */
        responseTemplates?: any;
        /**
         * A regular expression that specifies which error strings or status codes from the backend map to the integration response.
         */
        selectionPattern?: string;
        /**
         * The status code that API Gateway uses to map the integration response to a MethodResponse status code.
         */
        statusCode: string;
    }
    interface MethodResponse {
        /**
         * The resources used for the response's content type. Specify response models as key-value pairs (string-to-string maps), with a content type as the key and a Model resource name as the value.
         */
        responseModels?: any;
        /**
         * Response parameters that API Gateway sends to the client that called a method. Specify response parameters as key-value pairs (string-to-Boolean maps), with a destination as the key and a Boolean as the value.
         */
        responseParameters?: any;
        /**
         * The method response's status code, which you map to an IntegrationResponse.
         */
        statusCode: string;
    }
    interface RestApiEndpointConfiguration {
        types?: string[];
        vpcEndpointIds?: string[];
    }
    interface RestApiS3Location {
        bucket?: string;
        eTag?: string;
        key?: string;
        version?: string;
    }
    interface RestApiTag {
        key: string;
        value: string;
    }
    /**
     * Specifies settings for logging access in this stage.
     */
    interface StageAccessLogSetting {
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with amazon-apigateway-. This parameter is required to enable access logging.
         */
        destinationArn?: string;
        /**
         * A single line format of the access logs of data, as specified by selected $context variables (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference). The format must include at least $context.requestId. This parameter is required to enable access logging.
         */
        format?: string;
    }
    /**
     * Specifies settings for the canary deployment in this stage.
     */
    interface StageCanarySetting {
        /**
         * The identifier of the deployment that the stage points to.
         */
        deploymentId?: string;
        /**
         * The percentage (0-100) of traffic diverted to a canary deployment.
         */
        percentTraffic?: number;
        /**
         * Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
         */
        stageVariableOverrides?: any;
        /**
         * Whether the canary deployment uses the stage cache or not.
         */
        useStageCache?: boolean;
    }
    /**
     * Configures settings for all methods in a stage.
     */
    interface StageMethodSetting {
        /**
         * Indicates whether the cached responses are encrypted.
         */
        cacheDataEncrypted?: boolean;
        /**
         * The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses.
         */
        cacheTtlInSeconds?: number;
        /**
         * Indicates whether responses are cached and returned for requests. You must enable a cache cluster on the stage to cache responses.
         */
        cachingEnabled?: boolean;
        /**
         * Indicates whether data trace logging is enabled for methods in the stage. API Gateway pushes these logs to Amazon CloudWatch Logs.
         */
        dataTraceEnabled?: boolean;
        /**
         * The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
         */
        httpMethod?: string;
        /**
         * The logging level for this method. For valid values, see the loggingLevel property of the Stage (https://docs.aws.amazon.com/apigateway/api-reference/resource/stage/#loggingLevel) resource in the Amazon API Gateway API Reference.
         */
        loggingLevel?: string;
        /**
         * Indicates whether Amazon CloudWatch metrics are enabled for methods in the stage.
         */
        metricsEnabled?: boolean;
        /**
         * The resource path for this method. Forward slashes (/) are encoded as ~1 and the initial slash must include a forward slash. For example, the path value /resource/subresource must be encoded as /~1resource~1subresource. To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
         */
        resourcePath?: string;
        /**
         * The number of burst requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
         */
        throttlingBurstLimit?: number;
        /**
         * The number of steady-state requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
         */
        throttlingRateLimit?: number;
    }
    /**
     * Identify and categorize resources.
     */
    interface StageTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:.
         */
        value: string;
    }
    interface UsagePlanApiStage {
        /**
         * The ID of an API that is in the specified Stage property that you want to associate with the usage plan.
         */
        apiId?: string;
        /**
         * The name of the stage to associate with the usage plan.
         */
        stage?: string;
        /**
         * Map containing method-level throttling information for an API stage in a usage plan. The key for the map is the path and method for which to configure custom throttling, for example, '/pets/GET'. Duplicates are not allowed.
         */
        throttle?: any;
    }
    interface UsagePlanQuotaSettings {
        /**
         * The maximum number of requests that users can make within the specified time period.
         */
        limit?: number;
        /**
         * For the initial time period, the number of requests to subtract from the specified limit. When you first implement a usage plan, the plan might start in the middle of the week or month. With this property, you can decrease the limit for this initial time period.
         */
        offset?: number;
        /**
         * The time period for which the maximum limit of requests applies, such as DAY or WEEK. For valid values, see the period property for the UsagePlan resource in the Amazon API Gateway REST API Reference.
         */
        period?: string;
    }
    interface UsagePlanTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface UsagePlanThrottleSettings {
        /**
         * The maximum API request rate limit over a time ranging from one to a few seconds. The maximum API request rate limit depends on whether the underlying token bucket is at its full capacity.
         */
        burstLimit?: number;
        /**
         * The API request steady-state rate limit (average requests per second over an extended period of time).
         */
        rateLimit?: number;
    }
    interface VpcLinkTag {
        key: string;
        value: string;
    }
}
export declare namespace apigatewayv2 {
    interface ApiBodyS3Location {
        bucket?: string;
        etag?: string;
        key?: string;
        version?: string;
    }
    interface ApiCors {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOrigins?: string[];
        exposeHeaders?: string[];
        maxAge?: number;
    }
    interface ApiGatewayManagedOverridesAccessLogSettings {
        destinationArn?: string;
        format?: string;
    }
    interface ApiGatewayManagedOverridesIntegrationOverrides {
        description?: string;
        integrationMethod?: string;
        payloadFormatVersion?: string;
        timeoutInMillis?: number;
    }
    interface ApiGatewayManagedOverridesRouteOverrides {
        authorizationScopes?: string[];
        authorizationType?: string;
        authorizerId?: string;
        operationName?: string;
        target?: string;
    }
    interface ApiGatewayManagedOverridesRouteSettings {
        dataTraceEnabled?: boolean;
        detailedMetricsEnabled?: boolean;
        loggingLevel?: string;
        throttlingBurstLimit?: number;
        throttlingRateLimit?: number;
    }
    interface ApiGatewayManagedOverridesStageOverrides {
        accessLogSettings?: outputs.apigatewayv2.ApiGatewayManagedOverridesAccessLogSettings;
        autoDeploy?: boolean;
        defaultRouteSettings?: outputs.apigatewayv2.ApiGatewayManagedOverridesRouteSettings;
        description?: string;
        routeSettings?: any;
        stageVariables?: any;
    }
    interface AuthorizerJWTConfiguration {
        audience?: string[];
        issuer?: string;
    }
    interface DomainNameConfiguration {
        certificateArn?: string;
        certificateName?: string;
        endpointType?: string;
        ownershipVerificationCertificateArn?: string;
        securityPolicy?: string;
    }
    interface DomainNameMutualTlsAuthentication {
        truststoreUri?: string;
        truststoreVersion?: string;
    }
    interface IntegrationTlsConfig {
        serverNameToVerify?: string;
    }
    interface StageAccessLogSettings {
        destinationArn?: string;
        format?: string;
    }
    interface StageRouteSettings {
        dataTraceEnabled?: boolean;
        detailedMetricsEnabled?: boolean;
        loggingLevel?: string;
        throttlingBurstLimit?: number;
        throttlingRateLimit?: number;
    }
}
export declare namespace appconfig {
    interface ApplicationTags {
        key?: string;
        value?: string;
    }
    interface ConfigurationProfileTags {
        key?: string;
        value?: string;
    }
    interface ConfigurationProfileValidators {
        content?: string;
        type?: string;
    }
    interface DeploymentStrategyTags {
        key?: string;
        value?: string;
    }
    interface DeploymentTags {
        key?: string;
        value?: string;
    }
    interface EnvironmentMonitors {
        alarmArn?: string;
        alarmRoleArn?: string;
    }
    interface EnvironmentTags {
        key?: string;
        value?: string;
    }
}
export declare namespace appflow {
    interface ConnectorProfileAmplitudeConnectorProfileCredentials {
        /**
         * A unique alphanumeric identiﬁer used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
        secretKey: string;
    }
    interface ConnectorProfileApiKeyCredentials {
        apiKey: string;
        apiSecretKey?: string;
    }
    interface ConnectorProfileBasicAuthCredentials {
        password: string;
        username: string;
    }
    /**
     * Connector specific configurations needed to create connector profile
     */
    interface ConnectorProfileConfig {
        connectorProfileCredentials: outputs.appflow.ConnectorProfileCredentials;
        connectorProfileProperties?: outputs.appflow.ConnectorProfileProperties;
    }
    interface ConnectorProfileConnectorOAuthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been
         * granted.
         */
        redirectUri?: string;
    }
    /**
     * Connector specific configuration needed to create connector profile based on Authentication mechanism
     */
    interface ConnectorProfileCredentials {
        amplitude?: outputs.appflow.ConnectorProfileAmplitudeConnectorProfileCredentials;
        customConnector?: outputs.appflow.ConnectorProfileCustomConnectorProfileCredentials;
        datadog?: outputs.appflow.ConnectorProfileDatadogConnectorProfileCredentials;
        dynatrace?: outputs.appflow.ConnectorProfileDynatraceConnectorProfileCredentials;
        googleAnalytics?: outputs.appflow.ConnectorProfileGoogleAnalyticsConnectorProfileCredentials;
        inforNexus?: outputs.appflow.ConnectorProfileInforNexusConnectorProfileCredentials;
        marketo?: outputs.appflow.ConnectorProfileMarketoConnectorProfileCredentials;
        redshift?: outputs.appflow.ConnectorProfileRedshiftConnectorProfileCredentials;
        sAPOData?: outputs.appflow.ConnectorProfileSAPODataConnectorProfileCredentials;
        salesforce?: outputs.appflow.ConnectorProfileSalesforceConnectorProfileCredentials;
        serviceNow?: outputs.appflow.ConnectorProfileServiceNowConnectorProfileCredentials;
        singular?: outputs.appflow.ConnectorProfileSingularConnectorProfileCredentials;
        slack?: outputs.appflow.ConnectorProfileSlackConnectorProfileCredentials;
        snowflake?: outputs.appflow.ConnectorProfileSnowflakeConnectorProfileCredentials;
        trendmicro?: outputs.appflow.ConnectorProfileTrendmicroConnectorProfileCredentials;
        veeva?: outputs.appflow.ConnectorProfileVeevaConnectorProfileCredentials;
        zendesk?: outputs.appflow.ConnectorProfileZendeskConnectorProfileCredentials;
    }
    /**
     * A map for properties for custom authentication.
     */
    interface ConnectorProfileCredentialsMap {
    }
    interface ConnectorProfileCustomAuthCredentials {
        credentialsMap?: outputs.appflow.ConnectorProfileCredentialsMap;
        customAuthenticationType: string;
    }
    interface ConnectorProfileCustomConnectorProfileCredentials {
        apiKey?: outputs.appflow.ConnectorProfileApiKeyCredentials;
        authenticationType: enums.appflow.ConnectorProfileAuthenticationType;
        basic?: outputs.appflow.ConnectorProfileBasicAuthCredentials;
        custom?: outputs.appflow.ConnectorProfileCustomAuthCredentials;
        oauth2?: outputs.appflow.ConnectorProfileOAuth2Credentials;
    }
    interface ConnectorProfileCustomConnectorProfileProperties {
        oAuth2Properties?: outputs.appflow.ConnectorProfileOAuth2Properties;
        profileProperties?: outputs.appflow.ConnectorProfileProfileProperties;
    }
    interface ConnectorProfileDatadogConnectorProfileCredentials {
        /**
         * A unique alphanumeric identiﬁer used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
        /**
         * Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
         */
        applicationKey: string;
    }
    interface ConnectorProfileDatadogConnectorProfileProperties {
        /**
         * The location of the Datadog resource
         */
        instanceUrl: string;
    }
    interface ConnectorProfileDynatraceConnectorProfileCredentials {
        /**
         * The API tokens used by Dynatrace API to authenticate various API calls.
         */
        apiToken: string;
    }
    interface ConnectorProfileDynatraceConnectorProfileProperties {
        /**
         * The location of the Dynatrace resource
         */
        instanceUrl: string;
    }
    interface ConnectorProfileGoogleAnalyticsConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
        /**
         * The credentials used to acquire new access tokens.
         */
        refreshToken?: string;
    }
    interface ConnectorProfileInforNexusConnectorProfileCredentials {
        /**
         * The Access Key portion of the credentials.
         */
        accessKeyId: string;
        /**
         * The encryption keys used to encrypt data.
         */
        datakey: string;
        /**
         * The secret key used to sign requests.
         */
        secretAccessKey: string;
        /**
         * The identiﬁer for the user.
         */
        userId: string;
    }
    interface ConnectorProfileInforNexusConnectorProfileProperties {
        /**
         * The location of the InforNexus resource
         */
        instanceUrl: string;
    }
    interface ConnectorProfileMarketoConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
    }
    interface ConnectorProfileMarketoConnectorProfileProperties {
        /**
         * The location of the Marketo resource
         */
        instanceUrl: string;
    }
    interface ConnectorProfileOAuth2Credentials {
        accessToken?: string;
        clientId?: string;
        clientSecret?: string;
        oAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
        refreshToken?: string;
    }
    interface ConnectorProfileOAuth2Properties {
        oAuth2GrantType?: enums.appflow.ConnectorProfileOAuth2GrantType;
        tokenUrl?: string;
        tokenUrlCustomProperties?: outputs.appflow.ConnectorProfileTokenUrlCustomProperties;
    }
    interface ConnectorProfileOAuthProperties {
        authCodeUrl?: string;
        oAuthScopes?: string[];
        tokenUrl?: string;
    }
    /**
     * A map for properties for custom connector.
     */
    interface ConnectorProfileProfileProperties {
    }
    /**
     * Connector specific properties needed to create connector profile - currently not needed for Amplitude, Trendmicro, Googleanalytics and Singular
     */
    interface ConnectorProfileProperties {
        customConnector?: outputs.appflow.ConnectorProfileCustomConnectorProfileProperties;
        datadog?: outputs.appflow.ConnectorProfileDatadogConnectorProfileProperties;
        dynatrace?: outputs.appflow.ConnectorProfileDynatraceConnectorProfileProperties;
        inforNexus?: outputs.appflow.ConnectorProfileInforNexusConnectorProfileProperties;
        marketo?: outputs.appflow.ConnectorProfileMarketoConnectorProfileProperties;
        redshift?: outputs.appflow.ConnectorProfileRedshiftConnectorProfileProperties;
        sAPOData?: outputs.appflow.ConnectorProfileSAPODataConnectorProfileProperties;
        salesforce?: outputs.appflow.ConnectorProfileSalesforceConnectorProfileProperties;
        serviceNow?: outputs.appflow.ConnectorProfileServiceNowConnectorProfileProperties;
        slack?: outputs.appflow.ConnectorProfileSlackConnectorProfileProperties;
        snowflake?: outputs.appflow.ConnectorProfileSnowflakeConnectorProfileProperties;
        veeva?: outputs.appflow.ConnectorProfileVeevaConnectorProfileProperties;
        zendesk?: outputs.appflow.ConnectorProfileZendeskConnectorProfileProperties;
    }
    interface ConnectorProfileRedshiftConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }
    interface ConnectorProfileRedshiftConnectorProfileProperties {
        /**
         * The name of the Amazon S3 bucket associated with Redshift.
         */
        bucketName: string;
        /**
         * The object key for the destination bucket in which Amazon AppFlow will place the ﬁles.
         */
        bucketPrefix?: string;
        /**
         * The JDBC URL of the Amazon Redshift cluster.
         */
        databaseUrl: string;
        /**
         * The Amazon Resource Name (ARN) of the IAM role.
         */
        roleArn: string;
    }
    interface ConnectorProfileSAPODataConnectorProfileCredentials {
        basicAuthCredentials?: outputs.appflow.ConnectorProfileBasicAuthCredentials;
        oAuthCredentials?: outputs.appflow.ConnectorProfileSAPODataConnectorProfileCredentialsOAuthCredentialsProperties;
    }
    interface ConnectorProfileSAPODataConnectorProfileCredentialsOAuthCredentialsProperties {
        accessToken?: string;
        clientId?: string;
        clientSecret?: string;
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
        refreshToken?: string;
    }
    interface ConnectorProfileSAPODataConnectorProfileProperties {
        applicationHostUrl?: string;
        applicationServicePath?: string;
        clientNumber?: string;
        logonLanguage?: string;
        oAuthProperties?: outputs.appflow.ConnectorProfileOAuthProperties;
        portNumber?: number;
        privateLinkServiceName?: string;
    }
    interface ConnectorProfileSalesforceConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The client credentials to fetch access token and refresh token.
         */
        clientCredentialsArn?: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
        /**
         * The credentials used to acquire new access tokens.
         */
        refreshToken?: string;
    }
    interface ConnectorProfileSalesforceConnectorProfileProperties {
        /**
         * The location of the Salesforce resource
         */
        instanceUrl?: string;
        isSandboxEnvironment?: boolean;
    }
    interface ConnectorProfileServiceNowConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }
    interface ConnectorProfileServiceNowConnectorProfileProperties {
        /**
         * The location of the ServiceNow resource
         */
        instanceUrl: string;
    }
    interface ConnectorProfileSingularConnectorProfileCredentials {
        /**
         * A unique alphanumeric identiﬁer used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
    }
    interface ConnectorProfileSlackConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
    }
    interface ConnectorProfileSlackConnectorProfileProperties {
        /**
         * The location of the Slack resource
         */
        instanceUrl: string;
    }
    interface ConnectorProfileSnowflakeConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }
    interface ConnectorProfileSnowflakeConnectorProfileProperties {
        /**
         * The name of the account.
         */
        accountName?: string;
        /**
         * The name of the Amazon S3 bucket associated with Snowﬂake.
         */
        bucketName: string;
        /**
         * The bucket prefix that refers to the Amazon S3 bucket associated with Snowﬂake.
         */
        bucketPrefix?: string;
        /**
         * The Snowﬂake Private Link service name to be used for private data transfers.
         */
        privateLinkServiceName?: string;
        /**
         * The region of the Snowﬂake account.
         */
        region?: string;
        /**
         * The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the
         * Snowﬂake account. This is written in the following format: < Database>< Schema><Stage Name>.
         */
        stage: string;
        /**
         * The name of the Snowﬂake warehouse.
         */
        warehouse: string;
    }
    /**
     * A map for properties for custom connector Token Url.
     */
    interface ConnectorProfileTokenUrlCustomProperties {
    }
    interface ConnectorProfileTrendmicroConnectorProfileCredentials {
        /**
         * The Secret Access Key portion of the credentials.
         */
        apiSecretKey: string;
    }
    interface ConnectorProfileVeevaConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }
    interface ConnectorProfileVeevaConnectorProfileProperties {
        /**
         * The location of the Veeva resource
         */
        instanceUrl: string;
    }
    interface ConnectorProfileZendeskConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
    }
    interface ConnectorProfileZendeskConnectorProfileProperties {
        /**
         * The location of the Zendesk resource
         */
        instanceUrl: string;
    }
    interface FlowAggregationConfig {
        aggregationType?: enums.appflow.FlowAggregationType;
    }
    interface FlowAmplitudeSourceProperties {
        object: string;
    }
    /**
     * Operation to be performed on provided source fields
     */
    interface FlowConnectorOperator {
        amplitude?: enums.appflow.FlowAmplitudeConnectorOperator;
        customConnector?: enums.appflow.FlowOperator;
        datadog?: enums.appflow.FlowDatadogConnectorOperator;
        dynatrace?: enums.appflow.FlowDynatraceConnectorOperator;
        googleAnalytics?: enums.appflow.FlowGoogleAnalyticsConnectorOperator;
        inforNexus?: enums.appflow.FlowInforNexusConnectorOperator;
        marketo?: enums.appflow.FlowMarketoConnectorOperator;
        s3?: enums.appflow.FlowS3ConnectorOperator;
        sAPOData?: enums.appflow.FlowSAPODataConnectorOperator;
        salesforce?: enums.appflow.FlowSalesforceConnectorOperator;
        serviceNow?: enums.appflow.FlowServiceNowConnectorOperator;
        singular?: enums.appflow.FlowSingularConnectorOperator;
        slack?: enums.appflow.FlowSlackConnectorOperator;
        trendmicro?: enums.appflow.FlowTrendmicroConnectorOperator;
        veeva?: enums.appflow.FlowVeevaConnectorOperator;
        zendesk?: enums.appflow.FlowZendeskConnectorOperator;
    }
    interface FlowCustomConnectorDestinationProperties {
        customProperties?: outputs.appflow.FlowCustomProperties;
        entityName: string;
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: string[];
        writeOperationType?: enums.appflow.FlowWriteOperationType;
    }
    interface FlowCustomConnectorSourceProperties {
        customProperties?: outputs.appflow.FlowCustomProperties;
        entityName: string;
    }
    /**
     * A map for properties for custom connector.
     */
    interface FlowCustomProperties {
    }
    interface FlowDatadogSourceProperties {
        object: string;
    }
    /**
     * Destination connector details
     */
    interface FlowDestinationConnectorProperties {
        customConnector?: outputs.appflow.FlowCustomConnectorDestinationProperties;
        eventBridge?: outputs.appflow.FlowEventBridgeDestinationProperties;
        lookoutMetrics?: outputs.appflow.FlowLookoutMetricsDestinationProperties;
        marketo?: outputs.appflow.FlowMarketoDestinationProperties;
        redshift?: outputs.appflow.FlowRedshiftDestinationProperties;
        s3?: outputs.appflow.FlowS3DestinationProperties;
        sAPOData?: outputs.appflow.FlowSAPODataDestinationProperties;
        salesforce?: outputs.appflow.FlowSalesforceDestinationProperties;
        snowflake?: outputs.appflow.FlowSnowflakeDestinationProperties;
        upsolver?: outputs.appflow.FlowUpsolverDestinationProperties;
        zendesk?: outputs.appflow.FlowZendeskDestinationProperties;
    }
    /**
     * Configurations of destination connector.
     */
    interface FlowDestinationFlowConfig {
        /**
         * The API version that the destination connector uses.
         */
        apiVersion?: string;
        /**
         * Name of destination connector profile
         */
        connectorProfileName?: string;
        /**
         * Destination connector type
         */
        connectorType: enums.appflow.FlowConnectorType;
        /**
         * Destination connector details
         */
        destinationConnectorProperties: outputs.appflow.FlowDestinationConnectorProperties;
    }
    interface FlowDynatraceSourceProperties {
        object: string;
    }
    interface FlowErrorHandlingConfig {
        bucketName?: string;
        bucketPrefix?: string;
        failOnFirstError?: boolean;
    }
    interface FlowEventBridgeDestinationProperties {
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        object: string;
    }
    interface FlowGoogleAnalyticsSourceProperties {
        object: string;
    }
    /**
     * Configuration for scheduled incremental data pull
     */
    interface FlowIncrementalPullConfig {
        datetimeTypeFieldName?: string;
    }
    interface FlowInforNexusSourceProperties {
        object: string;
    }
    interface FlowLookoutMetricsDestinationProperties {
        object?: string;
    }
    interface FlowMarketoDestinationProperties {
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        object: string;
    }
    interface FlowMarketoSourceProperties {
        object: string;
    }
    interface FlowPrefixConfig {
        prefixFormat?: enums.appflow.FlowPrefixFormat;
        prefixType?: enums.appflow.FlowPrefixType;
    }
    interface FlowRedshiftDestinationProperties {
        bucketPrefix?: string;
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        intermediateBucketName: string;
        object: string;
    }
    interface FlowS3DestinationProperties {
        bucketName: string;
        bucketPrefix?: string;
        s3OutputFormatConfig?: outputs.appflow.FlowS3OutputFormatConfig;
    }
    interface FlowS3InputFormatConfig {
        s3InputFileType?: enums.appflow.FlowS3InputFormatConfigS3InputFileType;
    }
    interface FlowS3OutputFormatConfig {
        aggregationConfig?: outputs.appflow.FlowAggregationConfig;
        fileType?: enums.appflow.FlowFileType;
        prefixConfig?: outputs.appflow.FlowPrefixConfig;
        preserveSourceDataTyping?: boolean;
    }
    interface FlowS3SourceProperties {
        bucketName: string;
        bucketPrefix: string;
        s3InputFormatConfig?: outputs.appflow.FlowS3InputFormatConfig;
    }
    interface FlowSAPODataDestinationProperties {
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: string[];
        objectPath: string;
        successResponseHandlingConfig?: outputs.appflow.FlowSuccessResponseHandlingConfig;
        writeOperationType?: enums.appflow.FlowWriteOperationType;
    }
    interface FlowSAPODataSourceProperties {
        objectPath: string;
    }
    interface FlowSalesforceDestinationProperties {
        dataTransferApi?: enums.appflow.FlowDataTransferApi;
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: string[];
        object: string;
        writeOperationType?: enums.appflow.FlowWriteOperationType;
    }
    interface FlowSalesforceSourceProperties {
        dataTransferApi?: enums.appflow.FlowDataTransferApi;
        enableDynamicFieldUpdate?: boolean;
        includeDeletedRecords?: boolean;
        object: string;
    }
    /**
     * Details required for scheduled trigger type
     */
    interface FlowScheduledTriggerProperties {
        dataPullMode?: enums.appflow.FlowScheduledTriggerPropertiesDataPullMode;
        firstExecutionFrom?: number;
        flowErrorDeactivationThreshold?: number;
        scheduleEndTime?: number;
        scheduleExpression: string;
        scheduleOffset?: number;
        scheduleStartTime?: number;
        timeZone?: string;
    }
    interface FlowServiceNowSourceProperties {
        object: string;
    }
    interface FlowSingularSourceProperties {
        object: string;
    }
    interface FlowSlackSourceProperties {
        object: string;
    }
    interface FlowSnowflakeDestinationProperties {
        bucketPrefix?: string;
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        intermediateBucketName: string;
        object: string;
    }
    /**
     * Source connector details required to query a connector
     */
    interface FlowSourceConnectorProperties {
        amplitude?: outputs.appflow.FlowAmplitudeSourceProperties;
        customConnector?: outputs.appflow.FlowCustomConnectorSourceProperties;
        datadog?: outputs.appflow.FlowDatadogSourceProperties;
        dynatrace?: outputs.appflow.FlowDynatraceSourceProperties;
        googleAnalytics?: outputs.appflow.FlowGoogleAnalyticsSourceProperties;
        inforNexus?: outputs.appflow.FlowInforNexusSourceProperties;
        marketo?: outputs.appflow.FlowMarketoSourceProperties;
        s3?: outputs.appflow.FlowS3SourceProperties;
        sAPOData?: outputs.appflow.FlowSAPODataSourceProperties;
        salesforce?: outputs.appflow.FlowSalesforceSourceProperties;
        serviceNow?: outputs.appflow.FlowServiceNowSourceProperties;
        singular?: outputs.appflow.FlowSingularSourceProperties;
        slack?: outputs.appflow.FlowSlackSourceProperties;
        trendmicro?: outputs.appflow.FlowTrendmicroSourceProperties;
        veeva?: outputs.appflow.FlowVeevaSourceProperties;
        zendesk?: outputs.appflow.FlowZendeskSourceProperties;
    }
    /**
     * Configurations of Source connector of the flow.
     */
    interface FlowSourceFlowConfig {
        /**
         * The API version that the destination connector uses.
         */
        apiVersion?: string;
        /**
         * Name of source connector profile
         */
        connectorProfileName?: string;
        /**
         * Type of source connector
         */
        connectorType: enums.appflow.FlowConnectorType;
        /**
         * Configuration for scheduled incremental data pull
         */
        incrementalPullConfig?: outputs.appflow.FlowIncrementalPullConfig;
        /**
         * Source connector details required to query a connector
         */
        sourceConnectorProperties: outputs.appflow.FlowSourceConnectorProperties;
    }
    interface FlowSuccessResponseHandlingConfig {
        bucketName?: string;
        bucketPrefix?: string;
    }
    /**
     * A label for tagging AppFlow resources
     */
    interface FlowTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface FlowTask {
        /**
         * Operation to be performed on provided source fields
         */
        connectorOperator?: outputs.appflow.FlowConnectorOperator;
        /**
         * A field value on which source field should be validated
         */
        destinationField?: string;
        /**
         * Source fields on which particular task will be applied
         */
        sourceFields: string[];
        /**
         * A Map used to store task related info
         */
        taskProperties?: outputs.appflow.FlowTaskPropertiesObject[];
        /**
         * Type of task
         */
        taskType: enums.appflow.FlowTaskType;
    }
    /**
     * An object used to store task related info
     */
    interface FlowTaskPropertiesObject {
        key: enums.appflow.FlowOperatorPropertiesKeys;
        value: string;
    }
    interface FlowTrendmicroSourceProperties {
        object: string;
    }
    /**
     * Trigger settings of the flow.
     */
    interface FlowTriggerConfig {
        /**
         * Details required based on the type of trigger
         */
        triggerProperties?: outputs.appflow.FlowScheduledTriggerProperties;
        /**
         * Trigger type of the flow
         */
        triggerType: enums.appflow.FlowTriggerType;
    }
    interface FlowUpsolverDestinationProperties {
        bucketName: string;
        bucketPrefix?: string;
        s3OutputFormatConfig: outputs.appflow.FlowUpsolverS3OutputFormatConfig;
    }
    interface FlowUpsolverS3OutputFormatConfig {
        aggregationConfig?: outputs.appflow.FlowAggregationConfig;
        fileType?: enums.appflow.FlowFileType;
        prefixConfig: outputs.appflow.FlowPrefixConfig;
    }
    interface FlowVeevaSourceProperties {
        documentType?: string;
        includeAllVersions?: boolean;
        includeRenditions?: boolean;
        includeSourceFiles?: boolean;
        object: string;
    }
    interface FlowZendeskDestinationProperties {
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: string[];
        object: string;
        writeOperationType?: enums.appflow.FlowWriteOperationType;
    }
    interface FlowZendeskSourceProperties {
        object: string;
    }
}
export declare namespace appintegrations {
    interface DataIntegrationScheduleConfig {
        /**
         * The start date for objects to import in the first flow run. Epoch or ISO timestamp format is supported.
         */
        firstExecutionFrom: string;
        /**
         * The name of the object to pull from the data source.
         */
        object: string;
        /**
         * How often the data should be pulled from data source.
         */
        scheduleExpression: string;
    }
    /**
     * A label for tagging DataIntegration resources
     */
    interface DataIntegrationTag {
        /**
         * A key to identify the tag.
         */
        key: string;
        /**
         * Corresponding tag value for the key.
         */
        value: string;
    }
    interface EventIntegrationAssociation {
        /**
         * The metadata associated with the client.
         */
        clientAssociationMetadata?: outputs.appintegrations.EventIntegrationMetadata[];
        /**
         * The identifier for the client that is associated with the event integration.
         */
        clientId?: string;
        /**
         * The name of the Eventbridge rule.
         */
        eventBridgeRuleName?: string;
        /**
         * The Amazon Resource Name (ARN) for the event integration association.
         */
        eventIntegrationAssociationArn?: string;
        /**
         * The identifier for the event integration association.
         */
        eventIntegrationAssociationId?: string;
    }
    interface EventIntegrationEventFilter {
        /**
         * The source of the events.
         */
        source: string;
    }
    interface EventIntegrationMetadata {
        /**
         * A key to identify the metadata.
         */
        key: string;
        /**
         * Corresponding metadata value for the key.
         */
        value: string;
    }
    interface EventIntegrationTag {
        /**
         * A key to identify the tag.
         */
        key: string;
        /**
         * Corresponding tag value for the key.
         */
        value: string;
    }
}
export declare namespace applicationautoscaling {
    interface ScalableTargetAction {
        maxCapacity?: number;
        minCapacity?: number;
    }
    interface ScalableTargetScheduledAction {
        endTime?: string;
        scalableTargetAction?: outputs.applicationautoscaling.ScalableTargetAction;
        schedule: string;
        scheduledActionName: string;
        startTime?: string;
        timezone?: string;
    }
    interface ScalableTargetSuspendedState {
        dynamicScalingInSuspended?: boolean;
        dynamicScalingOutSuspended?: boolean;
        scheduledScalingSuspended?: boolean;
    }
    interface ScalingPolicyCustomizedMetricSpecification {
        dimensions?: outputs.applicationautoscaling.ScalingPolicyMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }
    interface ScalingPolicyMetricDimension {
        name: string;
        value: string;
    }
    interface ScalingPolicyPredefinedMetricSpecification {
        predefinedMetricType: string;
        resourceLabel?: string;
    }
    interface ScalingPolicyStepAdjustment {
        metricIntervalLowerBound?: number;
        metricIntervalUpperBound?: number;
        scalingAdjustment: number;
    }
    interface ScalingPolicyStepScalingPolicyConfiguration {
        adjustmentType?: string;
        cooldown?: number;
        metricAggregationType?: string;
        minAdjustmentMagnitude?: number;
        stepAdjustments?: outputs.applicationautoscaling.ScalingPolicyStepAdjustment[];
    }
    interface ScalingPolicyTargetTrackingScalingPolicyConfiguration {
        customizedMetricSpecification?: outputs.applicationautoscaling.ScalingPolicyCustomizedMetricSpecification;
        disableScaleIn?: boolean;
        predefinedMetricSpecification?: outputs.applicationautoscaling.ScalingPolicyPredefinedMetricSpecification;
        scaleInCooldown?: number;
        scaleOutCooldown?: number;
        targetValue: number;
    }
}
export declare namespace applicationinsights {
    /**
     * A CloudWatch alarm to be monitored for the component.
     */
    interface ApplicationAlarm {
        /**
         * The name of the CloudWatch alarm to be monitored for the component.
         */
        alarmName: string;
        /**
         * Indicates the degree of outage when the alarm goes off.
         */
        severity?: enums.applicationinsights.ApplicationAlarmSeverity;
    }
    /**
     * A metric to be monitored for the component.
     */
    interface ApplicationAlarmMetric {
        /**
         * The name of the metric to be monitored for the component.
         */
        alarmMetricName: string;
    }
    /**
     * The configuration settings of the component.
     */
    interface ApplicationComponentConfiguration {
        /**
         * The configuration settings
         */
        configurationDetails?: outputs.applicationinsights.ApplicationConfigurationDetails;
        /**
         * Sub component configurations of the component.
         */
        subComponentTypeConfigurations?: outputs.applicationinsights.ApplicationSubComponentTypeConfiguration[];
    }
    /**
     * The monitoring setting of the component.
     */
    interface ApplicationComponentMonitoringSetting {
        /**
         * The ARN of the compnonent.
         */
        componentARN?: string;
        /**
         * The component monitoring configuration mode.
         */
        componentConfigurationMode: enums.applicationinsights.ApplicationComponentMonitoringSettingComponentConfigurationMode;
        /**
         * The name of the component.
         */
        componentName?: string;
        /**
         * The monitoring configuration of the component.
         */
        customComponentConfiguration?: outputs.applicationinsights.ApplicationComponentConfiguration;
        /**
         * The overwritten settings on default component monitoring configuration.
         */
        defaultOverwriteComponentConfiguration?: outputs.applicationinsights.ApplicationComponentConfiguration;
        /**
         * The tier of the application component.
         */
        tier: string;
    }
    /**
     * The configuration settings.
     */
    interface ApplicationConfigurationDetails {
        /**
         * A list of metrics to monitor for the component.
         */
        alarmMetrics?: outputs.applicationinsights.ApplicationAlarmMetric[];
        /**
         * A list of alarms to monitor for the component.
         */
        alarms?: outputs.applicationinsights.ApplicationAlarm[];
        /**
         * The HA cluster Prometheus Exporter settings.
         */
        hAClusterPrometheusExporter?: outputs.applicationinsights.ApplicationHAClusterPrometheusExporter;
        /**
         * The HANA DB Prometheus Exporter settings.
         */
        hANAPrometheusExporter?: outputs.applicationinsights.ApplicationHANAPrometheusExporter;
        /**
         * The JMX Prometheus Exporter settings.
         */
        jMXPrometheusExporter?: outputs.applicationinsights.ApplicationJMXPrometheusExporter;
        /**
         * A list of logs to monitor for the component.
         */
        logs?: outputs.applicationinsights.ApplicationLog[];
        /**
         * A list of Windows Events to log.
         */
        windowsEvents?: outputs.applicationinsights.ApplicationWindowsEvent[];
    }
    /**
     * The custom grouped component.
     */
    interface ApplicationCustomComponent {
        /**
         * The name of the component.
         */
        componentName: string;
        /**
         * The list of resource ARNs that belong to the component.
         */
        resourceList: string[];
    }
    /**
     * The HA cluster Prometheus Exporter settings.
     */
    interface ApplicationHAClusterPrometheusExporter {
        /**
         * Prometheus exporter port.
         */
        prometheusPort?: string;
    }
    /**
     * The HANA DB Prometheus Exporter settings.
     */
    interface ApplicationHANAPrometheusExporter {
        /**
         * A flag which indicates agreeing to install SAP HANA DB client.
         */
        agreeToInstallHANADBClient: boolean;
        /**
         * The HANA DB port.
         */
        hANAPort: string;
        /**
         * HANA DB SID.
         */
        hANASID: string;
        /**
         * The secret name which manages the HANA DB credentials e.g. {
         *   "username": "<>",
         *   "password": "<>"
         * }.
         */
        hANASecretName: string;
        /**
         * Prometheus exporter port.
         */
        prometheusPort?: string;
    }
    /**
     * The JMX Prometheus Exporter settings.
     */
    interface ApplicationJMXPrometheusExporter {
        /**
         * Java agent host port
         */
        hostPort?: string;
        /**
         * JMX service URL.
         */
        jMXURL?: string;
        /**
         * Prometheus exporter port.
         */
        prometheusPort?: string;
    }
    /**
     * A log to be monitored for the component.
     */
    interface ApplicationLog {
        /**
         * The type of encoding of the logs to be monitored.
         */
        encoding?: enums.applicationinsights.ApplicationLogEncoding;
        /**
         * The CloudWatch log group name to be associated to the monitored log.
         */
        logGroupName?: string;
        /**
         * The path of the logs to be monitored.
         */
        logPath?: string;
        /**
         * The log type decides the log patterns against which Application Insights analyzes the log.
         */
        logType: string;
        /**
         * The name of the log pattern set.
         */
        patternSet?: string;
    }
    /**
     * The log pattern.
     */
    interface ApplicationLogPattern {
        /**
         * The log pattern.
         */
        pattern: string;
        /**
         * The name of the log pattern.
         */
        patternName: string;
        /**
         * Rank of the log pattern.
         */
        rank: number;
    }
    /**
     * The log pattern set.
     */
    interface ApplicationLogPatternSet {
        /**
         * The log patterns of a set.
         */
        logPatterns: outputs.applicationinsights.ApplicationLogPattern[];
        /**
         * The name of the log pattern set.
         */
        patternSetName: string;
    }
    /**
     * The configuration settings of sub components.
     */
    interface ApplicationSubComponentConfigurationDetails {
        /**
         * A list of metrics to monitor for the component.
         */
        alarmMetrics?: outputs.applicationinsights.ApplicationAlarmMetric[];
        /**
         * A list of logs to monitor for the component.
         */
        logs?: outputs.applicationinsights.ApplicationLog[];
        /**
         * A list of Windows Events to log.
         */
        windowsEvents?: outputs.applicationinsights.ApplicationWindowsEvent[];
    }
    /**
     * One type sub component configurations for the component.
     */
    interface ApplicationSubComponentTypeConfiguration {
        /**
         * The configuration settings of sub components.
         */
        subComponentConfigurationDetails: outputs.applicationinsights.ApplicationSubComponentConfigurationDetails;
        /**
         * The sub component type.
         */
        subComponentType: enums.applicationinsights.ApplicationSubComponentTypeConfigurationSubComponentType;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ApplicationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A Windows Event to be monitored for the component.
     */
    interface ApplicationWindowsEvent {
        /**
         * The levels of event to log.
         */
        eventLevels: enums.applicationinsights.ApplicationEventLevel[];
        /**
         * The type of Windows Events to log.
         */
        eventName: string;
        /**
         * The CloudWatch log group name to be associated to the monitored log.
         */
        logGroupName: string;
        /**
         * The name of the log pattern set.
         */
        patternSet?: string;
    }
}
export declare namespace appmesh {
    interface GatewayRouteGrpcGatewayRoute {
        action: outputs.appmesh.GatewayRouteGrpcGatewayRouteAction;
        match: outputs.appmesh.GatewayRouteGrpcGatewayRouteMatch;
    }
    interface GatewayRouteGrpcGatewayRouteAction {
        rewrite?: outputs.appmesh.GatewayRouteGrpcGatewayRouteRewrite;
        target: outputs.appmesh.GatewayRouteTarget;
    }
    interface GatewayRouteGrpcGatewayRouteMatch {
        hostname?: outputs.appmesh.GatewayRouteHostnameMatch;
        metadata?: outputs.appmesh.GatewayRouteGrpcGatewayRouteMetadata[];
        port?: number;
        serviceName?: string;
    }
    interface GatewayRouteGrpcGatewayRouteMetadata {
        invert?: boolean;
        match?: outputs.appmesh.GatewayRouteMetadataMatch;
        name: string;
    }
    interface GatewayRouteGrpcGatewayRouteRewrite {
        hostname?: outputs.appmesh.GatewayRouteHostnameRewrite;
    }
    interface GatewayRouteHostnameMatch {
        exact?: string;
        suffix?: string;
    }
    interface GatewayRouteHostnameRewrite {
        defaultTargetHostname?: string;
    }
    interface GatewayRouteHttpGatewayRoute {
        action: outputs.appmesh.GatewayRouteHttpGatewayRouteAction;
        match: outputs.appmesh.GatewayRouteHttpGatewayRouteMatch;
    }
    interface GatewayRouteHttpGatewayRouteAction {
        rewrite?: outputs.appmesh.GatewayRouteHttpGatewayRouteRewrite;
        target: outputs.appmesh.GatewayRouteTarget;
    }
    interface GatewayRouteHttpGatewayRouteHeader {
        invert?: boolean;
        match?: outputs.appmesh.GatewayRouteHttpGatewayRouteHeaderMatch;
        name: string;
    }
    interface GatewayRouteHttpGatewayRouteHeaderMatch {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.GatewayRouteRangeMatch;
        regex?: string;
        suffix?: string;
    }
    interface GatewayRouteHttpGatewayRouteMatch {
        headers?: outputs.appmesh.GatewayRouteHttpGatewayRouteHeader[];
        hostname?: outputs.appmesh.GatewayRouteHostnameMatch;
        method?: string;
        path?: outputs.appmesh.GatewayRouteHttpPathMatch;
        port?: number;
        prefix?: string;
        queryParameters?: outputs.appmesh.GatewayRouteQueryParameter[];
    }
    interface GatewayRouteHttpGatewayRoutePathRewrite {
        exact?: string;
    }
    interface GatewayRouteHttpGatewayRoutePrefixRewrite {
        defaultPrefix?: string;
        value?: string;
    }
    interface GatewayRouteHttpGatewayRouteRewrite {
        hostname?: outputs.appmesh.GatewayRouteHostnameRewrite;
        path?: outputs.appmesh.GatewayRouteHttpGatewayRoutePathRewrite;
        prefix?: outputs.appmesh.GatewayRouteHttpGatewayRoutePrefixRewrite;
    }
    interface GatewayRouteHttpPathMatch {
        exact?: string;
        regex?: string;
    }
    interface GatewayRouteHttpQueryParameterMatch {
        exact?: string;
    }
    interface GatewayRouteMetadataMatch {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.GatewayRouteRangeMatch;
        regex?: string;
        suffix?: string;
    }
    interface GatewayRouteQueryParameter {
        match?: outputs.appmesh.GatewayRouteHttpQueryParameterMatch;
        name: string;
    }
    interface GatewayRouteRangeMatch {
        end: number;
        start: number;
    }
    interface GatewayRouteSpec {
        grpcRoute?: outputs.appmesh.GatewayRouteGrpcGatewayRoute;
        http2Route?: outputs.appmesh.GatewayRouteHttpGatewayRoute;
        httpRoute?: outputs.appmesh.GatewayRouteHttpGatewayRoute;
        priority?: number;
    }
    interface GatewayRouteTag {
        key: string;
        value: string;
    }
    interface GatewayRouteTarget {
        port?: number;
        virtualService: outputs.appmesh.GatewayRouteVirtualService;
    }
    interface GatewayRouteVirtualService {
        virtualServiceName: string;
    }
    interface MeshEgressFilter {
        type: string;
    }
    interface MeshServiceDiscovery {
        ipPreference?: string;
    }
    interface MeshSpec {
        egressFilter?: outputs.appmesh.MeshEgressFilter;
        serviceDiscovery?: outputs.appmesh.MeshServiceDiscovery;
    }
    interface MeshTag {
        key: string;
        value: string;
    }
    interface RouteDuration {
        unit: string;
        value: number;
    }
    interface RouteGrpcRetryPolicy {
        grpcRetryEvents?: string[];
        httpRetryEvents?: string[];
        maxRetries: number;
        perRetryTimeout: outputs.appmesh.RouteDuration;
        tcpRetryEvents?: string[];
    }
    interface RouteGrpcRoute {
        action: outputs.appmesh.RouteGrpcRouteAction;
        match: outputs.appmesh.RouteGrpcRouteMatch;
        retryPolicy?: outputs.appmesh.RouteGrpcRetryPolicy;
        timeout?: outputs.appmesh.RouteGrpcTimeout;
    }
    interface RouteGrpcRouteAction {
        weightedTargets: outputs.appmesh.RouteWeightedTarget[];
    }
    interface RouteGrpcRouteMatch {
        metadata?: outputs.appmesh.RouteGrpcRouteMetadata[];
        methodName?: string;
        port?: number;
        serviceName?: string;
    }
    interface RouteGrpcRouteMetadata {
        invert?: boolean;
        match?: outputs.appmesh.RouteGrpcRouteMetadataMatchMethod;
        name: string;
    }
    interface RouteGrpcRouteMetadataMatchMethod {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.RouteMatchRange;
        regex?: string;
        suffix?: string;
    }
    interface RouteGrpcTimeout {
        idle?: outputs.appmesh.RouteDuration;
        perRequest?: outputs.appmesh.RouteDuration;
    }
    interface RouteHeaderMatchMethod {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.RouteMatchRange;
        regex?: string;
        suffix?: string;
    }
    interface RouteHttpPathMatch {
        exact?: string;
        regex?: string;
    }
    interface RouteHttpQueryParameterMatch {
        exact?: string;
    }
    interface RouteHttpRetryPolicy {
        httpRetryEvents?: string[];
        maxRetries: number;
        perRetryTimeout: outputs.appmesh.RouteDuration;
        tcpRetryEvents?: string[];
    }
    interface RouteHttpRoute {
        action: outputs.appmesh.RouteHttpRouteAction;
        match: outputs.appmesh.RouteHttpRouteMatch;
        retryPolicy?: outputs.appmesh.RouteHttpRetryPolicy;
        timeout?: outputs.appmesh.RouteHttpTimeout;
    }
    interface RouteHttpRouteAction {
        weightedTargets: outputs.appmesh.RouteWeightedTarget[];
    }
    interface RouteHttpRouteHeader {
        invert?: boolean;
        match?: outputs.appmesh.RouteHeaderMatchMethod;
        name: string;
    }
    interface RouteHttpRouteMatch {
        headers?: outputs.appmesh.RouteHttpRouteHeader[];
        method?: string;
        path?: outputs.appmesh.RouteHttpPathMatch;
        port?: number;
        prefix?: string;
        queryParameters?: outputs.appmesh.RouteQueryParameter[];
        scheme?: string;
    }
    interface RouteHttpTimeout {
        idle?: outputs.appmesh.RouteDuration;
        perRequest?: outputs.appmesh.RouteDuration;
    }
    interface RouteMatchRange {
        end: number;
        start: number;
    }
    interface RouteQueryParameter {
        match?: outputs.appmesh.RouteHttpQueryParameterMatch;
        name: string;
    }
    interface RouteSpec {
        grpcRoute?: outputs.appmesh.RouteGrpcRoute;
        http2Route?: outputs.appmesh.RouteHttpRoute;
        httpRoute?: outputs.appmesh.RouteHttpRoute;
        priority?: number;
        tcpRoute?: outputs.appmesh.RouteTcpRoute;
    }
    interface RouteTag {
        key: string;
        value: string;
    }
    interface RouteTcpRoute {
        action: outputs.appmesh.RouteTcpRouteAction;
        match?: outputs.appmesh.RouteTcpRouteMatch;
        timeout?: outputs.appmesh.RouteTcpTimeout;
    }
    interface RouteTcpRouteAction {
        weightedTargets: outputs.appmesh.RouteWeightedTarget[];
    }
    interface RouteTcpRouteMatch {
        port?: number;
    }
    interface RouteTcpTimeout {
        idle?: outputs.appmesh.RouteDuration;
    }
    interface RouteWeightedTarget {
        port?: number;
        virtualNode: string;
        weight: number;
    }
    interface VirtualGatewayAccessLog {
        file?: outputs.appmesh.VirtualGatewayFileAccessLog;
    }
    interface VirtualGatewayBackendDefaults {
        clientPolicy?: outputs.appmesh.VirtualGatewayClientPolicy;
    }
    interface VirtualGatewayClientPolicy {
        tLS?: outputs.appmesh.VirtualGatewayClientPolicyTls;
    }
    interface VirtualGatewayClientPolicyTls {
        certificate?: outputs.appmesh.VirtualGatewayClientTlsCertificate;
        enforce?: boolean;
        ports?: number[];
        validation: outputs.appmesh.VirtualGatewayTlsValidationContext;
    }
    interface VirtualGatewayClientTlsCertificate {
        file?: outputs.appmesh.VirtualGatewayListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualGatewayListenerTlsSdsCertificate;
    }
    interface VirtualGatewayConnectionPool {
        gRPC?: outputs.appmesh.VirtualGatewayGrpcConnectionPool;
        hTTP?: outputs.appmesh.VirtualGatewayHttpConnectionPool;
        hTTP2?: outputs.appmesh.VirtualGatewayHttp2ConnectionPool;
    }
    interface VirtualGatewayFileAccessLog {
        format?: outputs.appmesh.VirtualGatewayLoggingFormat;
        path: string;
    }
    interface VirtualGatewayGrpcConnectionPool {
        maxRequests: number;
    }
    interface VirtualGatewayHealthCheckPolicy {
        healthyThreshold: number;
        intervalMillis: number;
        path?: string;
        port?: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }
    interface VirtualGatewayHttp2ConnectionPool {
        maxRequests: number;
    }
    interface VirtualGatewayHttpConnectionPool {
        maxConnections: number;
        maxPendingRequests?: number;
    }
    interface VirtualGatewayJsonFormatRef {
        key: string;
        value: string;
    }
    interface VirtualGatewayListener {
        connectionPool?: outputs.appmesh.VirtualGatewayConnectionPool;
        healthCheck?: outputs.appmesh.VirtualGatewayHealthCheckPolicy;
        portMapping: outputs.appmesh.VirtualGatewayPortMapping;
        tLS?: outputs.appmesh.VirtualGatewayListenerTls;
    }
    interface VirtualGatewayListenerTls {
        certificate: outputs.appmesh.VirtualGatewayListenerTlsCertificate;
        mode: string;
        validation?: outputs.appmesh.VirtualGatewayListenerTlsValidationContext;
    }
    interface VirtualGatewayListenerTlsAcmCertificate {
        certificateArn: string;
    }
    interface VirtualGatewayListenerTlsCertificate {
        aCM?: outputs.appmesh.VirtualGatewayListenerTlsAcmCertificate;
        file?: outputs.appmesh.VirtualGatewayListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualGatewayListenerTlsSdsCertificate;
    }
    interface VirtualGatewayListenerTlsFileCertificate {
        certificateChain: string;
        privateKey: string;
    }
    interface VirtualGatewayListenerTlsSdsCertificate {
        secretName: string;
    }
    interface VirtualGatewayListenerTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySubjectAlternativeNames;
        trust: outputs.appmesh.VirtualGatewayListenerTlsValidationContextTrust;
    }
    interface VirtualGatewayListenerTlsValidationContextTrust {
        file?: outputs.appmesh.VirtualGatewayTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualGatewayTlsValidationContextSdsTrust;
    }
    interface VirtualGatewayLogging {
        accessLog?: outputs.appmesh.VirtualGatewayAccessLog;
    }
    interface VirtualGatewayLoggingFormat {
        json?: outputs.appmesh.VirtualGatewayJsonFormatRef[];
        text?: string;
    }
    interface VirtualGatewayPortMapping {
        port: number;
        protocol: string;
    }
    interface VirtualGatewaySpec {
        backendDefaults?: outputs.appmesh.VirtualGatewayBackendDefaults;
        listeners: outputs.appmesh.VirtualGatewayListener[];
        logging?: outputs.appmesh.VirtualGatewayLogging;
    }
    interface VirtualGatewaySubjectAlternativeNameMatchers {
        exact?: string[];
    }
    interface VirtualGatewaySubjectAlternativeNames {
        match: outputs.appmesh.VirtualGatewaySubjectAlternativeNameMatchers;
    }
    interface VirtualGatewayTag {
        key: string;
        value: string;
    }
    interface VirtualGatewayTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySubjectAlternativeNames;
        trust: outputs.appmesh.VirtualGatewayTlsValidationContextTrust;
    }
    interface VirtualGatewayTlsValidationContextAcmTrust {
        certificateAuthorityArns: string[];
    }
    interface VirtualGatewayTlsValidationContextFileTrust {
        certificateChain: string;
    }
    interface VirtualGatewayTlsValidationContextSdsTrust {
        secretName: string;
    }
    interface VirtualGatewayTlsValidationContextTrust {
        aCM?: outputs.appmesh.VirtualGatewayTlsValidationContextAcmTrust;
        file?: outputs.appmesh.VirtualGatewayTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualGatewayTlsValidationContextSdsTrust;
    }
    interface VirtualNodeAccessLog {
        file?: outputs.appmesh.VirtualNodeFileAccessLog;
    }
    interface VirtualNodeAwsCloudMapInstanceAttribute {
        key: string;
        value: string;
    }
    interface VirtualNodeAwsCloudMapServiceDiscovery {
        attributes?: outputs.appmesh.VirtualNodeAwsCloudMapInstanceAttribute[];
        ipPreference?: string;
        namespaceName: string;
        serviceName: string;
    }
    interface VirtualNodeBackend {
        virtualService?: outputs.appmesh.VirtualNodeVirtualServiceBackend;
    }
    interface VirtualNodeBackendDefaults {
        clientPolicy?: outputs.appmesh.VirtualNodeClientPolicy;
    }
    interface VirtualNodeClientPolicy {
        tLS?: outputs.appmesh.VirtualNodeClientPolicyTls;
    }
    interface VirtualNodeClientPolicyTls {
        certificate?: outputs.appmesh.VirtualNodeClientTlsCertificate;
        enforce?: boolean;
        ports?: number[];
        validation: outputs.appmesh.VirtualNodeTlsValidationContext;
    }
    interface VirtualNodeClientTlsCertificate {
        file?: outputs.appmesh.VirtualNodeListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualNodeListenerTlsSdsCertificate;
    }
    interface VirtualNodeConnectionPool {
        gRPC?: outputs.appmesh.VirtualNodeGrpcConnectionPool;
        hTTP?: outputs.appmesh.VirtualNodeHttpConnectionPool;
        hTTP2?: outputs.appmesh.VirtualNodeHttp2ConnectionPool;
        tCP?: outputs.appmesh.VirtualNodeTcpConnectionPool;
    }
    interface VirtualNodeDnsServiceDiscovery {
        hostname: string;
        ipPreference?: string;
        responseType?: string;
    }
    interface VirtualNodeDuration {
        unit: string;
        value: number;
    }
    interface VirtualNodeFileAccessLog {
        format?: outputs.appmesh.VirtualNodeLoggingFormat;
        path: string;
    }
    interface VirtualNodeGrpcConnectionPool {
        maxRequests: number;
    }
    interface VirtualNodeGrpcTimeout {
        idle?: outputs.appmesh.VirtualNodeDuration;
        perRequest?: outputs.appmesh.VirtualNodeDuration;
    }
    interface VirtualNodeHealthCheck {
        healthyThreshold: number;
        intervalMillis: number;
        path?: string;
        port?: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }
    interface VirtualNodeHttp2ConnectionPool {
        maxRequests: number;
    }
    interface VirtualNodeHttpConnectionPool {
        maxConnections: number;
        maxPendingRequests?: number;
    }
    interface VirtualNodeHttpTimeout {
        idle?: outputs.appmesh.VirtualNodeDuration;
        perRequest?: outputs.appmesh.VirtualNodeDuration;
    }
    interface VirtualNodeJsonFormatRef {
        key: string;
        value: string;
    }
    interface VirtualNodeListener {
        connectionPool?: outputs.appmesh.VirtualNodeConnectionPool;
        healthCheck?: outputs.appmesh.VirtualNodeHealthCheck;
        outlierDetection?: outputs.appmesh.VirtualNodeOutlierDetection;
        portMapping: outputs.appmesh.VirtualNodePortMapping;
        tLS?: outputs.appmesh.VirtualNodeListenerTls;
        timeout?: outputs.appmesh.VirtualNodeListenerTimeout;
    }
    interface VirtualNodeListenerTimeout {
        gRPC?: outputs.appmesh.VirtualNodeGrpcTimeout;
        hTTP?: outputs.appmesh.VirtualNodeHttpTimeout;
        hTTP2?: outputs.appmesh.VirtualNodeHttpTimeout;
        tCP?: outputs.appmesh.VirtualNodeTcpTimeout;
    }
    interface VirtualNodeListenerTls {
        certificate: outputs.appmesh.VirtualNodeListenerTlsCertificate;
        mode: string;
        validation?: outputs.appmesh.VirtualNodeListenerTlsValidationContext;
    }
    interface VirtualNodeListenerTlsAcmCertificate {
        certificateArn: string;
    }
    interface VirtualNodeListenerTlsCertificate {
        aCM?: outputs.appmesh.VirtualNodeListenerTlsAcmCertificate;
        file?: outputs.appmesh.VirtualNodeListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualNodeListenerTlsSdsCertificate;
    }
    interface VirtualNodeListenerTlsFileCertificate {
        certificateChain: string;
        privateKey: string;
    }
    interface VirtualNodeListenerTlsSdsCertificate {
        secretName: string;
    }
    interface VirtualNodeListenerTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSubjectAlternativeNames;
        trust: outputs.appmesh.VirtualNodeListenerTlsValidationContextTrust;
    }
    interface VirtualNodeListenerTlsValidationContextTrust {
        file?: outputs.appmesh.VirtualNodeTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualNodeTlsValidationContextSdsTrust;
    }
    interface VirtualNodeLogging {
        accessLog?: outputs.appmesh.VirtualNodeAccessLog;
    }
    interface VirtualNodeLoggingFormat {
        json?: outputs.appmesh.VirtualNodeJsonFormatRef[];
        text?: string;
    }
    interface VirtualNodeOutlierDetection {
        baseEjectionDuration: outputs.appmesh.VirtualNodeDuration;
        interval: outputs.appmesh.VirtualNodeDuration;
        maxEjectionPercent: number;
        maxServerErrors: number;
    }
    interface VirtualNodePortMapping {
        port: number;
        protocol: string;
    }
    interface VirtualNodeServiceDiscovery {
        aWSCloudMap?: outputs.appmesh.VirtualNodeAwsCloudMapServiceDiscovery;
        dNS?: outputs.appmesh.VirtualNodeDnsServiceDiscovery;
    }
    interface VirtualNodeSpec {
        backendDefaults?: outputs.appmesh.VirtualNodeBackendDefaults;
        backends?: outputs.appmesh.VirtualNodeBackend[];
        listeners?: outputs.appmesh.VirtualNodeListener[];
        logging?: outputs.appmesh.VirtualNodeLogging;
        serviceDiscovery?: outputs.appmesh.VirtualNodeServiceDiscovery;
    }
    interface VirtualNodeSubjectAlternativeNameMatchers {
        exact?: string[];
    }
    interface VirtualNodeSubjectAlternativeNames {
        match: outputs.appmesh.VirtualNodeSubjectAlternativeNameMatchers;
    }
    interface VirtualNodeTag {
        key: string;
        value: string;
    }
    interface VirtualNodeTcpConnectionPool {
        maxConnections: number;
    }
    interface VirtualNodeTcpTimeout {
        idle?: outputs.appmesh.VirtualNodeDuration;
    }
    interface VirtualNodeTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSubjectAlternativeNames;
        trust: outputs.appmesh.VirtualNodeTlsValidationContextTrust;
    }
    interface VirtualNodeTlsValidationContextAcmTrust {
        certificateAuthorityArns: string[];
    }
    interface VirtualNodeTlsValidationContextFileTrust {
        certificateChain: string;
    }
    interface VirtualNodeTlsValidationContextSdsTrust {
        secretName: string;
    }
    interface VirtualNodeTlsValidationContextTrust {
        aCM?: outputs.appmesh.VirtualNodeTlsValidationContextAcmTrust;
        file?: outputs.appmesh.VirtualNodeTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualNodeTlsValidationContextSdsTrust;
    }
    interface VirtualNodeVirtualServiceBackend {
        clientPolicy?: outputs.appmesh.VirtualNodeClientPolicy;
        virtualServiceName: string;
    }
    interface VirtualRouterListener {
        portMapping: outputs.appmesh.VirtualRouterPortMapping;
    }
    interface VirtualRouterPortMapping {
        port: number;
        protocol: string;
    }
    interface VirtualRouterSpec {
        listeners: outputs.appmesh.VirtualRouterListener[];
    }
    interface VirtualRouterTag {
        key: string;
        value: string;
    }
    interface VirtualServiceProvider {
        virtualNode?: outputs.appmesh.VirtualServiceVirtualNodeServiceProvider;
        virtualRouter?: outputs.appmesh.VirtualServiceVirtualRouterServiceProvider;
    }
    interface VirtualServiceSpec {
        provider?: outputs.appmesh.VirtualServiceProvider;
    }
    interface VirtualServiceTag {
        key: string;
        value: string;
    }
    interface VirtualServiceVirtualNodeServiceProvider {
        virtualNodeName: string;
    }
    interface VirtualServiceVirtualRouterServiceProvider {
        virtualRouterName: string;
    }
}
export declare namespace apprunner {
    interface ObservabilityConfigurationTag {
        key?: string;
        value?: string;
    }
    /**
     * Describes the configuration of the tracing feature within an AWS App Runner observability configuration.
     */
    interface ObservabilityConfigurationTraceConfiguration {
        /**
         * The implementation provider chosen for tracing App Runner services.
         */
        vendor: enums.apprunner.ObservabilityConfigurationTraceConfigurationVendor;
    }
    /**
     * Authentication Configuration
     */
    interface ServiceAuthenticationConfiguration {
        /**
         * Access Role Arn
         */
        accessRoleArn?: string;
        /**
         * Connection Arn
         */
        connectionArn?: string;
    }
    /**
     * Code Configuration
     */
    interface ServiceCodeConfiguration {
        codeConfigurationValues?: outputs.apprunner.ServiceCodeConfigurationValues;
        /**
         * Configuration Source
         */
        configurationSource: enums.apprunner.ServiceCodeConfigurationConfigurationSource;
    }
    /**
     * Code Configuration Values
     */
    interface ServiceCodeConfigurationValues {
        /**
         * Build Command
         */
        buildCommand?: string;
        /**
         * Port
         */
        port?: string;
        /**
         * Runtime
         */
        runtime: enums.apprunner.ServiceCodeConfigurationValuesRuntime;
        runtimeEnvironmentVariables?: outputs.apprunner.ServiceKeyValuePair[];
        /**
         * Start Command
         */
        startCommand?: string;
    }
    /**
     * Source Code Repository
     */
    interface ServiceCodeRepository {
        codeConfiguration?: outputs.apprunner.ServiceCodeConfiguration;
        /**
         * Repository Url
         */
        repositoryUrl: string;
        sourceCodeVersion: outputs.apprunner.ServiceSourceCodeVersion;
    }
    /**
     * Network egress configuration
     */
    interface ServiceEgressConfiguration {
        /**
         * Network egress type.
         */
        egressType: enums.apprunner.ServiceEgressConfigurationEgressType;
        /**
         * The Amazon Resource Name (ARN) of the App Runner VpcConnector.
         */
        vpcConnectorArn?: string;
    }
    /**
     * Encryption configuration (KMS key)
     */
    interface ServiceEncryptionConfiguration {
        /**
         * The KMS Key
         */
        kmsKey: string;
    }
    /**
     * Health check configuration
     */
    interface ServiceHealthCheckConfiguration {
        /**
         * Health check Healthy Threshold
         */
        healthyThreshold?: number;
        /**
         * Health check Interval
         */
        interval?: number;
        /**
         * Health check Path
         */
        path?: string;
        /**
         * Health Check Protocol
         */
        protocol?: enums.apprunner.ServiceHealthCheckConfigurationProtocol;
        /**
         * Health check Timeout
         */
        timeout?: number;
        /**
         * Health check Unhealthy Threshold
         */
        unhealthyThreshold?: number;
    }
    /**
     * Image Configuration
     */
    interface ServiceImageConfiguration {
        /**
         * Port
         */
        port?: string;
        runtimeEnvironmentVariables?: outputs.apprunner.ServiceKeyValuePair[];
        /**
         * Start Command
         */
        startCommand?: string;
    }
    /**
     * Image Repository
     */
    interface ServiceImageRepository {
        imageConfiguration?: outputs.apprunner.ServiceImageConfiguration;
        /**
         * Image Identifier
         */
        imageIdentifier: string;
        /**
         * Image Repository Type
         */
        imageRepositoryType: enums.apprunner.ServiceImageRepositoryImageRepositoryType;
    }
    /**
     * Network ingress configuration
     */
    interface ServiceIngressConfiguration {
        /**
         * It's set to true if the Apprunner service is publicly accessible. It's set to false otherwise.
         */
        isPubliclyAccessible: boolean;
    }
    /**
     * Instance Configuration
     */
    interface ServiceInstanceConfiguration {
        /**
         * CPU
         */
        cpu?: string;
        /**
         * Instance Role Arn
         */
        instanceRoleArn?: string;
        /**
         * Memory
         */
        memory?: string;
    }
    interface ServiceKeyValuePair {
        name?: string;
        value?: string;
    }
    /**
     * Network configuration
     */
    interface ServiceNetworkConfiguration {
        egressConfiguration?: outputs.apprunner.ServiceEgressConfiguration;
        ingressConfiguration?: outputs.apprunner.ServiceIngressConfiguration;
    }
    /**
     * Service observability configuration
     */
    interface ServiceObservabilityConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the App Runner ObservabilityConfiguration.
         */
        observabilityConfigurationArn?: string;
        /**
         * Observability enabled
         */
        observabilityEnabled: boolean;
    }
    /**
     * Source Code Version
     */
    interface ServiceSourceCodeVersion {
        /**
         * Source Code Version Type
         */
        type: enums.apprunner.ServiceSourceCodeVersionType;
        /**
         * Source Code Version Value
         */
        value: string;
    }
    /**
     * Source Code configuration
     */
    interface ServiceSourceConfiguration {
        authenticationConfiguration?: outputs.apprunner.ServiceAuthenticationConfiguration;
        /**
         * Auto Deployment enabled
         */
        autoDeploymentsEnabled?: boolean;
        codeRepository?: outputs.apprunner.ServiceCodeRepository;
        imageRepository?: outputs.apprunner.ServiceImageRepository;
    }
    interface ServiceTag {
        key?: string;
        value?: string;
    }
    interface VpcConnectorTag {
        key?: string;
        value?: string;
    }
    /**
     * The configuration of customer’s VPC and related VPC endpoint
     */
    interface VpcIngressConnectionIngressVpcConfiguration {
        /**
         * The ID of the VPC endpoint that your App Runner service connects to.
         */
        vpcEndpointId: string;
        /**
         * The ID of the VPC that the VPC endpoint is used in.
         */
        vpcId: string;
    }
    interface VpcIngressConnectionTag {
        key?: string;
        value?: string;
    }
}
export declare namespace appstream {
    interface AppBlockS3Location {
        s3Bucket: string;
        s3Key: string;
    }
    interface AppBlockScriptDetails {
        executableParameters?: string;
        executablePath: string;
        scriptS3Location: outputs.appstream.AppBlockS3Location;
        timeoutInSeconds: number;
    }
    interface AppBlockTag {
        tagKey: string;
        tagValue: string;
    }
    interface ApplicationS3Location {
        s3Bucket: string;
        s3Key: string;
    }
    interface ApplicationTag {
        tagKey: string;
        tagValue: string;
    }
    interface DirectoryConfigServiceAccountCredentials {
        accountName: string;
        accountPassword: string;
    }
    interface EntitlementAttribute {
        name: string;
        value: string;
    }
    interface FleetComputeCapacity {
        desiredInstances: number;
    }
    interface FleetDomainJoinInfo {
        directoryName?: string;
        organizationalUnitDistinguishedName?: string;
    }
    interface FleetS3Location {
        s3Bucket: string;
        s3Key: string;
    }
    interface FleetTag {
        key: string;
        value: string;
    }
    interface FleetVpcConfig {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }
    interface ImageBuilderAccessEndpoint {
        endpointType: string;
        vpceId: string;
    }
    interface ImageBuilderDomainJoinInfo {
        directoryName?: string;
        organizationalUnitDistinguishedName?: string;
    }
    interface ImageBuilderTag {
        key: string;
        value: string;
    }
    interface ImageBuilderVpcConfig {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }
    interface StackAccessEndpoint {
        endpointType: string;
        vpceId: string;
    }
    interface StackApplicationSettings {
        enabled: boolean;
        settingsGroup?: string;
    }
    interface StackStorageConnector {
        connectorType: string;
        domains?: string[];
        resourceIdentifier?: string;
    }
    interface StackStreamingExperienceSettings {
        preferredProtocol?: string;
    }
    interface StackTag {
        key: string;
        value: string;
    }
    interface StackUserSetting {
        action: string;
        permission: string;
    }
}
export declare namespace appsync {
    interface DataSourceAuthorizationConfig {
        authorizationType: string;
        awsIamConfig?: outputs.appsync.DataSourceAwsIamConfig;
    }
    interface DataSourceAwsIamConfig {
        signingRegion?: string;
        signingServiceName?: string;
    }
    interface DataSourceDeltaSyncConfig {
        baseTableTTL: string;
        deltaSyncTableName: string;
        deltaSyncTableTTL: string;
    }
    interface DataSourceDynamoDBConfig {
        awsRegion: string;
        deltaSyncConfig?: outputs.appsync.DataSourceDeltaSyncConfig;
        tableName: string;
        useCallerCredentials?: boolean;
        versioned?: boolean;
    }
    interface DataSourceElasticsearchConfig {
        awsRegion: string;
        endpoint: string;
    }
    interface DataSourceHttpConfig {
        authorizationConfig?: outputs.appsync.DataSourceAuthorizationConfig;
        endpoint: string;
    }
    interface DataSourceLambdaConfig {
        lambdaFunctionArn: string;
    }
    interface DataSourceOpenSearchServiceConfig {
        awsRegion: string;
        endpoint: string;
    }
    interface DataSourceRdsHttpEndpointConfig {
        awsRegion: string;
        awsSecretStoreArn: string;
        databaseName?: string;
        dbClusterIdentifier: string;
        schema?: string;
    }
    interface DataSourceRelationalDatabaseConfig {
        rdsHttpEndpointConfig?: outputs.appsync.DataSourceRdsHttpEndpointConfig;
        relationalDatabaseSourceType: string;
    }
    interface FunctionConfigurationLambdaConflictHandlerConfig {
        lambdaConflictHandlerArn?: string;
    }
    interface FunctionConfigurationSyncConfig {
        conflictDetection: string;
        conflictHandler?: string;
        lambdaConflictHandlerConfig?: outputs.appsync.FunctionConfigurationLambdaConflictHandlerConfig;
    }
    interface GraphQLApiAdditionalAuthenticationProvider {
        authenticationType: string;
        lambdaAuthorizerConfig?: outputs.appsync.GraphQLApiLambdaAuthorizerConfig;
        openIDConnectConfig?: outputs.appsync.GraphQLApiOpenIDConnectConfig;
        userPoolConfig?: outputs.appsync.GraphQLApiCognitoUserPoolConfig;
    }
    interface GraphQLApiCognitoUserPoolConfig {
        appIdClientRegex?: string;
        awsRegion?: string;
        userPoolId?: string;
    }
    interface GraphQLApiLambdaAuthorizerConfig {
        authorizerResultTtlInSeconds?: number;
        authorizerUri?: string;
        identityValidationExpression?: string;
    }
    interface GraphQLApiLogConfig {
        cloudWatchLogsRoleArn?: string;
        excludeVerboseContent?: boolean;
        fieldLogLevel?: string;
    }
    interface GraphQLApiOpenIDConnectConfig {
        authTTL?: number;
        clientId?: string;
        iatTTL?: number;
        issuer?: string;
    }
    interface GraphQLApiTag {
        key: string;
        value: string;
    }
    interface GraphQLApiUserPoolConfig {
        appIdClientRegex?: string;
        awsRegion?: string;
        defaultAction?: string;
        userPoolId?: string;
    }
    interface ResolverCachingConfig {
        cachingKeys?: string[];
        ttl: number;
    }
    interface ResolverLambdaConflictHandlerConfig {
        lambdaConflictHandlerArn?: string;
    }
    interface ResolverPipelineConfig {
        functions?: string[];
    }
    interface ResolverSyncConfig {
        conflictDetection: string;
        conflictHandler?: string;
        lambdaConflictHandlerConfig?: outputs.appsync.ResolverLambdaConflictHandlerConfig;
    }
}
export declare namespace aps {
    /**
     * A key-value pair to associate with a resource.
     */
    interface RuleGroupsNamespaceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Logging configuration
     */
    interface WorkspaceLoggingConfiguration {
        /**
         * CloudWatch log group ARN
         */
        logGroupArn?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface WorkspaceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace ask {
    interface SkillAuthenticationConfiguration {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }
    interface SkillOverrides {
        manifest?: any;
    }
    interface SkillPackage {
        overrides?: outputs.ask.SkillOverrides;
        s3Bucket: string;
        s3BucketRole?: string;
        s3Key: string;
        s3ObjectVersion?: string;
    }
}
export declare namespace athena {
    interface DataCatalogTag {
        key: string;
        value: string;
    }
    interface WorkGroupConfiguration {
        bytesScannedCutoffPerQuery?: number;
        enforceWorkGroupConfiguration?: boolean;
        engineVersion?: outputs.athena.WorkGroupEngineVersion;
        publishCloudWatchMetricsEnabled?: boolean;
        requesterPaysEnabled?: boolean;
        resultConfiguration?: outputs.athena.WorkGroupResultConfiguration;
    }
    /**
     * The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified.
     */
    interface WorkGroupConfigurationUpdates {
        bytesScannedCutoffPerQuery?: number;
        enforceWorkGroupConfiguration?: boolean;
        engineVersion?: outputs.athena.WorkGroupEngineVersion;
        publishCloudWatchMetricsEnabled?: boolean;
        removeBytesScannedCutoffPerQuery?: boolean;
        requesterPaysEnabled?: boolean;
        resultConfigurationUpdates?: outputs.athena.WorkGroupResultConfigurationUpdates;
    }
    /**
     * If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE-KMS or CSE-KMS) and key information.
     */
    interface WorkGroupEncryptionConfiguration {
        encryptionOption: enums.athena.WorkGroupEncryptionOption;
        kmsKey?: string;
    }
    /**
     * The Athena engine version for running queries.
     */
    interface WorkGroupEngineVersion {
        effectiveEngineVersion?: string;
        selectedEngineVersion?: string;
    }
    /**
     * The location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
     */
    interface WorkGroupResultConfiguration {
        encryptionConfiguration?: outputs.athena.WorkGroupEncryptionConfiguration;
        outputLocation?: string;
    }
    /**
     * The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.
     */
    interface WorkGroupResultConfigurationUpdates {
        encryptionConfiguration?: outputs.athena.WorkGroupEncryptionConfiguration;
        outputLocation?: string;
        removeEncryptionConfiguration?: boolean;
        removeOutputLocation?: boolean;
    }
    interface WorkGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace auditmanager {
    /**
     * The AWS account associated with the assessment.
     */
    interface AssessmentAWSAccount {
        emailAddress?: string;
        id?: string;
        name?: string;
    }
    /**
     * An AWS service such as Amazon S3, AWS CloudTrail, and so on.
     */
    interface AssessmentAWSService {
        serviceName?: string;
    }
    /**
     * The assignment of a control set to a delegate for review.
     */
    interface AssessmentDelegation {
        assessmentId?: string;
        assessmentName?: string;
        comment?: string;
        controlSetId?: string;
        createdBy?: string;
        creationTime?: number;
        id?: string;
        lastUpdated?: number;
        roleArn?: string;
        roleType?: enums.auditmanager.AssessmentRoleType;
        status?: enums.auditmanager.AssessmentDelegationStatus;
    }
    /**
     * The destination in which evidence reports are stored for the specified assessment.
     */
    interface AssessmentReportsDestination {
        destination?: string;
        destinationType?: enums.auditmanager.AssessmentReportDestinationType;
    }
    /**
     * The wrapper that contains AWS Audit Manager role information, such as the role type and IAM ARN.
     */
    interface AssessmentRole {
        roleArn?: string;
        roleType?: enums.auditmanager.AssessmentRoleType;
    }
    /**
     * The wrapper that contains the AWS accounts and AWS services in scope for the assessment.
     */
    interface AssessmentScope {
        /**
         * The AWS accounts included in scope.
         */
        awsAccounts?: outputs.auditmanager.AssessmentAWSAccount[];
        /**
         * The AWS services included in scope.
         */
        awsServices?: outputs.auditmanager.AssessmentAWSService[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface AssessmentTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace autoscaling {
    interface AutoScalingGroupAcceleratorCountRequest {
        max?: number;
        min?: number;
    }
    interface AutoScalingGroupAcceleratorTotalMemoryMiBRequest {
        max?: number;
        min?: number;
    }
    interface AutoScalingGroupBaselineEbsBandwidthMbpsRequest {
        max?: number;
        min?: number;
    }
    interface AutoScalingGroupInstanceRequirements {
        acceleratorCount?: outputs.autoscaling.AutoScalingGroupAcceleratorCountRequest;
        acceleratorManufacturers?: string[];
        acceleratorNames?: string[];
        acceleratorTotalMemoryMiB?: outputs.autoscaling.AutoScalingGroupAcceleratorTotalMemoryMiBRequest;
        acceleratorTypes?: string[];
        bareMetal?: string;
        baselineEbsBandwidthMbps?: outputs.autoscaling.AutoScalingGroupBaselineEbsBandwidthMbpsRequest;
        burstablePerformance?: string;
        cpuManufacturers?: string[];
        excludedInstanceTypes?: string[];
        instanceGenerations?: string[];
        localStorage?: string;
        localStorageTypes?: string[];
        memoryGiBPerVCpu?: outputs.autoscaling.AutoScalingGroupMemoryGiBPerVCpuRequest;
        memoryMiB?: outputs.autoscaling.AutoScalingGroupMemoryMiBRequest;
        networkInterfaceCount?: outputs.autoscaling.AutoScalingGroupNetworkInterfaceCountRequest;
        onDemandMaxPricePercentageOverLowestPrice?: number;
        requireHibernateSupport?: boolean;
        spotMaxPricePercentageOverLowestPrice?: number;
        totalLocalStorageGB?: outputs.autoscaling.AutoScalingGroupTotalLocalStorageGBRequest;
        vCpuCount?: outputs.autoscaling.AutoScalingGroupVCpuCountRequest;
    }
    interface AutoScalingGroupInstancesDistribution {
        onDemandAllocationStrategy?: string;
        onDemandBaseCapacity?: number;
        onDemandPercentageAboveBaseCapacity?: number;
        spotAllocationStrategy?: string;
        spotInstancePools?: number;
        spotMaxPrice?: string;
    }
    interface AutoScalingGroupLaunchTemplate {
        launchTemplateSpecification: outputs.autoscaling.AutoScalingGroupLaunchTemplateSpecification;
        overrides?: outputs.autoscaling.AutoScalingGroupLaunchTemplateOverrides[];
    }
    interface AutoScalingGroupLaunchTemplateOverrides {
        instanceRequirements?: outputs.autoscaling.AutoScalingGroupInstanceRequirements;
        instanceType?: string;
        launchTemplateSpecification?: outputs.autoscaling.AutoScalingGroupLaunchTemplateSpecification;
        weightedCapacity?: string;
    }
    interface AutoScalingGroupLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version: string;
    }
    interface AutoScalingGroupLifecycleHookSpecification {
        defaultResult?: string;
        heartbeatTimeout?: number;
        lifecycleHookName: string;
        lifecycleTransition: string;
        notificationMetadata?: string;
        notificationTargetARN?: string;
        roleARN?: string;
    }
    interface AutoScalingGroupMemoryGiBPerVCpuRequest {
        max?: number;
        min?: number;
    }
    interface AutoScalingGroupMemoryMiBRequest {
        max?: number;
        min?: number;
    }
    interface AutoScalingGroupMetricsCollection {
        granularity: string;
        metrics?: string[];
    }
    interface AutoScalingGroupMixedInstancesPolicy {
        instancesDistribution?: outputs.autoscaling.AutoScalingGroupInstancesDistribution;
        launchTemplate: outputs.autoscaling.AutoScalingGroupLaunchTemplate;
    }
    interface AutoScalingGroupNetworkInterfaceCountRequest {
        max?: number;
        min?: number;
    }
    interface AutoScalingGroupNotificationConfiguration {
        notificationTypes?: string[];
        topicARN: string;
    }
    interface AutoScalingGroupTagProperty {
        key: string;
        propagateAtLaunch: boolean;
        value: string;
    }
    interface AutoScalingGroupTotalLocalStorageGBRequest {
        max?: number;
        min?: number;
    }
    interface AutoScalingGroupVCpuCountRequest {
        max?: number;
        min?: number;
    }
    /**
     * BlockDevice is a subproperty of BlockDeviceMapping that describes an Amazon EBS volume.
     */
    interface LaunchConfigurationBlockDevice {
        /**
         * Indicates whether the volume is deleted on instance termination.
         */
        deleteOnTermination?: boolean;
        /**
         * Specifies whether the volume should be encrypted.
         */
        encrypted?: boolean;
        /**
         * The number of input/output (I/O) operations per second (IOPS) to provision for the volume.
         */
        iops?: number;
        /**
         * The snapshot ID of the volume to use.
         */
        snapshotId?: string;
        /**
         * The throughput (MiBps) to provision for a gp3 volume.
         */
        throughput?: number;
        /**
         * The volume size, in GiBs.
         */
        volumeSize?: number;
        /**
         * The volume type.
         */
        volumeType?: string;
    }
    /**
     * BlockDeviceMapping is a property of AWS::AutoScaling::LaunchConfiguration that describes a block device mapping for an Auto Scaling group.
     */
    interface LaunchConfigurationBlockDeviceMapping {
        /**
         * The device name exposed to the EC2 instance (for example, /dev/sdh or xvdh).
         */
        deviceName: string;
        /**
         * Parameters used to automatically set up EBS volumes when an instance is launched.
         */
        ebs?: outputs.autoscaling.LaunchConfigurationBlockDevice;
        /**
         * Setting this value to true suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: boolean;
        /**
         * The name of the virtual device.
         */
        virtualName?: string;
    }
    /**
     * MetadataOptions is a property of AWS::AutoScaling::LaunchConfiguration that describes metadata options for the instances.
     */
    interface LaunchConfigurationMetadataOptions {
        /**
         * This parameter enables or disables the HTTP metadata endpoint on your instances.
         */
        httpEndpoint?: string;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit?: number;
        /**
         * The state of token usage for your instance metadata requests.
         */
        httpTokens?: string;
    }
    interface ScalingPolicyCustomizedMetricSpecification {
        dimensions?: outputs.autoscaling.ScalingPolicyMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }
    interface ScalingPolicyMetric {
        dimensions?: outputs.autoscaling.ScalingPolicyMetricDimension[];
        metricName: string;
        namespace: string;
    }
    interface ScalingPolicyMetricDataQuery {
        expression?: string;
        id: string;
        label?: string;
        metricStat?: outputs.autoscaling.ScalingPolicyMetricStat;
        returnData?: boolean;
    }
    interface ScalingPolicyMetricDimension {
        name: string;
        value: string;
    }
    interface ScalingPolicyMetricStat {
        metric: outputs.autoscaling.ScalingPolicyMetric;
        stat: string;
        unit?: string;
    }
    interface ScalingPolicyPredefinedMetricSpecification {
        predefinedMetricType: string;
        resourceLabel?: string;
    }
    interface ScalingPolicyPredictiveScalingConfiguration {
        maxCapacityBreachBehavior?: string;
        maxCapacityBuffer?: number;
        metricSpecifications: outputs.autoscaling.ScalingPolicyPredictiveScalingMetricSpecification[];
        mode?: string;
        schedulingBufferTime?: number;
    }
    interface ScalingPolicyPredictiveScalingCustomizedCapacityMetric {
        metricDataQueries: outputs.autoscaling.ScalingPolicyMetricDataQuery[];
    }
    interface ScalingPolicyPredictiveScalingCustomizedLoadMetric {
        metricDataQueries: outputs.autoscaling.ScalingPolicyMetricDataQuery[];
    }
    interface ScalingPolicyPredictiveScalingCustomizedScalingMetric {
        metricDataQueries: outputs.autoscaling.ScalingPolicyMetricDataQuery[];
    }
    interface ScalingPolicyPredictiveScalingMetricSpecification {
        customizedCapacityMetricSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingCustomizedCapacityMetric;
        customizedLoadMetricSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingCustomizedLoadMetric;
        customizedScalingMetricSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingCustomizedScalingMetric;
        predefinedLoadMetricSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedLoadMetric;
        predefinedMetricPairSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedMetricPair;
        predefinedScalingMetricSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedScalingMetric;
        targetValue: number;
    }
    interface ScalingPolicyPredictiveScalingPredefinedLoadMetric {
        predefinedMetricType: string;
        resourceLabel?: string;
    }
    interface ScalingPolicyPredictiveScalingPredefinedMetricPair {
        predefinedMetricType: string;
        resourceLabel?: string;
    }
    interface ScalingPolicyPredictiveScalingPredefinedScalingMetric {
        predefinedMetricType: string;
        resourceLabel?: string;
    }
    interface ScalingPolicyStepAdjustment {
        metricIntervalLowerBound?: number;
        metricIntervalUpperBound?: number;
        scalingAdjustment: number;
    }
    interface ScalingPolicyTargetTrackingConfiguration {
        customizedMetricSpecification?: outputs.autoscaling.ScalingPolicyCustomizedMetricSpecification;
        disableScaleIn?: boolean;
        predefinedMetricSpecification?: outputs.autoscaling.ScalingPolicyPredefinedMetricSpecification;
        targetValue: number;
    }
    interface WarmPoolInstanceReusePolicy {
        reuseOnScaleIn?: boolean;
    }
}
export declare namespace autoscalingplans {
    interface ScalingPlanApplicationSource {
        cloudFormationStackARN?: string;
        tagFilters?: outputs.autoscalingplans.ScalingPlanTagFilter[];
    }
    interface ScalingPlanCustomizedLoadMetricSpecification {
        dimensions?: outputs.autoscalingplans.ScalingPlanMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }
    interface ScalingPlanCustomizedScalingMetricSpecification {
        dimensions?: outputs.autoscalingplans.ScalingPlanMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }
    interface ScalingPlanMetricDimension {
        name: string;
        value: string;
    }
    interface ScalingPlanPredefinedLoadMetricSpecification {
        predefinedLoadMetricType: string;
        resourceLabel?: string;
    }
    interface ScalingPlanPredefinedScalingMetricSpecification {
        predefinedScalingMetricType: string;
        resourceLabel?: string;
    }
    interface ScalingPlanScalingInstruction {
        customizedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanCustomizedLoadMetricSpecification;
        disableDynamicScaling?: boolean;
        maxCapacity: number;
        minCapacity: number;
        predefinedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanPredefinedLoadMetricSpecification;
        predictiveScalingMaxCapacityBehavior?: string;
        predictiveScalingMaxCapacityBuffer?: number;
        predictiveScalingMode?: string;
        resourceId: string;
        scalableDimension: string;
        scalingPolicyUpdateBehavior?: string;
        scheduledActionBufferTime?: number;
        serviceNamespace: string;
        targetTrackingConfigurations: outputs.autoscalingplans.ScalingPlanTargetTrackingConfiguration[];
    }
    interface ScalingPlanTagFilter {
        key: string;
        values?: string[];
    }
    interface ScalingPlanTargetTrackingConfiguration {
        customizedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanCustomizedScalingMetricSpecification;
        disableScaleIn?: boolean;
        estimatedInstanceWarmup?: number;
        predefinedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanPredefinedScalingMetricSpecification;
        scaleInCooldown?: number;
        scaleOutCooldown?: number;
        targetValue: number;
    }
}
export declare namespace backup {
    interface BackupPlanAdvancedBackupSettingResourceType {
        backupOptions: any;
        resourceType: string;
    }
    interface BackupPlanBackupRuleResourceType {
        completionWindowMinutes?: number;
        copyActions?: outputs.backup.BackupPlanCopyActionResourceType[];
        enableContinuousBackup?: boolean;
        lifecycle?: outputs.backup.BackupPlanLifecycleResourceType;
        recoveryPointTags?: any;
        ruleName: string;
        scheduleExpression?: string;
        startWindowMinutes?: number;
        targetBackupVault: string;
    }
    interface BackupPlanCopyActionResourceType {
        destinationBackupVaultArn: string;
        lifecycle?: outputs.backup.BackupPlanLifecycleResourceType;
    }
    interface BackupPlanLifecycleResourceType {
        deleteAfterDays?: number;
        moveToColdStorageAfterDays?: number;
    }
    interface BackupPlanResourceType {
        advancedBackupSettings?: outputs.backup.BackupPlanAdvancedBackupSettingResourceType[];
        backupPlanName: string;
        backupPlanRule: outputs.backup.BackupPlanBackupRuleResourceType[];
    }
    interface BackupSelectionConditionParameter {
        conditionKey?: string;
        conditionValue?: string;
    }
    interface BackupSelectionConditionResourceType {
        conditionKey: string;
        conditionType: string;
        conditionValue: string;
    }
    interface BackupSelectionResourceType {
        conditions?: outputs.backup.BackupSelectionResourceTypeConditionsProperties;
        iamRoleArn: string;
        listOfTags?: outputs.backup.BackupSelectionConditionResourceType[];
        notResources?: string[];
        resources?: string[];
        selectionName: string;
    }
    interface BackupSelectionResourceTypeConditionsProperties {
        stringEquals?: outputs.backup.BackupSelectionConditionParameter[];
        stringLike?: outputs.backup.BackupSelectionConditionParameter[];
        stringNotEquals?: outputs.backup.BackupSelectionConditionParameter[];
        stringNotLike?: outputs.backup.BackupSelectionConditionParameter[];
    }
    interface BackupVaultLockConfigurationType {
        changeableForDays?: number;
        maxRetentionDays?: number;
        minRetentionDays: number;
    }
    interface BackupVaultNotificationObjectType {
        backupVaultEvents: string[];
        sNSTopicArn: string;
    }
    interface FrameworkControl {
        /**
         * A list of ParameterName and ParameterValue pairs.
         */
        controlInputParameters?: outputs.backup.FrameworkControlInputParameter[];
        /**
         * The name of a control. This name is between 1 and 256 characters.
         */
        controlName: string;
        /**
         * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans.
         */
        controlScope?: outputs.backup.FrameworkControlControlScopeProperties;
    }
    /**
     * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans.
     */
    interface FrameworkControlControlScopeProperties {
        /**
         * The ID of the only AWS resource that you want your control scope to contain.
         */
        complianceResourceIds?: string[];
        /**
         * Describes whether the control scope includes one or more types of resources, such as `EFS` or `RDS`.
         */
        complianceResourceTypes?: string[];
        /**
         * Describes whether the control scope includes resources with one or more tags. Each tag is a key-value pair.
         */
        tags?: outputs.backup.FrameworkTag[];
    }
    interface FrameworkControlInputParameter {
        parameterName: string;
        parameterValue: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface FrameworkTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key?: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
     */
    interface ReportDeliveryChannelProperties {
        /**
         * A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
         */
        formats?: string[];
        /**
         * The unique name of the S3 bucket that receives your reports.
         */
        s3BucketName: string;
        /**
         * The prefix for where AWS Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
         */
        s3KeyPrefix?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ReportPlanTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key?: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * Identifies the report template for the report. Reports are built using a report template.
     */
    interface ReportSettingProperties {
        /**
         * The Amazon Resource Names (ARNs) of the frameworks a report covers.
         */
        frameworkArns?: string[];
        /**
         * Identifies the report template for the report. Reports are built using a report template. The report templates are: `BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT`
         */
        reportTemplate: string;
    }
}
export declare namespace batch {
    interface ComputeEnvironmentComputeResources {
        allocationStrategy?: string;
        bidPercentage?: number;
        desiredvCpus?: number;
        ec2Configuration?: outputs.batch.ComputeEnvironmentEc2ConfigurationObject[];
        ec2KeyPair?: string;
        imageId?: string;
        instanceRole?: string;
        instanceTypes?: string[];
        launchTemplate?: outputs.batch.ComputeEnvironmentLaunchTemplateSpecification;
        maxvCpus: number;
        minvCpus?: number;
        placementGroup?: string;
        securityGroupIds?: string[];
        spotIamFleetRole?: string;
        subnets: string[];
        /**
         * A key-value pair to associate with a resource.
         */
        tags?: any;
        type: string;
        updateToLatestImageVersion?: boolean;
    }
    interface ComputeEnvironmentEc2ConfigurationObject {
        imageIdOverride?: string;
        imageType: string;
    }
    interface ComputeEnvironmentLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version?: string;
    }
    interface ComputeEnvironmentUpdatePolicy {
        jobExecutionTimeoutMinutes?: number;
        terminateJobsOnUpdate?: boolean;
    }
    interface JobDefinitionAuthorizationConfig {
        accessPointId?: string;
        iam?: string;
    }
    interface JobDefinitionContainerProperties {
        command?: string[];
        environment?: outputs.batch.JobDefinitionEnvironment[];
        executionRoleArn?: string;
        fargatePlatformConfiguration?: outputs.batch.JobDefinitionFargatePlatformConfiguration;
        image: string;
        instanceType?: string;
        jobRoleArn?: string;
        linuxParameters?: outputs.batch.JobDefinitionLinuxParameters;
        logConfiguration?: outputs.batch.JobDefinitionLogConfiguration;
        memory?: number;
        mountPoints?: outputs.batch.JobDefinitionMountPoints[];
        networkConfiguration?: outputs.batch.JobDefinitionNetworkConfiguration;
        privileged?: boolean;
        readonlyRootFilesystem?: boolean;
        resourceRequirements?: outputs.batch.JobDefinitionResourceRequirement[];
        secrets?: outputs.batch.JobDefinitionSecret[];
        ulimits?: outputs.batch.JobDefinitionUlimit[];
        user?: string;
        vcpus?: number;
        volumes?: outputs.batch.JobDefinitionVolumes[];
    }
    interface JobDefinitionDevice {
        containerPath?: string;
        hostPath?: string;
        permissions?: string[];
    }
    interface JobDefinitionEfsVolumeConfiguration {
        authorizationConfig?: outputs.batch.JobDefinitionAuthorizationConfig;
        fileSystemId: string;
        rootDirectory?: string;
        transitEncryption?: string;
        transitEncryptionPort?: number;
    }
    interface JobDefinitionEnvironment {
        name?: string;
        value?: string;
    }
    interface JobDefinitionEvaluateOnExit {
        action: string;
        onExitCode?: string;
        onReason?: string;
        onStatusReason?: string;
    }
    interface JobDefinitionFargatePlatformConfiguration {
        platformVersion?: string;
    }
    interface JobDefinitionLinuxParameters {
        devices?: outputs.batch.JobDefinitionDevice[];
        initProcessEnabled?: boolean;
        maxSwap?: number;
        sharedMemorySize?: number;
        swappiness?: number;
        tmpfs?: outputs.batch.JobDefinitionTmpfs[];
    }
    interface JobDefinitionLogConfiguration {
        logDriver: string;
        options?: any;
        secretOptions?: outputs.batch.JobDefinitionSecret[];
    }
    interface JobDefinitionMountPoints {
        containerPath?: string;
        readOnly?: boolean;
        sourceVolume?: string;
    }
    interface JobDefinitionNetworkConfiguration {
        assignPublicIp?: string;
    }
    interface JobDefinitionNodeProperties {
        mainNode: number;
        nodeRangeProperties: outputs.batch.JobDefinitionNodeRangeProperty[];
        numNodes: number;
    }
    interface JobDefinitionNodeRangeProperty {
        container?: outputs.batch.JobDefinitionContainerProperties;
        targetNodes: string;
    }
    interface JobDefinitionResourceRequirement {
        type?: string;
        value?: string;
    }
    interface JobDefinitionRetryStrategy {
        attempts?: number;
        evaluateOnExit?: outputs.batch.JobDefinitionEvaluateOnExit[];
    }
    interface JobDefinitionSecret {
        name: string;
        valueFrom: string;
    }
    interface JobDefinitionTimeout {
        attemptDurationSeconds?: number;
    }
    interface JobDefinitionTmpfs {
        containerPath: string;
        mountOptions?: string[];
        size: number;
    }
    interface JobDefinitionUlimit {
        hardLimit: number;
        name: string;
        softLimit: number;
    }
    interface JobDefinitionVolumes {
        efsVolumeConfiguration?: outputs.batch.JobDefinitionEfsVolumeConfiguration;
        host?: outputs.batch.JobDefinitionVolumesHost;
        name?: string;
    }
    interface JobDefinitionVolumesHost {
        sourcePath?: string;
    }
    interface JobQueueComputeEnvironmentOrder {
        computeEnvironment: string;
        order: number;
    }
    /**
     * Fair Share Policy for the Job Queue.
     */
    interface SchedulingPolicyFairsharePolicy {
        computeReservation?: number;
        shareDecaySeconds?: number;
        /**
         * List of Share Attributes
         */
        shareDistribution?: outputs.batch.SchedulingPolicyShareAttributes[];
    }
    interface SchedulingPolicyShareAttributes {
        shareIdentifier?: string;
        weightFactor?: number;
    }
}
export declare namespace billingconductor {
    interface BillingGroupAccountGrouping {
        linkedAccountIds: string[];
    }
    interface BillingGroupComputationPreference {
        /**
         * ARN of the attached pricing plan
         */
        pricingPlanArn: string;
    }
    interface BillingGroupTag {
        key: string;
        value: string;
    }
    interface CustomLineItemBillingPeriodRange {
        exclusiveEndBillingPeriod?: string;
        inclusiveStartBillingPeriod?: string;
    }
    interface CustomLineItemChargeDetails {
        flat?: outputs.billingconductor.CustomLineItemFlatChargeDetails;
        percentage?: outputs.billingconductor.CustomLineItemPercentageChargeDetails;
        type: enums.billingconductor.CustomLineItemType;
    }
    interface CustomLineItemFlatChargeDetails {
        chargeValue: number;
    }
    interface CustomLineItemPercentageChargeDetails {
        childAssociatedResources?: string[];
        percentageValue: number;
    }
    interface CustomLineItemTag {
        key: string;
        value: string;
    }
    interface PricingPlanTag {
        key: string;
        value: string;
    }
    interface PricingRuleTag {
        key: string;
        value: string;
    }
}
export declare namespace budgets {
    interface BudgetAutoAdjustData {
        autoAdjustType: string;
        historicalOptions?: outputs.budgets.BudgetHistoricalOptions;
    }
    interface BudgetCostTypes {
        includeCredit?: boolean;
        includeDiscount?: boolean;
        includeOtherSubscription?: boolean;
        includeRecurring?: boolean;
        includeRefund?: boolean;
        includeSubscription?: boolean;
        includeSupport?: boolean;
        includeTax?: boolean;
        includeUpfront?: boolean;
        useAmortized?: boolean;
        useBlended?: boolean;
    }
    interface BudgetData {
        autoAdjustData?: outputs.budgets.BudgetAutoAdjustData;
        budgetLimit?: outputs.budgets.BudgetSpend;
        budgetName?: string;
        budgetType: string;
        costFilters?: any;
        costTypes?: outputs.budgets.BudgetCostTypes;
        plannedBudgetLimits?: any;
        timePeriod?: outputs.budgets.BudgetTimePeriod;
        timeUnit: string;
    }
    interface BudgetHistoricalOptions {
        budgetAdjustmentPeriod: number;
    }
    interface BudgetNotification {
        comparisonOperator: string;
        notificationType: string;
        threshold: number;
        thresholdType?: string;
    }
    interface BudgetNotificationWithSubscribers {
        notification: outputs.budgets.BudgetNotification;
        subscribers: outputs.budgets.BudgetSubscriber[];
    }
    interface BudgetSpend {
        amount: number;
        unit: string;
    }
    interface BudgetSubscriber {
        address: string;
        subscriptionType: string;
    }
    interface BudgetTimePeriod {
        end?: string;
        start?: string;
    }
    interface BudgetsActionActionThreshold {
        type: enums.budgets.BudgetsActionActionThresholdType;
        value: number;
    }
    interface BudgetsActionDefinition {
        iamActionDefinition?: outputs.budgets.BudgetsActionIamActionDefinition;
        scpActionDefinition?: outputs.budgets.BudgetsActionScpActionDefinition;
        ssmActionDefinition?: outputs.budgets.BudgetsActionSsmActionDefinition;
    }
    interface BudgetsActionIamActionDefinition {
        groups?: string[];
        policyArn: string;
        roles?: string[];
        users?: string[];
    }
    interface BudgetsActionScpActionDefinition {
        policyId: string;
        targetIds: string[];
    }
    interface BudgetsActionSsmActionDefinition {
        instanceIds: string[];
        region: string;
        subtype: enums.budgets.BudgetsActionSsmActionDefinitionSubtype;
    }
    interface BudgetsActionSubscriber {
        address: string;
        type: enums.budgets.BudgetsActionSubscriberType;
    }
}
export declare namespace cassandra {
    interface KeyspaceTag {
        key: string;
        value: string;
    }
    interface TableBillingMode {
        mode: enums.cassandra.TableMode;
        provisionedThroughput?: outputs.cassandra.TableProvisionedThroughput;
    }
    interface TableClusteringKeyColumn {
        column: outputs.cassandra.TableColumn;
        orderBy?: enums.cassandra.TableClusteringKeyColumnOrderBy;
    }
    interface TableColumn {
        columnName: string;
        columnType: string;
    }
    /**
     * Represents the settings used to enable server-side encryption
     */
    interface TableEncryptionSpecification {
        encryptionType: enums.cassandra.TableEncryptionType;
        kmsKeyIdentifier?: string;
    }
    /**
     * Throughput for the specified table, which consists of values for ReadCapacityUnits and WriteCapacityUnits
     */
    interface TableProvisionedThroughput {
        readCapacityUnits: number;
        writeCapacityUnits: number;
    }
    /**
     * A key-value pair to apply to the resource
     */
    interface TableTag {
        key: string;
        value: string;
    }
}
export declare namespace ce {
    /**
     * A key-value pair to associate with a resource.
     */
    interface AnomalyMonitorResourceTag {
        /**
         * The key name for the tag.
         */
        key: string;
        /**
         * The value for the tag.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface AnomalySubscriptionResourceTag {
        /**
         * The key name for the tag.
         */
        key: string;
        /**
         * The value for the tag.
         */
        value: string;
    }
    interface AnomalySubscriptionSubscriber {
        address: string;
        status?: enums.ce.AnomalySubscriptionSubscriberStatus;
        type: enums.ce.AnomalySubscriptionSubscriberType;
    }
}
export declare namespace certificatemanager {
    interface AccountExpiryEventsConfiguration {
        daysBeforeExpiry?: number;
    }
    interface CertificateDomainValidationOption {
        domainName: string;
        hostedZoneId?: string;
        validationDomain?: string;
    }
    interface CertificateTag {
        key: string;
        value: string;
    }
}
export declare namespace cloud9 {
    interface EnvironmentEC2Repository {
        pathComponent: string;
        repositoryUrl: string;
    }
    interface EnvironmentEC2Tag {
        key: string;
        value: string;
    }
}
export declare namespace cloudformation {
    interface HookVersionLoggingConfig {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: string;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: string;
    }
    /**
     * Describes whether StackSets performs non-conflicting operations concurrently and queues conflicting operations.
     */
    interface ManagedExecutionProperties {
        active?: boolean;
    }
    interface ResourceVersionLoggingConfig {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: string;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: string;
    }
    interface StackSetAutoDeployment {
        /**
         * If set to true, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.
         */
        enabled?: boolean;
        /**
         * If set to true, stack resources are retained when an account is removed from a target organization or OU. If set to false, stack resources are deleted. Specify only if Enabled is set to True.
         */
        retainStacksOnAccountRemoval?: boolean;
    }
    /**
     *  The AWS OrganizationalUnitIds or Accounts for which to create stack instances in the specified Regions.
     */
    interface StackSetDeploymentTargets {
        /**
         * The filter type you want to apply on organizational units and accounts.
         */
        accountFilterType?: enums.cloudformation.StackSetDeploymentTargetsAccountFilterType;
        /**
         * AWS accounts that you want to create stack instances in the specified Region(s) for.
         */
        accounts?: string[];
        /**
         * The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
         */
        organizationalUnitIds?: string[];
    }
    /**
     * The user-specified preferences for how AWS CloudFormation performs a stack set operation.
     */
    interface StackSetOperationPreferences {
        failureToleranceCount?: number;
        failureTolerancePercentage?: number;
        maxConcurrentCount?: number;
        maxConcurrentPercentage?: number;
        regionConcurrencyType?: enums.cloudformation.StackSetRegionConcurrencyType;
        regionOrder?: string[];
    }
    interface StackSetParameter {
        /**
         * The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
         */
        parameterKey: string;
        /**
         * The input value associated with the parameter.
         */
        parameterValue: string;
    }
    /**
     * Stack instances in some specific accounts and Regions.
     */
    interface StackSetStackInstances {
        deploymentTargets: outputs.cloudformation.StackSetDeploymentTargets;
        /**
         * A list of stack set parameters whose values you want to override in the selected stack instances.
         */
        parameterOverrides?: outputs.cloudformation.StackSetParameter[];
        /**
         * The names of one or more Regions where you want to create stack instances using the specified AWS account(s).
         */
        regions: string[];
    }
    /**
     * Tag type enables you to specify a key-value pair that can be used to store information about an AWS CloudFormation StackSet.
     */
    interface StackSetTag {
        /**
         * A string used to identify this tag. You can specify a maximum of 127 characters for a tag key.
         */
        key: string;
        /**
         * A string containing the value for this tag. You can specify a maximum of 256 characters for a tag value.
         */
        value: string;
    }
    interface StackTag {
        key: string;
        value: string;
    }
    interface TypeActivationLoggingConfig {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: string;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: string;
    }
}
export declare namespace cloudfront {
    interface CachePolicyConfig {
        comment?: string;
        defaultTTL: number;
        maxTTL: number;
        minTTL: number;
        name: string;
        parametersInCacheKeyAndForwardedToOrigin: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOrigin;
    }
    interface CachePolicyCookiesConfig {
        cookieBehavior: string;
        cookies?: string[];
    }
    interface CachePolicyHeadersConfig {
        headerBehavior: string;
        headers?: string[];
    }
    interface CachePolicyParametersInCacheKeyAndForwardedToOrigin {
        cookiesConfig: outputs.cloudfront.CachePolicyCookiesConfig;
        enableAcceptEncodingBrotli?: boolean;
        enableAcceptEncodingGzip: boolean;
        headersConfig: outputs.cloudfront.CachePolicyHeadersConfig;
        queryStringsConfig: outputs.cloudfront.CachePolicyQueryStringsConfig;
    }
    interface CachePolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings?: string[];
    }
    interface CloudFrontOriginAccessIdentityConfig {
        comment: string;
    }
    interface DistributionCacheBehavior {
        allowedMethods?: string[];
        cachePolicyId?: string;
        cachedMethods?: string[];
        compress?: boolean;
        defaultTTL?: number;
        fieldLevelEncryptionId?: string;
        forwardedValues?: outputs.cloudfront.DistributionForwardedValues;
        functionAssociations?: outputs.cloudfront.DistributionFunctionAssociation[];
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionLambdaFunctionAssociation[];
        maxTTL?: number;
        minTTL?: number;
        originRequestPolicyId?: string;
        pathPattern: string;
        realtimeLogConfigArn?: string;
        responseHeadersPolicyId?: string;
        smoothStreaming?: boolean;
        targetOriginId: string;
        trustedKeyGroups?: string[];
        trustedSigners?: string[];
        viewerProtocolPolicy: string;
    }
    interface DistributionConfig {
        aliases?: string[];
        cNAMEs?: string[];
        cacheBehaviors?: outputs.cloudfront.DistributionCacheBehavior[];
        comment?: string;
        customErrorResponses?: outputs.cloudfront.DistributionCustomErrorResponse[];
        customOrigin?: outputs.cloudfront.DistributionLegacyCustomOrigin;
        defaultCacheBehavior: outputs.cloudfront.DistributionDefaultCacheBehavior;
        defaultRootObject?: string;
        enabled: boolean;
        httpVersion?: string;
        iPV6Enabled?: boolean;
        logging?: outputs.cloudfront.DistributionLogging;
        originGroups?: outputs.cloudfront.DistributionOriginGroups;
        origins?: outputs.cloudfront.DistributionOrigin[];
        priceClass?: string;
        restrictions?: outputs.cloudfront.DistributionRestrictions;
        s3Origin?: outputs.cloudfront.DistributionLegacyS3Origin;
        viewerCertificate?: outputs.cloudfront.DistributionViewerCertificate;
        webACLId?: string;
    }
    interface DistributionCookies {
        forward: string;
        whitelistedNames?: string[];
    }
    interface DistributionCustomErrorResponse {
        errorCachingMinTTL?: number;
        errorCode: number;
        responseCode?: number;
        responsePagePath?: string;
    }
    interface DistributionCustomOriginConfig {
        hTTPPort?: number;
        hTTPSPort?: number;
        originKeepaliveTimeout?: number;
        originProtocolPolicy: string;
        originReadTimeout?: number;
        originSSLProtocols?: string[];
    }
    interface DistributionDefaultCacheBehavior {
        allowedMethods?: string[];
        cachePolicyId?: string;
        cachedMethods?: string[];
        compress?: boolean;
        defaultTTL?: number;
        fieldLevelEncryptionId?: string;
        forwardedValues?: outputs.cloudfront.DistributionForwardedValues;
        functionAssociations?: outputs.cloudfront.DistributionFunctionAssociation[];
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionLambdaFunctionAssociation[];
        maxTTL?: number;
        minTTL?: number;
        originRequestPolicyId?: string;
        realtimeLogConfigArn?: string;
        responseHeadersPolicyId?: string;
        smoothStreaming?: boolean;
        targetOriginId: string;
        trustedKeyGroups?: string[];
        trustedSigners?: string[];
        viewerProtocolPolicy: string;
    }
    interface DistributionForwardedValues {
        cookies?: outputs.cloudfront.DistributionCookies;
        headers?: string[];
        queryString: boolean;
        queryStringCacheKeys?: string[];
    }
    interface DistributionFunctionAssociation {
        eventType?: string;
        functionARN?: string;
    }
    interface DistributionGeoRestriction {
        locations?: string[];
        restrictionType: string;
    }
    interface DistributionLambdaFunctionAssociation {
        eventType?: string;
        includeBody?: boolean;
        lambdaFunctionARN?: string;
    }
    interface DistributionLegacyCustomOrigin {
        dNSName: string;
        hTTPPort?: number;
        hTTPSPort?: number;
        originProtocolPolicy: string;
        originSSLProtocols: string[];
    }
    interface DistributionLegacyS3Origin {
        dNSName: string;
        originAccessIdentity?: string;
    }
    interface DistributionLogging {
        bucket: string;
        includeCookies?: boolean;
        prefix?: string;
    }
    interface DistributionOrigin {
        connectionAttempts?: number;
        connectionTimeout?: number;
        customOriginConfig?: outputs.cloudfront.DistributionCustomOriginConfig;
        domainName: string;
        id: string;
        originAccessControlId?: string;
        originCustomHeaders?: outputs.cloudfront.DistributionOriginCustomHeader[];
        originPath?: string;
        originShield?: outputs.cloudfront.DistributionOriginShield;
        s3OriginConfig?: outputs.cloudfront.DistributionS3OriginConfig;
    }
    interface DistributionOriginCustomHeader {
        headerName: string;
        headerValue: string;
    }
    interface DistributionOriginGroup {
        failoverCriteria: outputs.cloudfront.DistributionOriginGroupFailoverCriteria;
        id: string;
        members: outputs.cloudfront.DistributionOriginGroupMembers;
    }
    interface DistributionOriginGroupFailoverCriteria {
        statusCodes: outputs.cloudfront.DistributionStatusCodes;
    }
    interface DistributionOriginGroupMember {
        originId: string;
    }
    interface DistributionOriginGroupMembers {
        items: outputs.cloudfront.DistributionOriginGroupMember[];
        quantity: number;
    }
    interface DistributionOriginGroups {
        items?: outputs.cloudfront.DistributionOriginGroup[];
        quantity: number;
    }
    interface DistributionOriginShield {
        enabled?: boolean;
        originShieldRegion?: string;
    }
    interface DistributionRestrictions {
        geoRestriction: outputs.cloudfront.DistributionGeoRestriction;
    }
    interface DistributionS3OriginConfig {
        originAccessIdentity?: string;
    }
    interface DistributionStatusCodes {
        items: number[];
        quantity: number;
    }
    interface DistributionTag {
        key: string;
        value: string;
    }
    interface DistributionViewerCertificate {
        acmCertificateArn?: string;
        cloudFrontDefaultCertificate?: boolean;
        iamCertificateId?: string;
        minimumProtocolVersion?: string;
        sslSupportMethod?: string;
    }
    interface FunctionConfig {
        comment: string;
        runtime: string;
    }
    interface FunctionMetadata {
        functionARN?: string;
    }
    interface KeyGroupConfig {
        comment?: string;
        items: string[];
        name: string;
    }
    interface MonitoringSubscription {
        realtimeMetricsSubscriptionConfig?: outputs.cloudfront.MonitoringSubscriptionRealtimeMetricsSubscriptionConfig;
    }
    interface MonitoringSubscriptionRealtimeMetricsSubscriptionConfig {
        realtimeMetricsSubscriptionStatus: enums.cloudfront.MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus;
    }
    interface OriginAccessControlConfig {
        description?: string;
        name: string;
        originAccessControlOriginType: string;
        signingBehavior: string;
        signingProtocol: string;
    }
    interface OriginRequestPolicyConfig {
        comment?: string;
        cookiesConfig: outputs.cloudfront.OriginRequestPolicyCookiesConfig;
        headersConfig: outputs.cloudfront.OriginRequestPolicyHeadersConfig;
        name: string;
        queryStringsConfig: outputs.cloudfront.OriginRequestPolicyQueryStringsConfig;
    }
    interface OriginRequestPolicyCookiesConfig {
        cookieBehavior: string;
        cookies?: string[];
    }
    interface OriginRequestPolicyHeadersConfig {
        headerBehavior: string;
        headers?: string[];
    }
    interface OriginRequestPolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings?: string[];
    }
    interface PublicKeyConfig {
        callerReference: string;
        comment?: string;
        encodedKey: string;
        name: string;
    }
    interface RealtimeLogConfigEndPoint {
        kinesisStreamConfig: outputs.cloudfront.RealtimeLogConfigKinesisStreamConfig;
        streamType: string;
    }
    interface RealtimeLogConfigKinesisStreamConfig {
        roleArn: string;
        streamArn: string;
    }
    interface ResponseHeadersPolicyAccessControlAllowHeaders {
        items: string[];
    }
    interface ResponseHeadersPolicyAccessControlAllowMethods {
        items: string[];
    }
    interface ResponseHeadersPolicyAccessControlAllowOrigins {
        items: string[];
    }
    interface ResponseHeadersPolicyAccessControlExposeHeaders {
        items: string[];
    }
    interface ResponseHeadersPolicyConfig {
        comment?: string;
        corsConfig?: outputs.cloudfront.ResponseHeadersPolicyCorsConfig;
        customHeadersConfig?: outputs.cloudfront.ResponseHeadersPolicyCustomHeadersConfig;
        name: string;
        securityHeadersConfig?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfig;
        serverTimingHeadersConfig?: outputs.cloudfront.ResponseHeadersPolicyServerTimingHeadersConfig;
    }
    interface ResponseHeadersPolicyContentSecurityPolicy {
        contentSecurityPolicy: string;
        override: boolean;
    }
    interface ResponseHeadersPolicyContentTypeOptions {
        override: boolean;
    }
    interface ResponseHeadersPolicyCorsConfig {
        accessControlAllowCredentials: boolean;
        accessControlAllowHeaders: outputs.cloudfront.ResponseHeadersPolicyAccessControlAllowHeaders;
        accessControlAllowMethods: outputs.cloudfront.ResponseHeadersPolicyAccessControlAllowMethods;
        accessControlAllowOrigins: outputs.cloudfront.ResponseHeadersPolicyAccessControlAllowOrigins;
        accessControlExposeHeaders?: outputs.cloudfront.ResponseHeadersPolicyAccessControlExposeHeaders;
        accessControlMaxAgeSec?: number;
        originOverride: boolean;
    }
    interface ResponseHeadersPolicyCustomHeader {
        header: string;
        override: boolean;
        value: string;
    }
    interface ResponseHeadersPolicyCustomHeadersConfig {
        items: outputs.cloudfront.ResponseHeadersPolicyCustomHeader[];
    }
    interface ResponseHeadersPolicyFrameOptions {
        frameOption: string;
        override: boolean;
    }
    interface ResponseHeadersPolicyReferrerPolicy {
        override: boolean;
        referrerPolicy: string;
    }
    interface ResponseHeadersPolicySecurityHeadersConfig {
        contentSecurityPolicy?: outputs.cloudfront.ResponseHeadersPolicyContentSecurityPolicy;
        contentTypeOptions?: outputs.cloudfront.ResponseHeadersPolicyContentTypeOptions;
        frameOptions?: outputs.cloudfront.ResponseHeadersPolicyFrameOptions;
        referrerPolicy?: outputs.cloudfront.ResponseHeadersPolicyReferrerPolicy;
        strictTransportSecurity?: outputs.cloudfront.ResponseHeadersPolicyStrictTransportSecurity;
        xSSProtection?: outputs.cloudfront.ResponseHeadersPolicyXSSProtection;
    }
    interface ResponseHeadersPolicyServerTimingHeadersConfig {
        enabled: boolean;
        samplingRate?: number;
    }
    interface ResponseHeadersPolicyStrictTransportSecurity {
        accessControlMaxAgeSec: number;
        includeSubdomains?: boolean;
        override: boolean;
        preload?: boolean;
    }
    interface ResponseHeadersPolicyXSSProtection {
        modeBlock?: boolean;
        override: boolean;
        protection: boolean;
        reportUri?: string;
    }
    interface StreamingDistributionConfig {
        aliases?: string[];
        comment: string;
        enabled: boolean;
        logging?: outputs.cloudfront.StreamingDistributionLogging;
        priceClass?: string;
        s3Origin: outputs.cloudfront.StreamingDistributionS3Origin;
        trustedSigners: outputs.cloudfront.StreamingDistributionTrustedSigners;
    }
    interface StreamingDistributionLogging {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }
    interface StreamingDistributionS3Origin {
        domainName: string;
        originAccessIdentity: string;
    }
    interface StreamingDistributionTag {
        key: string;
        value: string;
    }
    interface StreamingDistributionTrustedSigners {
        awsAccountNumbers?: string[];
        enabled: boolean;
    }
}
export declare namespace cloudtrail {
    /**
     * Advanced event selectors let you create fine-grained selectors for the following AWS CloudTrail event record ﬁelds. They help you control costs by logging only those events that are important to you.
     */
    interface EventDataStoreAdvancedEventSelector {
        /**
         * Contains all selector statements in an advanced event selector.
         */
        fieldSelectors: outputs.cloudtrail.EventDataStoreAdvancedFieldSelector[];
        /**
         * An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
         */
        name?: string;
    }
    /**
     * A single selector statement in an advanced event selector.
     */
    interface EventDataStoreAdvancedFieldSelector {
        /**
         * An operator that includes events that match the last few characters of the event record field specified as the value of Field.
         */
        endsWith?: string[];
        /**
         * An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
         */
        equals?: string[];
        /**
         * A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
         */
        field: string;
        /**
         * An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
         */
        notEndsWith?: string[];
        /**
         * An operator that excludes events that match the exact value of the event record field specified as the value of Field.
         */
        notEquals?: string[];
        /**
         * An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
         */
        notStartsWith?: string[];
        /**
         * An operator that includes events that match the first few characters of the event record field specified as the value of Field.
         */
        startsWith?: string[];
    }
    /**
     * An arbitrary set of tags (key-value pairs) for this event data store.
     */
    interface EventDataStoreTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * CloudTrail supports data event logging for Amazon S3 objects and AWS Lambda functions. You can specify up to 250 resources for an individual event selector, but the total number of data resources cannot exceed 250 across all event selectors in a trail. This limit does not apply if you configure resource logging for all data events.
     */
    interface TrailDataResource {
        /**
         * The resource type in which you want to log data events. You can specify AWS::S3::Object or AWS::Lambda::Function resources.
         */
        type: string;
        /**
         * An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
         */
        values?: string[];
    }
    /**
     * The type of email sending events to publish to the event destination.
     */
    interface TrailEventSelector {
        dataResources?: outputs.cloudtrail.TrailDataResource[];
        /**
         * An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out AWS Key Management Service events by containing "kms.amazonaws.com". By default, ExcludeManagementEventSources is empty, and AWS KMS events are included in events that are logged to your trail.
         */
        excludeManagementEventSources?: string[];
        /**
         * Specify if you want your event selector to include management events for your trail.
         */
        includeManagementEvents?: boolean;
        /**
         * Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation.
         */
        readWriteType?: enums.cloudtrail.TrailEventSelectorReadWriteType;
    }
    /**
     * A string that contains insight types that are logged on a trail.
     */
    interface TrailInsightSelector {
        /**
         * The type of insight to log on a trail.
         */
        insightType?: string;
    }
    /**
     * An arbitrary set of tags (key-value pairs) for this trail.
     */
    interface TrailTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace cloudwatch {
    interface AlarmDimension {
        name: string;
        value: string;
    }
    interface AlarmMetric {
        dimensions?: outputs.cloudwatch.AlarmDimension[];
        metricName?: string;
        namespace?: string;
    }
    interface AlarmMetricDataQuery {
        accountId?: string;
        expression?: string;
        id: string;
        label?: string;
        metricStat?: outputs.cloudwatch.AlarmMetricStat;
        period?: number;
        returnData?: boolean;
    }
    interface AlarmMetricStat {
        metric: outputs.cloudwatch.AlarmMetric;
        period: number;
        stat: string;
        unit?: string;
    }
    interface AnomalyDetectorConfiguration {
        excludedTimeRanges?: outputs.cloudwatch.AnomalyDetectorRange[];
        metricTimeZone?: string;
    }
    interface AnomalyDetectorDimension {
        name: string;
        value: string;
    }
    interface AnomalyDetectorMetric {
        dimensions?: outputs.cloudwatch.AnomalyDetectorDimension[];
        metricName: string;
        namespace: string;
    }
    interface AnomalyDetectorMetricDataQuery {
        accountId?: string;
        expression?: string;
        id: string;
        label?: string;
        metricStat?: outputs.cloudwatch.AnomalyDetectorMetricStat;
        period?: number;
        returnData?: boolean;
    }
    interface AnomalyDetectorMetricMathAnomalyDetector {
        metricDataQueries?: outputs.cloudwatch.AnomalyDetectorMetricDataQuery[];
    }
    interface AnomalyDetectorMetricStat {
        metric: outputs.cloudwatch.AnomalyDetectorMetric;
        period: number;
        stat: string;
        unit?: string;
    }
    interface AnomalyDetectorRange {
        endTime: string;
        startTime: string;
    }
    interface AnomalyDetectorSingleMetricAnomalyDetector {
        dimensions?: outputs.cloudwatch.AnomalyDetectorDimension[];
        metricName?: string;
        namespace?: string;
        stat?: string;
    }
    interface InsightRuleTags {
    }
    /**
     * This structure defines the metrics that will be streamed.
     */
    interface MetricStreamFilter {
        /**
         * Only metrics with Namespace matching this value will be streamed.
         */
        namespace: string;
    }
    /**
     * This structure specifies a list of additional statistics to stream, and the metrics to stream those additional statistics for. All metrics that match the combination of metric name and namespace will be streamed with the extended statistics, no matter their dimensions.
     */
    interface MetricStreamStatisticsConfiguration {
        /**
         * The additional statistics to stream for the metrics listed in IncludeMetrics.
         */
        additionalStatistics: string[];
        /**
         * An array that defines the metrics that are to have additional statistics streamed.
         */
        includeMetrics: outputs.cloudwatch.MetricStreamStatisticsMetric[];
    }
    /**
     * A structure that specifies the metric name and namespace for one metric that is going to have additional statistics included in the stream.
     */
    interface MetricStreamStatisticsMetric {
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the metric.
         */
        namespace: string;
    }
    /**
     * Metadata that you can assign to a Metric Stream, consisting of a key-value pair.
     */
    interface MetricStreamTag {
        /**
         * A unique identifier for the tag.
         */
        key: string;
        /**
         * An optional string, which you can use to describe or define the tag.
         */
        value?: string;
    }
}
export declare namespace codeartifact {
    /**
     * A key-value pair to associate with a resource.
     */
    interface DomainTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface RepositoryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace codebuild {
    interface ProjectArtifacts {
        artifactIdentifier?: string;
        encryptionDisabled?: boolean;
        location?: string;
        name?: string;
        namespaceType?: string;
        overrideArtifactName?: boolean;
        packaging?: string;
        path?: string;
        type: string;
    }
    interface ProjectBatchRestrictions {
        computeTypesAllowed?: string[];
        maximumBuildsAllowed?: number;
    }
    interface ProjectBuildBatchConfig {
        batchReportMode?: string;
        combineArtifacts?: boolean;
        restrictions?: outputs.codebuild.ProjectBatchRestrictions;
        serviceRole?: string;
        timeoutInMins?: number;
    }
    interface ProjectBuildStatusConfig {
        context?: string;
        targetUrl?: string;
    }
    interface ProjectCache {
        location?: string;
        modes?: string[];
        type: string;
    }
    interface ProjectCloudWatchLogsConfig {
        groupName?: string;
        status: string;
        streamName?: string;
    }
    interface ProjectEnvironment {
        certificate?: string;
        computeType: string;
        environmentVariables?: outputs.codebuild.ProjectEnvironmentVariable[];
        image: string;
        imagePullCredentialsType?: string;
        privilegedMode?: boolean;
        registryCredential?: outputs.codebuild.ProjectRegistryCredential;
        type: string;
    }
    interface ProjectEnvironmentVariable {
        name: string;
        type?: string;
        value: string;
    }
    interface ProjectFileSystemLocation {
        identifier: string;
        location: string;
        mountOptions?: string;
        mountPoint: string;
        type: string;
    }
    interface ProjectFilterGroup {
    }
    interface ProjectGitSubmodulesConfig {
        fetchSubmodules: boolean;
    }
    interface ProjectLogsConfig {
        cloudWatchLogs?: outputs.codebuild.ProjectCloudWatchLogsConfig;
        s3Logs?: outputs.codebuild.ProjectS3LogsConfig;
    }
    interface ProjectRegistryCredential {
        credential: string;
        credentialProvider: string;
    }
    interface ProjectS3LogsConfig {
        encryptionDisabled?: boolean;
        location?: string;
        status: string;
    }
    interface ProjectSource {
        auth?: outputs.codebuild.ProjectSourceAuth;
        buildSpec?: string;
        buildStatusConfig?: outputs.codebuild.ProjectBuildStatusConfig;
        gitCloneDepth?: number;
        gitSubmodulesConfig?: outputs.codebuild.ProjectGitSubmodulesConfig;
        insecureSsl?: boolean;
        location?: string;
        reportBuildStatus?: boolean;
        sourceIdentifier?: string;
        type: string;
    }
    interface ProjectSourceAuth {
        resource?: string;
        type: string;
    }
    interface ProjectSourceVersion {
        sourceIdentifier: string;
        sourceVersion?: string;
    }
    interface ProjectTag {
        key: string;
        value: string;
    }
    interface ProjectTriggers {
        buildType?: string;
        filterGroups?: outputs.codebuild.ProjectFilterGroup[];
        webhook?: boolean;
    }
    interface ProjectVpcConfig {
        securityGroupIds?: string[];
        subnets?: string[];
        vpcId?: string;
    }
    interface ReportGroupReportExportConfig {
        exportConfigType: string;
        s3Destination?: outputs.codebuild.ReportGroupS3ReportExportConfig;
    }
    interface ReportGroupS3ReportExportConfig {
        bucket: string;
        bucketOwner?: string;
        encryptionDisabled?: boolean;
        encryptionKey?: string;
        packaging?: string;
        path?: string;
    }
    interface ReportGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace codecommit {
    interface RepositoryCode {
        branchName?: string;
        s3: outputs.codecommit.RepositoryS3;
    }
    interface RepositoryS3 {
        bucket: string;
        key: string;
        objectVersion?: string;
    }
    interface RepositoryTag {
        key: string;
        value: string;
    }
    interface RepositoryTrigger {
        branches?: string[];
        customData?: string;
        destinationArn: string;
        events: string[];
        name: string;
    }
}
export declare namespace codedeploy {
    interface ApplicationTag {
        key: string;
        value: string;
    }
    interface DeploymentConfigMinimumHealthyHosts {
        type: string;
        value: number;
    }
    interface DeploymentConfigTimeBasedCanary {
        canaryInterval: number;
        canaryPercentage: number;
    }
    interface DeploymentConfigTimeBasedLinear {
        linearInterval: number;
        linearPercentage: number;
    }
    interface DeploymentConfigTrafficRoutingConfig {
        timeBasedCanary?: outputs.codedeploy.DeploymentConfigTimeBasedCanary;
        timeBasedLinear?: outputs.codedeploy.DeploymentConfigTimeBasedLinear;
        type: string;
    }
    interface DeploymentGroupAlarm {
        name?: string;
    }
    interface DeploymentGroupAlarmConfiguration {
        alarms?: outputs.codedeploy.DeploymentGroupAlarm[];
        enabled?: boolean;
        ignorePollAlarmFailure?: boolean;
    }
    interface DeploymentGroupAutoRollbackConfiguration {
        enabled?: boolean;
        events?: string[];
    }
    interface DeploymentGroupBlueGreenDeploymentConfiguration {
        deploymentReadyOption?: outputs.codedeploy.DeploymentGroupDeploymentReadyOption;
        greenFleetProvisioningOption?: outputs.codedeploy.DeploymentGroupGreenFleetProvisioningOption;
        terminateBlueInstancesOnDeploymentSuccess?: outputs.codedeploy.DeploymentGroupBlueInstanceTerminationOption;
    }
    interface DeploymentGroupBlueInstanceTerminationOption {
        action?: string;
        terminationWaitTimeInMinutes?: number;
    }
    interface DeploymentGroupDeployment {
        description?: string;
        ignoreApplicationStopFailures?: boolean;
        revision: outputs.codedeploy.DeploymentGroupRevisionLocation;
    }
    interface DeploymentGroupDeploymentReadyOption {
        actionOnTimeout?: string;
        waitTimeInMinutes?: number;
    }
    interface DeploymentGroupDeploymentStyle {
        deploymentOption?: string;
        deploymentType?: string;
    }
    interface DeploymentGroupEC2TagFilter {
        key?: string;
        type?: string;
        value?: string;
    }
    interface DeploymentGroupEC2TagSet {
        ec2TagSetList?: outputs.codedeploy.DeploymentGroupEC2TagSetListObject[];
    }
    interface DeploymentGroupEC2TagSetListObject {
        ec2TagGroup?: outputs.codedeploy.DeploymentGroupEC2TagFilter[];
    }
    interface DeploymentGroupECSService {
        clusterName: string;
        serviceName: string;
    }
    interface DeploymentGroupELBInfo {
        name?: string;
    }
    interface DeploymentGroupGitHubLocation {
        commitId: string;
        repository: string;
    }
    interface DeploymentGroupGreenFleetProvisioningOption {
        action?: string;
    }
    interface DeploymentGroupLoadBalancerInfo {
        elbInfoList?: outputs.codedeploy.DeploymentGroupELBInfo[];
        targetGroupInfoList?: outputs.codedeploy.DeploymentGroupTargetGroupInfo[];
        targetGroupPairInfoList?: outputs.codedeploy.DeploymentGroupTargetGroupPairInfo[];
    }
    interface DeploymentGroupOnPremisesTagSet {
        onPremisesTagSetList?: outputs.codedeploy.DeploymentGroupOnPremisesTagSetListObject[];
    }
    interface DeploymentGroupOnPremisesTagSetListObject {
        onPremisesTagGroup?: outputs.codedeploy.DeploymentGroupTagFilter[];
    }
    interface DeploymentGroupRevisionLocation {
        gitHubLocation?: outputs.codedeploy.DeploymentGroupGitHubLocation;
        revisionType?: string;
        s3Location?: outputs.codedeploy.DeploymentGroupS3Location;
    }
    interface DeploymentGroupS3Location {
        bucket: string;
        bundleType?: string;
        eTag?: string;
        key: string;
        version?: string;
    }
    interface DeploymentGroupTag {
        key: string;
        value: string;
    }
    interface DeploymentGroupTagFilter {
        key?: string;
        type?: string;
        value?: string;
    }
    interface DeploymentGroupTargetGroupInfo {
        name?: string;
    }
    interface DeploymentGroupTargetGroupPairInfo {
        prodTrafficRoute?: outputs.codedeploy.DeploymentGroupTrafficRoute;
        targetGroups?: outputs.codedeploy.DeploymentGroupTargetGroupInfo[];
        testTrafficRoute?: outputs.codedeploy.DeploymentGroupTrafficRoute;
    }
    interface DeploymentGroupTrafficRoute {
        listenerArns?: string[];
    }
    interface DeploymentGroupTriggerConfig {
        triggerEvents?: string[];
        triggerName?: string;
        triggerTargetArn?: string;
    }
}
export declare namespace codeguruprofiler {
    /**
     * The agent permissions attached to this profiling group.
     */
    interface AgentPermissionsProperties {
        /**
         * The principals for the agent permissions.
         */
        principals: string[];
    }
    /**
     * Notification medium for users to get alerted for events that occur in application profile. We support SNS topic as a notification channel.
     */
    interface ProfilingGroupChannel {
        channelId?: string;
        channelUri: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ProfilingGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        value: string;
    }
}
export declare namespace codegurureviewer {
    /**
     * A key-value pair to associate with a resource.
     */
    interface RepositoryAssociationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        value: string;
    }
}
export declare namespace codepipeline {
    interface CustomActionTypeArtifactDetails {
        maximumCount: number;
        minimumCount: number;
    }
    interface CustomActionTypeConfigurationProperties {
        description?: string;
        key: boolean;
        name: string;
        queryable?: boolean;
        required: boolean;
        secret: boolean;
        type?: string;
    }
    interface CustomActionTypeSettings {
        entityUrlTemplate?: string;
        executionUrlTemplate?: string;
        revisionUrlTemplate?: string;
        thirdPartyConfigurationUrl?: string;
    }
    interface CustomActionTypeTag {
        key: string;
        value: string;
    }
    interface PipelineActionDeclaration {
        actionTypeId: outputs.codepipeline.PipelineActionTypeId;
        configuration?: any;
        inputArtifacts?: outputs.codepipeline.PipelineInputArtifact[];
        name: string;
        namespace?: string;
        outputArtifacts?: outputs.codepipeline.PipelineOutputArtifact[];
        region?: string;
        roleArn?: string;
        runOrder?: number;
    }
    interface PipelineActionTypeId {
        category: string;
        owner: string;
        provider: string;
        version: string;
    }
    interface PipelineArtifactStore {
        encryptionKey?: outputs.codepipeline.PipelineEncryptionKey;
        location: string;
        type: string;
    }
    interface PipelineArtifactStoreMap {
        artifactStore: outputs.codepipeline.PipelineArtifactStore;
        region: string;
    }
    interface PipelineBlockerDeclaration {
        name: string;
        type: string;
    }
    interface PipelineEncryptionKey {
        id: string;
        type: string;
    }
    interface PipelineInputArtifact {
        name: string;
    }
    interface PipelineOutputArtifact {
        name: string;
    }
    interface PipelineStageDeclaration {
        actions: outputs.codepipeline.PipelineActionDeclaration[];
        blockers?: outputs.codepipeline.PipelineBlockerDeclaration[];
        name: string;
    }
    interface PipelineStageTransition {
        reason: string;
        stageName: string;
    }
    interface PipelineTag {
        key: string;
        value: string;
    }
    interface WebhookAuthConfiguration {
        allowedIPRange?: string;
        secretToken?: string;
    }
    interface WebhookFilterRule {
        jsonPath: string;
        matchEquals?: string;
    }
}
export declare namespace codestar {
    interface GitHubRepositoryCode {
        s3: outputs.codestar.GitHubRepositoryS3;
    }
    interface GitHubRepositoryS3 {
        bucket: string;
        key: string;
        objectVersion?: string;
    }
}
export declare namespace codestarconnections {
    /**
     * A key-value pair to associate with a resource.
     */
    interface ConnectionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace codestarnotifications {
    interface NotificationRuleTarget {
        targetAddress: string;
        targetType: string;
    }
}
export declare namespace cognito {
    interface IdentityPoolCognitoIdentityProvider {
        clientId?: string;
        providerName?: string;
        serverSideTokenCheck?: boolean;
    }
    interface IdentityPoolCognitoStreams {
        roleArn?: string;
        streamName?: string;
        streamingStatus?: string;
    }
    interface IdentityPoolPushSync {
        applicationArns?: string[];
        roleArn?: string;
    }
    interface UserPoolAccountRecoverySetting {
        recoveryMechanisms?: outputs.cognito.UserPoolRecoveryOption[];
    }
    interface UserPoolAddOns {
        advancedSecurityMode?: string;
    }
    interface UserPoolAdminCreateUserConfig {
        allowAdminCreateUserOnly?: boolean;
        inviteMessageTemplate?: outputs.cognito.UserPoolInviteMessageTemplate;
        unusedAccountValidityDays?: number;
    }
    interface UserPoolClientAnalyticsConfiguration {
        applicationArn?: string;
        applicationId?: string;
        externalId?: string;
        roleArn?: string;
        userDataShared?: boolean;
    }
    interface UserPoolClientTokenValidityUnits {
        accessToken?: string;
        idToken?: string;
        refreshToken?: string;
    }
    interface UserPoolCustomEmailSender {
        lambdaArn?: string;
        lambdaVersion?: string;
    }
    interface UserPoolCustomSMSSender {
        lambdaArn?: string;
        lambdaVersion?: string;
    }
    interface UserPoolDeviceConfiguration {
        challengeRequiredOnNewDevice?: boolean;
        deviceOnlyRememberedOnUserPrompt?: boolean;
    }
    interface UserPoolDomainCustomDomainConfigType {
        certificateArn?: string;
    }
    interface UserPoolEmailConfiguration {
        configurationSet?: string;
        emailSendingAccount?: string;
        from?: string;
        replyToEmailAddress?: string;
        sourceArn?: string;
    }
    interface UserPoolInviteMessageTemplate {
        emailMessage?: string;
        emailSubject?: string;
        sMSMessage?: string;
    }
    interface UserPoolLambdaConfig {
        createAuthChallenge?: string;
        customEmailSender?: outputs.cognito.UserPoolCustomEmailSender;
        customMessage?: string;
        customSMSSender?: outputs.cognito.UserPoolCustomSMSSender;
        defineAuthChallenge?: string;
        kMSKeyID?: string;
        postAuthentication?: string;
        postConfirmation?: string;
        preAuthentication?: string;
        preSignUp?: string;
        preTokenGeneration?: string;
        userMigration?: string;
        verifyAuthChallengeResponse?: string;
    }
    interface UserPoolNumberAttributeConstraints {
        maxValue?: string;
        minValue?: string;
    }
    interface UserPoolPasswordPolicy {
        minimumLength?: number;
        requireLowercase?: boolean;
        requireNumbers?: boolean;
        requireSymbols?: boolean;
        requireUppercase?: boolean;
        temporaryPasswordValidityDays?: number;
    }
    interface UserPoolPolicies {
        passwordPolicy?: outputs.cognito.UserPoolPasswordPolicy;
    }
    interface UserPoolRecoveryOption {
        name?: string;
        priority?: number;
    }
    interface UserPoolResourceServerResourceServerScopeType {
        scopeDescription: string;
        scopeName: string;
    }
    interface UserPoolRiskConfigurationAttachmentAccountTakeoverActionType {
        eventAction: string;
        notify: boolean;
    }
    interface UserPoolRiskConfigurationAttachmentAccountTakeoverActionsType {
        highAction?: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionType;
        lowAction?: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionType;
        mediumAction?: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionType;
    }
    interface UserPoolRiskConfigurationAttachmentAccountTakeoverRiskConfigurationType {
        actions: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionsType;
        notifyConfiguration?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyConfigurationType;
    }
    interface UserPoolRiskConfigurationAttachmentCompromisedCredentialsActionsType {
        eventAction: string;
    }
    interface UserPoolRiskConfigurationAttachmentCompromisedCredentialsRiskConfigurationType {
        actions: outputs.cognito.UserPoolRiskConfigurationAttachmentCompromisedCredentialsActionsType;
        eventFilter?: string[];
    }
    interface UserPoolRiskConfigurationAttachmentNotifyConfigurationType {
        blockEmail?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailType;
        from?: string;
        mfaEmail?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailType;
        noActionEmail?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailType;
        replyTo?: string;
        sourceArn: string;
    }
    interface UserPoolRiskConfigurationAttachmentNotifyEmailType {
        htmlBody?: string;
        subject: string;
        textBody?: string;
    }
    interface UserPoolRiskConfigurationAttachmentRiskExceptionConfigurationType {
        blockedIPRangeList?: string[];
        skippedIPRangeList?: string[];
    }
    interface UserPoolSchemaAttribute {
        attributeDataType?: string;
        developerOnlyAttribute?: boolean;
        mutable?: boolean;
        name?: string;
        numberAttributeConstraints?: outputs.cognito.UserPoolNumberAttributeConstraints;
        required?: boolean;
        stringAttributeConstraints?: outputs.cognito.UserPoolStringAttributeConstraints;
    }
    interface UserPoolSmsConfiguration {
        externalId?: string;
        snsCallerArn?: string;
        snsRegion?: string;
    }
    interface UserPoolStringAttributeConstraints {
        maxLength?: string;
        minLength?: string;
    }
    interface UserPoolUserAttributeType {
        name?: string;
        value?: string;
    }
    interface UserPoolUserAttributeUpdateSettings {
        attributesRequireVerificationBeforeUpdate: string[];
    }
    interface UserPoolUsernameConfiguration {
        caseSensitive?: boolean;
    }
    interface UserPoolVerificationMessageTemplate {
        defaultEmailOption?: string;
        emailMessage?: string;
        emailMessageByLink?: string;
        emailSubject?: string;
        emailSubjectByLink?: string;
        smsMessage?: string;
    }
}
export declare namespace config {
    /**
     * The configuration for a Provider to assume a role.
     */
    interface AssumeRole {
        /**
         * Number of seconds to restrict the assume role session duration.
         */
        durationSeconds?: number;
        /**
         * External identifier to use when assuming the role.
         */
        externalId?: string;
        /**
         * IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
         */
        policy?: string;
        /**
         * Set of Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the role.
         */
        policyArns?: string[];
        /**
         * Amazon Resource Name (ARN) of the IAM Role to assume.
         */
        roleArn?: string;
        /**
         * Session name to use when assuming the role.
         */
        sessionName?: string;
        /**
         * Map of assume role session tags.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * A list of keys for session tags that you want to set as transitive. If you set a tag key as transitive, the corresponding key and value passes to subsequent sessions in a role chain.
         */
        transitiveTagKeys?: string[];
    }
    /**
     * The configuration with resource tag settings to apply across all resources handled by this provider. This is designed to replace redundant per-resource `tags` configurations. Provider tags can be overridden with new values, but not excluded from specific resources. To override provider tag values, use the `tags` argument within a resource to configure new tag values for matching keys.
     */
    interface DefaultTags {
        /**
         * A group of tags to set across all resources.
         */
        tags?: {
            [key: string]: string;
        };
    }
    /**
     * The configuration for for customizing service endpoints.
     */
    interface Endpoints {
        /**
         * Override the default endpoint for AWS Access Analyzer
         */
        accessanalyzer?: string;
        /**
         * Override the default endpoint for AWS Certificate Manager
         */
        acm?: string;
        /**
         * Override the default endpoint for AWS Certificate Manager Private Certificate Authority
         */
        acmpca?: string;
        /**
         * Override the default endpoint for AWS Amplify Console
         */
        amplify?: string;
        /**
         * Override the default endpoint for AWS AppConfig
         */
        appconfig?: string;
        /**
         * Override the default endpoint for AWS Application Auto Scaling
         */
        applicationautoscaling?: string;
        /**
         * Override the default endpoint for AWS CloudWatch Application Insights
         */
        applicationinsights?: string;
        /**
         * Override the default endpoint for AWS App Mesh
         */
        appmesh?: string;
        /**
         * Override the default endpoint for AWS App Runner
         */
        apprunner?: string;
        /**
         * Override the default endpoint for AWS AppStream 2.0
         */
        appstream?: string;
        /**
         * Override the default endpoint for AWS AppSync
         */
        appsync?: string;
        /**
         * Override the default endpoint for AWS Athena
         */
        athena?: string;
        /**
         * Override the default endpoint for AWS Audit Manager
         */
        auditmanager?: string;
        /**
         * Override the default endpoint for AWS Auto Scaling
         */
        autoscaling?: string;
        /**
         * Override the default endpoint for AWS Backup
         */
        backup?: string;
        /**
         * Override the default endpoint for AWS Batch
         */
        batch?: string;
        /**
         * Override the default endpoint for AWS Budgets
         */
        budgets?: string;
        /**
         * Override the default endpoint for Amazon Chime
         */
        chime?: string;
        /**
         * Override the default endpoint for AWS Cloud9
         */
        cloud9?: string;
        /**
         * Override the default endpoint for AWS CloudFormation
         */
        cloudformation?: string;
        /**
         * Override the default endpoint for AWS CloudFront
         */
        cloudfront?: string;
        /**
         * Override the default endpoint for AWS CloudHSM
         */
        cloudhsm?: string;
        /**
         * Override the default endpoint for AWS CloudSearch
         */
        cloudsearch?: string;
        /**
         * Override the default endpoint for AWS CloudTrail
         */
        cloudtrail?: string;
        /**
         * Override the default endpoint for AWS CloudWatch
         */
        cloudwatch?: string;
        /**
         * Override the default endpoint for AWS CloudWatch Events
         */
        cloudwatchevents?: string;
        /**
         * Override the default endpoint for AWS CloudWatch Logs
         */
        cloudwatchlogs?: string;
        /**
         * Override the default endpoint for AWS CodeArtifact
         */
        codeartifact?: string;
        /**
         * Override the default endpoint for AWS CodeBuild
         */
        codebuild?: string;
        /**
         * Override the default endpoint for AWS CodeCommit
         */
        codecommit?: string;
        /**
         * Override the default endpoint for AWS CodeDeploy
         */
        codedeploy?: string;
        /**
         * Override the default endpoint for AWS CodePipeline
         */
        codepipeline?: string;
        /**
         * Override the default endpoint for AWS CodeStart Connections
         */
        codestarconnections?: string;
        /**
         * Override the default endpoint for Amazon Cognito
         */
        cognitoidentity?: string;
        /**
         * Override the default endpoint for AWS Config
         */
        configservice?: string;
        /**
         * Override the default endpoint for Amazon Connect
         */
        connect?: string;
        /**
         * Override the default endpoint for AWS Cost and Usage Reports
         */
        cur?: string;
        /**
         * Override the default endpoint for AWS Data Exchange
         */
        dataexchange?: string;
        /**
         * Override the default endpoint for AWS Data Pipeline
         */
        datapipeline?: string;
        /**
         * Override the default endpoint for AWS DataSync
         */
        datasync?: string;
        /**
         * Override the default endpoint for AWS DynamoDB Accelerator
         */
        dax?: string;
        /**
         * Override the default endpoint for AWS Detective
         */
        detective?: string;
        /**
         * Override the default endpoint for AWS Device Farm
         */
        devicefarm?: string;
        /**
         * Override the default endpoint for AWS Direct Connect
         */
        directconnect?: string;
        /**
         * Override the default endpoint for AWS Data Lifecycle Manager
         */
        dlm?: string;
        /**
         * Override the default endpoint for AWS Database Migration Service
         */
        dms?: string;
        /**
         * Override the default endpoint for AWS DocumentDB
         */
        docdb?: string;
        /**
         * Override the default endpoint for AWS Directory Service
         */
        ds?: string;
        /**
         * Override the default endpoint for AWS DynamoDB
         */
        dynamodb?: string;
        /**
         * Override the default endpoint for AWS Elastic Compute Cloud (EC2)
         */
        ec2?: string;
        /**
         * Override the default endpoint for AWS Elastic Container Registry (ECR)
         */
        ecr?: string;
        /**
         * Override the default endpoint for AWS Elastic Container Registry (ECR) Public
         */
        ecrpublic?: string;
        /**
         * Override the default endpoint for AWS Elastic Container Service (ECS)
         */
        ecs?: string;
        /**
         * Override the default endpoint for AWS Elastic File System (EFS)
         */
        efs?: string;
        /**
         * Override the default endpoint for AWS Elastic Kubernetes Service (EKS)
         */
        eks?: string;
        /**
         * Override the default endpoint for AWS ElastiCache
         */
        elasticache?: string;
        /**
         * Override the default endpoint for AWS Elastic Beanstalk
         */
        elasticbeanstalk?: string;
        /**
         * Override the default endpoint for AWS Elastic Transcoder
         */
        elastictranscoder?: string;
        /**
         * Override the default endpoint for AWS Elastic Load Balancing
         */
        elb?: string;
        /**
         * Override the default endpoint for AWS Elastic Load Balancing V2
         */
        elbv2?: string;
        /**
         * Override the default endpoint for AWS EMR
         */
        emr?: string;
        /**
         * Override the default endpoint for AWS EMR on EKS
         */
        emrcontainers?: string;
        /**
         * Override the default endpoint for AWS OpenSearch Service (formerly Elasticsearch)
         */
        es?: string;
        /**
         * Override the default endpoint for AWS Kinesis Data Firehose
         */
        firehose?: string;
        /**
         * Override the default endpoint for AWS Firewall Manager
         */
        fms?: string;
        /**
         * Override the default endpoint for Amazon Forecast
         */
        forecast?: string;
        /**
         * Override the default endpoint for AWS FSx
         */
        fsx?: string;
        /**
         * Override the default endpoint for AWS GameLift
         */
        gamelift?: string;
        /**
         * Override the default endpoint for Amazon S3 Glacier
         */
        glacier?: string;
        /**
         * Override the default endpoint for AWS Global Accelerator
         */
        globalaccelerator?: string;
        /**
         * Override the default endpoint for AWS Glue
         */
        glue?: string;
        /**
         * Override the default endpoint for AWS IoT Greengrass
         */
        greengrass?: string;
        /**
         * Override the default endpoint for AWS GuardDuty
         */
        guardduty?: string;
        /**
         * Override the default endpoint for AWS Identity and Access Management
         */
        iam?: string;
        /**
         * Override the default endpoint for AWS Single Sign-On (SSO) Identity Store
         */
        identitystore?: string;
        /**
         * Override the default endpoint for AWS Image Builder
         */
        imagebuilder?: string;
        /**
         * Override the default endpoint for Amazon Inspector
         */
        inspector?: string;
        /**
         * Override the default endpoint for AWS IoT
         */
        iot?: string;
        /**
         * Override the default endpoint for AWS IoT Analytics
         */
        iotanalytics?: string;
        /**
         * Override the default endpoint for AWS IoT Events
         */
        iotevents?: string;
        /**
         * Override the default endpoint for Amazon Managed Streaming for Apache Kafka (MSK)
         */
        kafka?: string;
        /**
         * Override the default endpoint for Amazon Kinesis
         */
        kinesis?: string;
        /**
         * Override the default endpoint for Amazon Kinesis Data Analytics
         */
        kinesisanalytics?: string;
        /**
         * Override the default endpoint for Amazon Kinesis Data Analytics V2
         */
        kinesisanalyticsv2?: string;
        /**
         * Override the default endpoint for Amazon Kinesis Video Streams
         */
        kinesisvideo?: string;
        /**
         * Override the default endpoint for AWS Key Management Service
         */
        kms?: string;
        /**
         * Override the default endpoint for AWS Lake Formation
         */
        lakeformation?: string;
        /**
         * Override the default endpoint for AWS Lambda
         */
        lambda?: string;
        /**
         * Override the default endpoint for Amazon Lex
         */
        lexmodels?: string;
        /**
         * Override the default endpoint for AWS License Manager
         */
        licensemanager?: string;
        /**
         * Override the default endpoint for Amazon Lightsail
         */
        lightsail?: string;
        /**
         * Override the default endpoint for Amazon Location
         */
        location?: string;
        /**
         * Override the default endpoint for Amazon Macie
         */
        macie?: string;
        /**
         * Override the default endpoint for Amazon Macie V2
         */
        macie2?: string;
        /**
         * Override the default endpoint for Amazon Managed Blockchain
         */
        managedblockchain?: string;
        /**
         * Override the default endpoint for AWS Marketplace Catalog
         */
        marketplacecatalog?: string;
        /**
         * Override the default endpoint for AWS MediaConnect
         */
        mediaconnect?: string;
        /**
         * Override the default endpoint for AWS MediaConvert
         */
        mediaconvert?: string;
        /**
         * Override the default endpoint for AWS MediaLive
         */
        medialive?: string;
        /**
         * Override the default endpoint for AWS MediaPackage
         */
        mediapackage?: string;
        /**
         * Override the default endpoint for AWS Elemental MediaStore container
         */
        mediastore?: string;
        /**
         * Override the default endpoint for AWS Elemental MediaStore asset
         */
        mediastoredata?: string;
        /**
         * Override the default endpoint for AWS MemoryDB for Redis
         */
        memorydb?: string;
        /**
         * Override the default endpoint for Amazon MQ
         */
        mq?: string;
        /**
         * Override the default endpoint for Amazon Managed Workflows for Apache Airflow
         */
        mwaa?: string;
        /**
         * Override the default endpoint for Amazon Neptune
         */
        neptune?: string;
        /**
         * Override the default endpoint for AWS Network Firewall
         */
        networkfirewall?: string;
        /**
         * Override the default endpoint for AWS Network Manager
         */
        networkmanager?: string;
        /**
         * Override the default endpoint for AWS OpsWorks
         */
        opsworks?: string;
        /**
         * Override the default endpoint for AWS Organizations
         */
        organizations?: string;
        /**
         * Override the default endpoint for AWS Outposts
         */
        outposts?: string;
        /**
         * Override the default endpoint for Amazon Personalize
         */
        personalize?: string;
        /**
         * Override the default endpoint for Amazon Pinpoint
         */
        pinpoint?: string;
        /**
         * Override the default endpoint for Amazon Web Services Price List Service
         */
        pricing?: string;
        /**
         * Override the default endpoint for Amazon QLDB
         */
        qldb?: string;
        /**
         * Override the default endpoint for Amazon QuickSight
         */
        quicksight?: string;
        /**
         * Override the default endpoint for AWS Resource Access Manager
         */
        ram?: string;
        /**
         * Override the default endpoint for Amazon Relational Database Service
         */
        rds?: string;
        /**
         * Override the default endpoint for Amazon Redshift
         */
        redshift?: string;
        /**
         * Override the default endpoint for AWS Resource Groups
         */
        resourcegroups?: string;
        /**
         * Override the default endpoint for AWS Resource Groups Tagging API
         */
        resourcegroupstaggingapi?: string;
        /**
         * Override the default endpoint for Amazon Route 53
         */
        route53?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Domains
         */
        route53domains?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Recovery Control
         */
        route53recoverycontrolconfig?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Recovery Readiness
         */
        route53recoveryreadiness?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Resolver
         */
        route53resolver?: string;
        /**
         * Override the default endpoint for Amazon Simple Storage Service (S3)
         */
        s3?: string;
        /**
         * Override the default endpoint for Amazon Simple Storage Service (S3) Control
         */
        s3control?: string;
        /**
         * Override the default endpoint for Amazon S3 on Outposts
         */
        s3outposts?: string;
        /**
         * Override the default endpoint for AWS SageMaker
         */
        sagemaker?: string;
        /**
         * Override the default endpoint for Amazon EventBridge Schema Registry
         */
        schemas?: string;
        /**
         * Override the default endpoint for Amazon SimpleDB
         */
        sdb?: string;
        /**
         * Override the default endpoint for AWS Secrets Manager
         */
        secretsmanager?: string;
        /**
         * Override the default endpoint for AWS Security Hub
         */
        securityhub?: string;
        /**
         * Override the default endpoint for AWS Serverless Application Repository
         */
        serverlessrepo?: string;
        /**
         * Override the default endpoint for AWS Service Catalog
         */
        servicecatalog?: string;
        /**
         * Override the default endpoint for AWS Cloud Map
         */
        servicediscovery?: string;
        /**
         * Override the default endpoint for AWS Service Quotas
         */
        servicequotas?: string;
        /**
         * Override the default endpoint for Amazon Simple Email Service (SES)
         */
        ses?: string;
        /**
         * Override the default endpoint for AWS Shield Advanced API
         */
        shield?: string;
        /**
         * Override the default endpoint for AWS Signer
         */
        signer?: string;
        /**
         * Override the default endpoint for Amazon Simple Notification Service (SNS)
         */
        sns?: string;
        /**
         * Override the default endpoint for Amazon Simple Queue Service (SQS)
         */
        sqs?: string;
        /**
         * Override the default endpoint for AWS Systems Manager
         */
        ssm?: string;
        /**
         * Override the default endpoint for AWS Single Sign On (SSO)
         */
        ssoadmin?: string;
        /**
         * Override the default endpoint for AWS Step Functions
         */
        stepfunctions?: string;
        /**
         * Override the default endpoint for AWS Storage Gateway
         */
        storagegateway?: string;
        /**
         * Override the default endpoint for AWS Security Token Service (STS)
         */
        sts?: string;
        /**
         * Override the default endpoint for Amazon Simple Workflow Service (SWF)
         */
        swf?: string;
        /**
         * Override the default endpoint for Amazon CloudWatch Synthetics
         */
        synthetics?: string;
        /**
         * Override the default endpoint for Amazon Timestream
         */
        timestreamwrite?: string;
        /**
         * Override the default endpoint for AWS Transfer Family
         */
        transfer?: string;
        /**
         * Override the default endpoint for AWS WAF Classic
         */
        waf?: string;
        /**
         * Override the default endpoint for AWS WAF Regional Classic
         */
        wafregional?: string;
        /**
         * Override the default endpoint for AWS WAF V2
         */
        wafv2?: string;
        /**
         * Override the default endpoint for Amazon WorkLink
         */
        worklink?: string;
        /**
         * Override the default endpoint for Amazon WorkMail
         */
        workmail?: string;
        /**
         * Override the default endpoint for Amazon WorkSpaces
         */
        workspaces?: string;
        /**
         * Override the default endpoint for AWS X-Ray
         */
        xray?: string;
    }
    /**
     * The configuration with resource tag settings to ignore across all resources handled by this provider (except any individual service tag resources such as `ec2.Tag`) for situations where external systems are managing certain resource tags.
     */
    interface IgnoreTags {
        /**
         * List of exact resource tag keys to ignore across all resources handled by this provider. This configuration prevents Pulumi from returning the tag in any `tags` attributes and displaying any configuration difference for the tag value. If any resource configuration still has this tag key configured in the `tags` argument, it will display a perpetual difference until the tag is removed from the argument or `ignoreChanges` is also used.
         */
        keyPrefixes?: string[];
        /**
         * List of resource tag key prefixes to ignore across all resources handled by this provider. This configuration prevents Pulumi from returning any tag key matching the prefixes in any `tags` attributes and displaying any configuration difference for those tag values. If any resource configuration still has a tag matching one of the prefixes configured in the `tags` argument, it will display a perpetual difference until the tag is removed from the argument or `ignoreChanges` is also used.
         */
        keys?: string[];
    }
}
export declare namespace configuration {
    /**
     * A key-value pair to associate with a resource.
     */
    interface AggregationAuthorizationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ConfigRuleCustomPolicyDetails {
        enableDebugLogDelivery?: boolean;
        policyRuntime?: string;
        policyText?: string;
    }
    interface ConfigRuleScope {
        complianceResourceId?: string;
        complianceResourceTypes?: string[];
        tagKey?: string;
        tagValue?: string;
    }
    interface ConfigRuleSource {
        customPolicyDetails?: outputs.configuration.ConfigRuleCustomPolicyDetails;
        owner: string;
        sourceDetails?: outputs.configuration.ConfigRuleSourceDetail[];
        sourceIdentifier?: string;
    }
    interface ConfigRuleSourceDetail {
        eventSource: string;
        maximumExecutionFrequency?: string;
        messageType: string;
    }
    interface ConfigurationAggregatorAccountAggregationSource {
        accountIds: string[];
        allAwsRegions?: boolean;
        awsRegions?: string[];
    }
    interface ConfigurationAggregatorOrganizationAggregationSource {
        allAwsRegions?: boolean;
        awsRegions?: string[];
        roleArn: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ConfigurationAggregatorTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ConfigurationRecorderRecordingGroup {
        allSupported?: boolean;
        includeGlobalResourceTypes?: boolean;
        resourceTypes?: string[];
    }
    /**
     * Input parameters in the form of key-value pairs for the conformance pack.
     */
    interface ConformancePackInputParameter {
        parameterName: string;
        parameterValue: string;
    }
    interface DeliveryChannelConfigSnapshotDeliveryProperties {
        deliveryFrequency?: string;
    }
    interface OrganizationConfigRuleOrganizationCustomRuleMetadata {
        description?: string;
        inputParameters?: string;
        lambdaFunctionArn: string;
        maximumExecutionFrequency?: string;
        organizationConfigRuleTriggerTypes: string[];
        resourceIdScope?: string;
        resourceTypesScope?: string[];
        tagKeyScope?: string;
        tagValueScope?: string;
    }
    interface OrganizationConfigRuleOrganizationManagedRuleMetadata {
        description?: string;
        inputParameters?: string;
        maximumExecutionFrequency?: string;
        resourceIdScope?: string;
        resourceTypesScope?: string[];
        ruleIdentifier: string;
        tagKeyScope?: string;
        tagValueScope?: string;
    }
    /**
     * Input parameters in the form of key-value pairs for the conformance pack.
     */
    interface OrganizationConformancePackConformancePackInputParameter {
        parameterName: string;
        parameterValue: string;
    }
    interface RemediationConfigurationExecutionControls {
        ssmControls?: outputs.configuration.RemediationConfigurationSsmControls;
    }
    interface RemediationConfigurationSsmControls {
        concurrentExecutionRatePercentage?: number;
        errorPercentage?: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface StoredQueryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The TemplateSSMDocumentDetails object contains the name of the SSM document and the version of the SSM document.
     */
    interface TemplateSSMDocumentDetailsProperties {
        documentName?: string;
        documentVersion?: string;
    }
}
export declare namespace connect {
    /**
     * The constraints for the task template
     */
    interface ConstraintsProperties {
        invisibleFields?: outputs.connect.TaskTemplateInvisibleFieldInfo[];
        readOnlyFields?: outputs.connect.TaskTemplateReadOnlyFieldInfo[];
        requiredFields?: outputs.connect.TaskTemplateRequiredFieldInfo[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ContactFlowModuleTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is maximum of 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ContactFlowTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. . You can specify a value that is maximum of 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Contains information about the hours of operation.
     */
    interface HoursOfOperationConfig {
        /**
         * The day that the hours of operation applies to.
         */
        day: enums.connect.HoursOfOperationConfigDay;
        /**
         * The end time that your contact center closes.
         */
        endTime: outputs.connect.HoursOfOperationTimeSlice;
        /**
         * The start time that your contact center opens.
         */
        startTime: outputs.connect.HoursOfOperationTimeSlice;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface HoursOfOperationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is maximum of 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The start time or end time for an hours of operation.
     */
    interface HoursOfOperationTimeSlice {
        /**
         * The hours.
         */
        hours: number;
        /**
         * The minutes.
         */
        minutes: number;
    }
    interface InstanceAttributes {
        autoResolveBestVoices?: boolean;
        contactLens?: boolean;
        contactflowLogs?: boolean;
        earlyMedia?: boolean;
        inboundCalls: boolean;
        outboundCalls: boolean;
        useCustomTTSVoices?: boolean;
    }
    interface InstanceStorageConfigEncryptionConfig {
        encryptionType: enums.connect.InstanceStorageConfigEncryptionType;
        keyId: string;
    }
    interface InstanceStorageConfigKinesisFirehoseConfig {
        firehoseArn: string;
    }
    interface InstanceStorageConfigKinesisStreamConfig {
        streamArn: string;
    }
    interface InstanceStorageConfigKinesisVideoStreamConfig {
        encryptionConfig?: outputs.connect.InstanceStorageConfigEncryptionConfig;
        prefix: string;
        retentionPeriodHours: number;
    }
    interface InstanceStorageConfigS3Config {
        bucketName: string;
        bucketPrefix: string;
        encryptionConfig?: outputs.connect.InstanceStorageConfigEncryptionConfig;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface PhoneNumberTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Configuration settings for the quick connect.
     */
    interface QuickConnectConfig {
        phoneConfig?: outputs.connect.QuickConnectPhoneNumberQuickConnectConfig;
        queueConfig?: outputs.connect.QuickConnectQueueQuickConnectConfig;
        quickConnectType: enums.connect.QuickConnectType;
        userConfig?: outputs.connect.QuickConnectUserQuickConnectConfig;
    }
    /**
     * The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
     */
    interface QuickConnectPhoneNumberQuickConnectConfig {
        phoneNumber: string;
    }
    /**
     * The queue configuration. This is required only if QuickConnectType is QUEUE.
     */
    interface QuickConnectQueueQuickConnectConfig {
        contactFlowArn: string;
        queueArn: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface QuickConnectTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is maximum of 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The user configuration. This is required only if QuickConnectType is USER.
     */
    interface QuickConnectUserQuickConnectConfig {
        contactFlowArn: string;
        userArn: string;
    }
    /**
     * the default value for the task template's field
     */
    interface TaskTemplateDefaultFieldValue {
        defaultValue: string;
        id: outputs.connect.TaskTemplateFieldIdentifier;
    }
    /**
     * A task template field object.
     */
    interface TaskTemplateField {
        /**
         * The description of the task template's field
         */
        description?: string;
        id: outputs.connect.TaskTemplateFieldIdentifier;
        /**
         * list of field options to be used with single select
         */
        singleSelectOptions?: string[];
        type: enums.connect.TaskTemplateFieldType;
    }
    /**
     * the identifier (name) for the task template field
     */
    interface TaskTemplateFieldIdentifier {
        /**
         * The name of the task template field
         */
        name: string;
    }
    /**
     * Invisible field info
     */
    interface TaskTemplateInvisibleFieldInfo {
        id: outputs.connect.TaskTemplateFieldIdentifier;
    }
    /**
     * ReadOnly field info
     */
    interface TaskTemplateReadOnlyFieldInfo {
        id: outputs.connect.TaskTemplateFieldIdentifier;
    }
    /**
     * Required field info
     */
    interface TaskTemplateRequiredFieldInfo {
        id: outputs.connect.TaskTemplateFieldIdentifier;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface TaskTemplateTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. . You can specify a value that is maximum of 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Contains information about the identity of a user.
     */
    interface UserIdentityInfo {
        email?: string;
        firstName?: string;
        lastName?: string;
        mobile?: string;
        secondaryEmail?: string;
    }
    /**
     * Contains information about the phone configuration settings for a user.
     */
    interface UserPhoneConfig {
        afterContactWorkTimeLimit?: number;
        autoAccept?: boolean;
        deskPhoneNumber?: string;
        phoneType: enums.connect.UserPhoneType;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface UserTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is maximum of 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace connectcampaigns {
    /**
     * The possible types of dialer config parameters
     */
    interface CampaignDialerConfig {
    }
    /**
     * The configuration used for outbound calls.
     */
    interface CampaignOutboundCallConfig {
        /**
         * The identifier of the contact flow for the outbound call.
         */
        connectContactFlowArn: string;
        /**
         * The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
         */
        connectQueueArn: string;
        /**
         * The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
         */
        connectSourcePhoneNumber?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface CampaignTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that's 1 to 256 characters in length.
         */
        value: string;
    }
}
export declare namespace customerprofiles {
    interface DomainTag {
        key: string;
        value: string;
    }
    interface IntegrationConnectorOperator {
        marketo?: enums.customerprofiles.IntegrationMarketoConnectorOperator;
        s3?: enums.customerprofiles.IntegrationS3ConnectorOperator;
        salesforce?: enums.customerprofiles.IntegrationSalesforceConnectorOperator;
        serviceNow?: enums.customerprofiles.IntegrationServiceNowConnectorOperator;
        zendesk?: enums.customerprofiles.IntegrationZendeskConnectorOperator;
    }
    interface IntegrationFlowDefinition {
        description?: string;
        flowName: string;
        kmsArn: string;
        sourceFlowConfig: outputs.customerprofiles.IntegrationSourceFlowConfig;
        tasks: outputs.customerprofiles.IntegrationTask[];
        triggerConfig: outputs.customerprofiles.IntegrationTriggerConfig;
    }
    interface IntegrationIncrementalPullConfig {
        datetimeTypeFieldName?: string;
    }
    interface IntegrationMarketoSourceProperties {
        object: string;
    }
    interface IntegrationObjectTypeMapping {
        key: string;
        value: string;
    }
    interface IntegrationS3SourceProperties {
        bucketName: string;
        bucketPrefix?: string;
    }
    interface IntegrationSalesforceSourceProperties {
        enableDynamicFieldUpdate?: boolean;
        includeDeletedRecords?: boolean;
        object: string;
    }
    interface IntegrationScheduledTriggerProperties {
        dataPullMode?: enums.customerprofiles.IntegrationScheduledTriggerPropertiesDataPullMode;
        firstExecutionFrom?: number;
        scheduleEndTime?: number;
        scheduleExpression: string;
        scheduleOffset?: number;
        scheduleStartTime?: number;
        timezone?: string;
    }
    interface IntegrationServiceNowSourceProperties {
        object: string;
    }
    interface IntegrationSourceConnectorProperties {
        marketo?: outputs.customerprofiles.IntegrationMarketoSourceProperties;
        s3?: outputs.customerprofiles.IntegrationS3SourceProperties;
        salesforce?: outputs.customerprofiles.IntegrationSalesforceSourceProperties;
        serviceNow?: outputs.customerprofiles.IntegrationServiceNowSourceProperties;
        zendesk?: outputs.customerprofiles.IntegrationZendeskSourceProperties;
    }
    interface IntegrationSourceFlowConfig {
        connectorProfileName?: string;
        connectorType: enums.customerprofiles.IntegrationConnectorType;
        incrementalPullConfig?: outputs.customerprofiles.IntegrationIncrementalPullConfig;
        sourceConnectorProperties: outputs.customerprofiles.IntegrationSourceConnectorProperties;
    }
    interface IntegrationTag {
        key: string;
        value: string;
    }
    interface IntegrationTask {
        connectorOperator?: outputs.customerprofiles.IntegrationConnectorOperator;
        destinationField?: string;
        sourceFields: string[];
        taskProperties?: outputs.customerprofiles.IntegrationTaskPropertiesMap[];
        taskType: enums.customerprofiles.IntegrationTaskType;
    }
    interface IntegrationTaskPropertiesMap {
        operatorPropertyKey: enums.customerprofiles.IntegrationOperatorPropertiesKeys;
        property: string;
    }
    interface IntegrationTriggerConfig {
        triggerProperties?: outputs.customerprofiles.IntegrationTriggerProperties;
        triggerType: enums.customerprofiles.IntegrationTriggerType;
    }
    interface IntegrationTriggerProperties {
        scheduled?: outputs.customerprofiles.IntegrationScheduledTriggerProperties;
    }
    interface IntegrationZendeskSourceProperties {
        object: string;
    }
    /**
     * Represents a field in a ProfileObjectType.
     */
    interface ObjectTypeField {
        /**
         * The content type of the field. Used for determining equality when searching.
         */
        contentType?: enums.customerprofiles.ObjectTypeFieldContentType;
        /**
         * A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
         */
        source?: string;
        /**
         * The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
         */
        target?: string;
    }
    interface ObjectTypeFieldMap {
        name?: string;
        objectTypeField?: outputs.customerprofiles.ObjectTypeField;
    }
    /**
     * An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
     */
    interface ObjectTypeKey {
        /**
         * The reference for the key name of the fields map.
         */
        fieldNames?: string[];
        /**
         * The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
         */
        standardIdentifiers?: enums.customerprofiles.ObjectTypeKeyStandardIdentifiersItem[];
    }
    interface ObjectTypeKeyMap {
        name?: string;
        objectTypeKeyList?: outputs.customerprofiles.ObjectTypeKey[];
    }
    interface ObjectTypeTag {
        key: string;
        value: string;
    }
}
export declare namespace databrew {
    /**
     * Csv options
     */
    interface DatasetCsvOptions {
        delimiter?: string;
        headerRow?: boolean;
    }
    interface DatasetDataCatalogInputDefinition {
        /**
         * Catalog id
         */
        catalogId?: string;
        /**
         * Database name
         */
        databaseName?: string;
        /**
         * Table name
         */
        tableName?: string;
        tempDirectory?: outputs.databrew.DatasetS3Location;
    }
    interface DatasetDatabaseInputDefinition {
        /**
         * Database table name
         */
        databaseTableName?: string;
        /**
         * Glue connection name
         */
        glueConnectionName: string;
        /**
         * Custom SQL to run against the provided AWS Glue connection. This SQL will be used as the input for DataBrew projects and jobs.
         */
        queryString?: string;
        tempDirectory?: outputs.databrew.DatasetS3Location;
    }
    interface DatasetDatetimeOptions {
        /**
         * Date/time format of a date parameter
         */
        format: string;
        /**
         * Locale code for a date parameter
         */
        localeCode?: string;
        /**
         * Timezone offset
         */
        timezoneOffset?: string;
    }
    interface DatasetExcelOptions {
        headerRow?: boolean;
        sheetIndexes?: number[];
        sheetNames?: string[];
    }
    interface DatasetFilesLimit {
        /**
         * Maximum number of files
         */
        maxFiles: number;
        /**
         * Order
         */
        order?: enums.databrew.DatasetFilesLimitOrder;
        /**
         * Ordered by
         */
        orderedBy?: enums.databrew.DatasetFilesLimitOrderedBy;
    }
    interface DatasetFilterExpression {
        /**
         * Filtering expression for a parameter
         */
        expression: string;
        valuesMap: outputs.databrew.DatasetFilterValue[];
    }
    /**
     * A key-value pair to associate expression variable names with their values
     */
    interface DatasetFilterValue {
        value: string;
        /**
         * Variable name
         */
        valueReference: string;
    }
    /**
     * Format options for dataset
     */
    interface DatasetFormatOptions {
        csv?: outputs.databrew.DatasetCsvOptions;
        excel?: outputs.databrew.DatasetExcelOptions;
        json?: outputs.databrew.DatasetJsonOptions;
    }
    /**
     * Input
     */
    interface DatasetInput {
        dataCatalogInputDefinition?: outputs.databrew.DatasetDataCatalogInputDefinition;
        databaseInputDefinition?: outputs.databrew.DatasetDatabaseInputDefinition;
        metadata?: outputs.databrew.DatasetMetadata;
        s3InputDefinition?: outputs.databrew.DatasetS3Location;
    }
    /**
     * Json options
     */
    interface DatasetJsonOptions {
        multiLine?: boolean;
    }
    interface DatasetMetadata {
        /**
         * Arn of the source of the dataset. For e.g.: AppFlow Flow ARN.
         */
        sourceArn?: string;
    }
    interface DatasetParameter {
        /**
         * Add the value of this parameter as a column in a dataset.
         */
        createColumn?: boolean;
        datetimeOptions?: outputs.databrew.DatasetDatetimeOptions;
        filter?: outputs.databrew.DatasetFilterExpression;
        name: string;
        /**
         * Parameter type
         */
        type: enums.databrew.DatasetParameterType;
    }
    /**
     * Path options for dataset
     */
    interface DatasetPathOptions {
        filesLimit?: outputs.databrew.DatasetFilesLimit;
        lastModifiedDateCondition?: outputs.databrew.DatasetFilterExpression;
        parameters?: outputs.databrew.DatasetPathParameter[];
    }
    /**
     * A key-value pair to associate dataset parameter name with its definition.
     */
    interface DatasetPathParameter {
        datasetParameter: outputs.databrew.DatasetParameter;
        pathParameterName: string;
    }
    /**
     * Input location
     */
    interface DatasetS3Location {
        bucket: string;
        key?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DatasetTag {
        key: string;
        value: string;
    }
    interface JobAllowedStatistics {
        statistics: string[];
    }
    interface JobColumnSelector {
        name?: string;
        regex?: string;
    }
    interface JobColumnStatisticsConfiguration {
        selectors?: outputs.databrew.JobColumnSelector[];
        statistics: outputs.databrew.JobStatisticsConfiguration;
    }
    /**
     * Output Csv options
     */
    interface JobCsvOutputOptions {
        delimiter?: string;
    }
    interface JobDataCatalogOutput {
        catalogId?: string;
        databaseName: string;
        databaseOptions?: outputs.databrew.JobDatabaseTableOutputOptions;
        overwrite?: boolean;
        s3Options?: outputs.databrew.JobS3TableOutputOptions;
        tableName: string;
    }
    interface JobDatabaseOutput {
        databaseOptions: outputs.databrew.JobDatabaseTableOutputOptions;
        /**
         * Database table name
         */
        databaseOutputMode?: enums.databrew.JobDatabaseOutputDatabaseOutputMode;
        /**
         * Glue connection name
         */
        glueConnectionName: string;
    }
    interface JobDatabaseTableOutputOptions {
        tableName: string;
        tempDirectory?: outputs.databrew.JobS3Location;
    }
    interface JobEntityDetectorConfiguration {
        allowedStatistics?: outputs.databrew.JobAllowedStatistics;
        entityTypes: string[];
    }
    interface JobOutput {
        compressionFormat?: enums.databrew.JobOutputCompressionFormat;
        format?: enums.databrew.JobOutputFormat;
        formatOptions?: outputs.databrew.JobOutputFormatOptions;
        location: outputs.databrew.JobS3Location;
        maxOutputFiles?: number;
        overwrite?: boolean;
        partitionColumns?: string[];
    }
    /**
     * Format options for job Output
     */
    interface JobOutputFormatOptions {
        csv?: outputs.databrew.JobCsvOutputOptions;
    }
    /**
     * Output location
     */
    interface JobOutputLocation {
        bucket: string;
        bucketOwner?: string;
        key?: string;
    }
    interface JobParameterMap {
    }
    interface JobProfileConfiguration {
        columnStatisticsConfigurations?: outputs.databrew.JobColumnStatisticsConfiguration[];
        datasetStatisticsConfiguration?: outputs.databrew.JobStatisticsConfiguration;
        entityDetectorConfiguration?: outputs.databrew.JobEntityDetectorConfiguration;
        profileColumns?: outputs.databrew.JobColumnSelector[];
    }
    interface JobRecipe {
        /**
         * Recipe name
         */
        name: string;
        /**
         * Recipe version
         */
        version?: string;
    }
    /**
     * S3 Output location
     */
    interface JobS3Location {
        bucket: string;
        bucketOwner?: string;
        key?: string;
    }
    interface JobS3TableOutputOptions {
        location: outputs.databrew.JobS3Location;
    }
    /**
     * Job Sample
     */
    interface JobSample {
        mode?: enums.databrew.JobSampleMode;
        size?: number;
    }
    interface JobStatisticOverride {
        parameters: outputs.databrew.JobParameterMap;
        statistic: string;
    }
    interface JobStatisticsConfiguration {
        includedStatistics?: string[];
        overrides?: outputs.databrew.JobStatisticOverride[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface JobTag {
        key: string;
        value: string;
    }
    /**
     * Configuration to attach Rulesets to the job
     */
    interface JobValidationConfiguration {
        /**
         * Arn of the Ruleset
         */
        rulesetArn: string;
        validationMode?: enums.databrew.JobValidationMode;
    }
    interface ProjectSample {
        /**
         * Sample size
         */
        size?: number;
        /**
         * Sample type
         */
        type: enums.databrew.ProjectSampleType;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ProjectTag {
        key: string;
        value: string;
    }
    interface RecipeAction {
        /**
         * Step action operation
         */
        operation: string;
        parameters?: outputs.databrew.RecipeParameters | outputs.databrew.RecipeParameterMap;
    }
    /**
     * Condition expressions applied to the step action
     */
    interface RecipeConditionExpression {
        /**
         * Input condition to be applied to the target column
         */
        condition: string;
        /**
         * Name of the target column
         */
        targetColumn: string;
        /**
         * Value of the condition
         */
        value?: string;
    }
    interface RecipeDataCatalogInputDefinition {
        /**
         * Catalog id
         */
        catalogId?: string;
        /**
         * Database name
         */
        databaseName?: string;
        /**
         * Table name
         */
        tableName?: string;
        tempDirectory?: outputs.databrew.RecipeS3Location;
    }
    interface RecipeParameterMap {
    }
    interface RecipeParameters {
        aggregateFunction?: string;
        base?: string;
        caseStatement?: string;
        categoryMap?: string;
        charsToRemove?: string;
        collapseConsecutiveWhitespace?: string;
        columnDataType?: string;
        columnRange?: string;
        count?: string;
        customCharacters?: string;
        customStopWords?: string;
        customValue?: string;
        datasetsColumns?: string;
        dateAddValue?: string;
        dateTimeFormat?: string;
        dateTimeParameters?: string;
        deleteOtherRows?: string;
        delimiter?: string;
        endPattern?: string;
        endPosition?: string;
        endValue?: string;
        expandContractions?: string;
        exponent?: string;
        falseString?: string;
        groupByAggFunctionOptions?: string;
        groupByColumns?: string;
        hiddenColumns?: string;
        ignoreCase?: string;
        includeInSplit?: string;
        /**
         * Input
         */
        input?: outputs.databrew.RecipeParametersInputProperties;
        interval?: string;
        isText?: string;
        joinKeys?: string;
        joinType?: string;
        leftColumns?: string;
        limit?: string;
        lowerBound?: string;
        mapType?: string;
        modeType?: string;
        multiLine?: boolean;
        numRows?: string;
        numRowsAfter?: string;
        numRowsBefore?: string;
        orderByColumn?: string;
        orderByColumns?: string;
        other?: string;
        pattern?: string;
        patternOption1?: string;
        patternOption2?: string;
        patternOptions?: string;
        period?: string;
        position?: string;
        removeAllPunctuation?: string;
        removeAllQuotes?: string;
        removeAllWhitespace?: string;
        removeCustomCharacters?: string;
        removeCustomValue?: string;
        removeLeadingAndTrailingPunctuation?: string;
        removeLeadingAndTrailingQuotes?: string;
        removeLeadingAndTrailingWhitespace?: string;
        removeLetters?: string;
        removeNumbers?: string;
        removeSourceColumn?: string;
        removeSpecialCharacters?: string;
        rightColumns?: string;
        sampleSize?: string;
        sampleType?: string;
        secondInput?: string;
        secondaryInputs?: outputs.databrew.RecipeSecondaryInput[];
        sheetIndexes?: number[];
        sheetNames?: string[];
        sourceColumn?: string;
        sourceColumn1?: string;
        sourceColumn2?: string;
        sourceColumns?: string;
        startColumnIndex?: string;
        startPattern?: string;
        startPosition?: string;
        startValue?: string;
        stemmingMode?: string;
        stepCount?: string;
        stepIndex?: string;
        stopWordsMode?: string;
        strategy?: string;
        targetColumn?: string;
        targetColumnNames?: string;
        targetDateFormat?: string;
        targetIndex?: string;
        timeZone?: string;
        tokenizerPattern?: string;
        trueString?: string;
        udfLang?: string;
        units?: string;
        unpivotColumn?: string;
        upperBound?: string;
        useNewDataFrame?: string;
        value?: string;
        value1?: string;
        value2?: string;
        valueColumn?: string;
        viewFrame?: string;
    }
    /**
     * Input
     */
    interface RecipeParametersInputProperties {
        dataCatalogInputDefinition?: outputs.databrew.RecipeDataCatalogInputDefinition;
        s3InputDefinition?: outputs.databrew.RecipeS3Location;
    }
    /**
     * Input location
     */
    interface RecipeS3Location {
        bucket: string;
        key?: string;
    }
    /**
     * Secondary input
     */
    interface RecipeSecondaryInput {
        dataCatalogInputDefinition?: outputs.databrew.RecipeDataCatalogInputDefinition;
        s3InputDefinition?: outputs.databrew.RecipeS3Location;
    }
    interface RecipeStep {
        action: outputs.databrew.RecipeAction;
        /**
         * Condition expressions applied to the step action
         */
        conditionExpressions?: outputs.databrew.RecipeConditionExpression[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface RecipeTag {
        key: string;
        value: string;
    }
    /**
     * Selector of a column from a dataset for profile job configuration. One selector includes either a column name or a regular expression
     */
    interface RulesetColumnSelector {
        /**
         * The name of a column from a dataset
         */
        name?: string;
        /**
         * A regular expression for selecting a column from a dataset
         */
        regex?: string;
    }
    /**
     * Data quality rule for a target resource (dataset)
     */
    interface RulesetRule {
        checkExpression: string;
        columnSelectors?: outputs.databrew.RulesetColumnSelector[];
        disabled?: boolean;
        /**
         * Name of the rule
         */
        name: string;
        substitutionMap?: outputs.databrew.RulesetSubstitutionValue[];
        threshold?: outputs.databrew.RulesetThreshold;
    }
    /**
     * A key-value pair to associate expression's substitution variable names with their values
     */
    interface RulesetSubstitutionValue {
        /**
         * Value or column name
         */
        value: string;
        /**
         * Variable name
         */
        valueReference: string;
    }
    /**
     * A key-value pair to associate with a resource
     */
    interface RulesetTag {
        key: string;
        value: string;
    }
    interface RulesetThreshold {
        type?: enums.databrew.RulesetThresholdType;
        unit?: enums.databrew.RulesetThresholdUnit;
        value: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ScheduleTag {
        key: string;
        value: string;
    }
}
export declare namespace datapipeline {
    interface PipelineField {
        /**
         * Specifies the name of a field for a particular object. To view valid values for a particular field, see Pipeline Object Reference in the AWS Data Pipeline Developer Guide.
         */
        key: string;
        /**
         * A field value that you specify as an identifier of another object in the same pipeline definition.
         */
        refValue?: string;
        /**
         * A field value that you specify as a string. To view valid values for a particular field, see Pipeline Object Reference in the AWS Data Pipeline Developer Guide.
         */
        stringValue?: string;
    }
    interface PipelineObject {
        /**
         * Key-value pairs that define the properties of the object.
         */
        fields: outputs.datapipeline.PipelineField[];
        /**
         * The ID of the object.
         */
        id: string;
        /**
         * The name of the object.
         */
        name: string;
    }
    interface PipelineParameterAttribute {
        /**
         * The field identifier.
         */
        key: string;
        /**
         * The field value, expressed as a String.
         */
        stringValue: string;
    }
    interface PipelineParameterObject {
        /**
         * The attributes of the parameter object.
         */
        attributes: outputs.datapipeline.PipelineParameterAttribute[];
        /**
         * The ID of the parameter object.
         */
        id: string;
    }
    interface PipelineParameterValue {
        /**
         * The ID of the parameter value.
         */
        id: string;
        /**
         * The field value, expressed as a String.
         */
        stringValue: string;
    }
    interface PipelineTag {
        /**
         * The key name of a tag.
         */
        key: string;
        /**
         * The value to associate with the key name.
         */
        value: string;
    }
}
export declare namespace datasync {
    /**
     * A key-value pair to associate with a resource.
     */
    interface AgentTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * The subnet and security group that DataSync uses to access target EFS file system.
     */
    interface LocationEFSEc2Config {
        /**
         * The Amazon Resource Names (ARNs) of the security groups that are configured for the Amazon EC2 resource.
         */
        securityGroupArns: string[];
        /**
         * The ARN of the subnet that DataSync uses to access the target EFS file system.
         */
        subnetArn: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationEFSTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationFSxLustreTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * NFS protocol configuration for FSx ONTAP file system.
     */
    interface LocationFSxONTAPNFS {
        mountOptions: outputs.datasync.LocationFSxONTAPNfsMountOptions;
    }
    /**
     * The NFS mount options that DataSync can use to mount your NFS share.
     */
    interface LocationFSxONTAPNfsMountOptions {
        /**
         * The specific NFS version that you want DataSync to use to mount your NFS share.
         */
        version?: enums.datasync.LocationFSxONTAPNfsMountOptionsVersion;
    }
    /**
     * Configuration settings for NFS or SMB protocol.
     */
    interface LocationFSxONTAPProtocol {
        nFS?: outputs.datasync.LocationFSxONTAPNFS;
        sMB?: outputs.datasync.LocationFSxONTAPSMB;
    }
    /**
     * SMB protocol configuration for FSx ONTAP file system.
     */
    interface LocationFSxONTAPSMB {
        /**
         * The name of the Windows domain that the SMB server belongs to.
         */
        domain?: string;
        mountOptions: outputs.datasync.LocationFSxONTAPSmbMountOptions;
        /**
         * The password of the user who can mount the share and has the permissions to access files and folders in the SMB share.
         */
        password: string;
        /**
         * The user who can mount the share, has the permissions to access files and folders in the SMB share.
         */
        user: string;
    }
    /**
     * The mount options used by DataSync to access the SMB server.
     */
    interface LocationFSxONTAPSmbMountOptions {
        /**
         * The specific SMB version that you want DataSync to use to mount your SMB share.
         */
        version?: enums.datasync.LocationFSxONTAPSmbMountOptionsVersion;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationFSxONTAPTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * The NFS mount options that DataSync can use to mount your NFS share.
     */
    interface LocationFSxOpenZFSMountOptions {
        /**
         * The specific NFS version that you want DataSync to use to mount your NFS share.
         */
        version?: enums.datasync.LocationFSxOpenZFSMountOptionsVersion;
    }
    /**
     * FSx OpenZFS file system NFS protocol information
     */
    interface LocationFSxOpenZFSNFS {
        mountOptions: outputs.datasync.LocationFSxOpenZFSMountOptions;
    }
    /**
     * Configuration settings for an NFS or SMB protocol, currently only support NFS
     */
    interface LocationFSxOpenZFSProtocol {
        nFS?: outputs.datasync.LocationFSxOpenZFSNFS;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationFSxOpenZFSTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationFSxWindowsTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * HDFS Name Node IP and port information.
     */
    interface LocationHDFSNameNode {
        /**
         * The DNS name or IP address of the Name Node in the customer's on premises HDFS cluster.
         */
        hostname: string;
        /**
         * The port on which the Name Node is listening on for client requests.
         */
        port: number;
    }
    /**
     * Configuration information for RPC Protection and Data Transfer Protection. These parameters can be set to AUTHENTICATION, INTEGRITY, or PRIVACY. The default value is PRIVACY.
     */
    interface LocationHDFSQopConfiguration {
        /**
         * Configuration for Data Transfer Protection.
         */
        dataTransferProtection?: enums.datasync.LocationHDFSQopConfigurationDataTransferProtection;
        /**
         * Configuration for RPC Protection.
         */
        rpcProtection?: enums.datasync.LocationHDFSQopConfigurationRpcProtection;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationHDFSTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The NFS mount options that DataSync can use to mount your NFS share.
     */
    interface LocationNFSMountOptions {
        /**
         * The specific NFS version that you want DataSync to use to mount your NFS share.
         */
        version?: enums.datasync.LocationNFSMountOptionsVersion;
    }
    /**
     * Contains a list of Amazon Resource Names (ARNs) of agents that are used to connect an NFS server.
     */
    interface LocationNFSOnPremConfig {
        /**
         * ARN(s) of the agent(s) to use for an NFS location.
         */
        agentArns: string[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationNFSTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationObjectStorageTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * The Amazon Resource Name (ARN) of the AWS IAM role that is used to access an Amazon S3 bucket.
     */
    interface LocationS3S3Config {
        /**
         * The ARN of the IAM role of the Amazon S3 bucket.
         */
        bucketAccessRoleArn: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationS3Tag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * The mount options used by DataSync to access the SMB server.
     */
    interface LocationSMBMountOptions {
        /**
         * The specific SMB version that you want DataSync to use to mount your SMB share.
         */
        version?: enums.datasync.LocationSMBMountOptionsVersion;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LocationSMBTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
    /**
     * Specifies which files folders and objects to include or exclude when transferring files from source to destination.
     */
    interface TaskFilterRule {
        /**
         * The type of filter rule to apply. AWS DataSync only supports the SIMPLE_PATTERN rule type.
         */
        filterType?: enums.datasync.TaskFilterRuleFilterType;
        /**
         * A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|".
         */
        value?: string;
    }
    /**
     * Represents the options that are available to control the behavior of a StartTaskExecution operation.
     */
    interface TaskOptions {
        /**
         * A file metadata value that shows the last time a file was accessed (that is, when the file was read or written to).
         */
        atime?: enums.datasync.TaskOptionsAtime;
        /**
         * A value that limits the bandwidth used by AWS DataSync.
         */
        bytesPerSecond?: number;
        /**
         * The group ID (GID) of the file's owners.
         */
        gid?: enums.datasync.TaskOptionsGid;
        /**
         * A value that determines the types of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide.
         */
        logLevel?: enums.datasync.TaskOptionsLogLevel;
        /**
         * A value that indicates the last time that a file was modified (that is, a file was written to) before the PREPARING phase.
         */
        mtime?: enums.datasync.TaskOptionsMtime;
        /**
         * A value that determines whether object tags should be read from the source object store and written to the destination object store.
         */
        objectTags?: enums.datasync.TaskOptionsObjectTags;
        /**
         * A value that determines whether files at the destination should be overwritten or preserved when copying files.
         */
        overwriteMode?: enums.datasync.TaskOptionsOverwriteMode;
        /**
         * A value that determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.
         */
        posixPermissions?: enums.datasync.TaskOptionsPosixPermissions;
        /**
         * A value that specifies whether files in the destination that don't exist in the source file system should be preserved.
         */
        preserveDeletedFiles?: enums.datasync.TaskOptionsPreserveDeletedFiles;
        /**
         * A value that determines whether AWS DataSync should preserve the metadata of block and character devices in the source file system, and recreate the files with that device name and metadata on the destination.
         */
        preserveDevices?: enums.datasync.TaskOptionsPreserveDevices;
        /**
         * A value that determines which components of the SMB security descriptor are copied during transfer.
         */
        securityDescriptorCopyFlags?: enums.datasync.TaskOptionsSecurityDescriptorCopyFlags;
        /**
         * A value that determines whether tasks should be queued before executing the tasks.
         */
        taskQueueing?: enums.datasync.TaskOptionsTaskQueueing;
        /**
         * A value that determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location.
         */
        transferMode?: enums.datasync.TaskOptionsTransferMode;
        /**
         * The user ID (UID) of the file's owner.
         */
        uid?: enums.datasync.TaskOptionsUid;
        /**
         * A value that determines whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred.
         */
        verifyMode?: enums.datasync.TaskOptionsVerifyMode;
    }
    /**
     * Specifies the schedule you want your task to use for repeated executions.
     */
    interface TaskSchedule {
        /**
         * A cron expression that specifies when AWS DataSync initiates a scheduled transfer from a source to a destination location
         */
        scheduleExpression: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface TaskTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }
}
export declare namespace dax {
    interface ClusterSSESpecification {
        sSEEnabled?: boolean;
    }
}
export declare namespace detective {
    /**
     * A key-value pair to associate with a resource.
     */
    interface GraphTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. Valid characters are Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @
         */
        key?: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. Valid characters are Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @
         */
        value?: string;
    }
}
export declare namespace devicefarm {
    /**
     * Represents a condition for a device pool.
     */
    interface DevicePoolRule {
        /**
         * The rule's stringified attribute.
         */
        attribute?: enums.devicefarm.DevicePoolRuleAttribute;
        /**
         * Specifies how Device Farm compares the rule's attribute to the value.
         */
        operator?: enums.devicefarm.DevicePoolRuleOperator;
        /**
         * The rule's value.
         */
        value?: string;
    }
    interface DevicePoolTag {
        key: string;
        value: string;
    }
    interface InstanceProfileTag {
        key: string;
        value: string;
    }
    interface NetworkProfileTag {
        key: string;
        value: string;
    }
    interface ProjectTag {
        key: string;
        value: string;
    }
    interface TestGridProjectTag {
        key: string;
        value: string;
    }
    /**
     * The VPC security groups and subnets that are attached to a TestGrid project.
     */
    interface TestGridProjectVpcConfig {
        /**
         * A list of VPC security group IDs in your Amazon VPC.
         */
        securityGroupIds: string[];
        /**
         * A list of VPC subnet IDs in your Amazon VPC.
         */
        subnetIds: string[];
        vpcId: string;
    }
    interface VPCEConfigurationTag {
        key: string;
        value: string;
    }
}
export declare namespace devopsguru {
    /**
     * Information about notification channels you have configured with DevOps Guru.
     */
    interface NotificationChannelConfig {
        filters?: outputs.devopsguru.NotificationChannelNotificationFilterConfig;
        sns?: outputs.devopsguru.NotificationChannelSnsChannelConfig;
    }
    /**
     * Information about filters of a notification channel configured in DevOpsGuru to filter for insights.
     */
    interface NotificationChannelNotificationFilterConfig {
        messageTypes?: enums.devopsguru.NotificationChannelNotificationMessageType[];
        severities?: enums.devopsguru.NotificationChannelInsightSeverity[];
    }
    /**
     * Information about a notification channel configured in DevOps Guru to send notifications when insights are created.
     */
    interface NotificationChannelSnsChannelConfig {
        topicArn?: string;
    }
    /**
     * CloudFormation resource for DevOps Guru to monitor
     */
    interface ResourceCollectionCloudFormationCollectionFilter {
        /**
         * An array of CloudFormation stack names.
         */
        stackNames?: string[];
    }
    /**
     * Information about a filter used to specify which AWS resources are analyzed for anomalous behavior by DevOps Guru.
     */
    interface ResourceCollectionFilter {
        cloudFormation?: outputs.devopsguru.ResourceCollectionCloudFormationCollectionFilter;
        tags?: outputs.devopsguru.ResourceCollectionTagCollection[];
    }
    /**
     * Tagged resource for DevOps Guru to monitor
     */
    interface ResourceCollectionTagCollection {
        /**
         * A Tag key for DevOps Guru app boundary.
         */
        appBoundaryKey?: string;
        /**
         * Tag values of DevOps Guru app boundary.
         */
        tagValues?: string[];
    }
}
export declare namespace directoryservice {
    interface MicrosoftADVpcSettings {
        subnetIds: string[];
        vpcId: string;
    }
    interface SimpleADVpcSettings {
        subnetIds: string[];
        vpcId: string;
    }
}
export declare namespace dlm {
    interface LifecyclePolicyAction {
        crossRegionCopy: outputs.dlm.LifecyclePolicyCrossRegionCopyAction[];
        name: string;
    }
    interface LifecyclePolicyArchiveRetainRule {
        retentionArchiveTier: outputs.dlm.LifecyclePolicyRetentionArchiveTier;
    }
    interface LifecyclePolicyArchiveRule {
        retainRule: outputs.dlm.LifecyclePolicyArchiveRetainRule;
    }
    interface LifecyclePolicyCreateRule {
        cronExpression?: string;
        interval?: number;
        intervalUnit?: string;
        location?: string;
        times?: string[];
    }
    interface LifecyclePolicyCrossRegionCopyAction {
        encryptionConfiguration: outputs.dlm.LifecyclePolicyEncryptionConfiguration;
        retainRule?: outputs.dlm.LifecyclePolicyCrossRegionCopyRetainRule;
        target: string;
    }
    interface LifecyclePolicyCrossRegionCopyDeprecateRule {
        interval: number;
        intervalUnit: string;
    }
    interface LifecyclePolicyCrossRegionCopyRetainRule {
        interval: number;
        intervalUnit: string;
    }
    interface LifecyclePolicyCrossRegionCopyRule {
        cmkArn?: string;
        copyTags?: boolean;
        deprecateRule?: outputs.dlm.LifecyclePolicyCrossRegionCopyDeprecateRule;
        encrypted: boolean;
        retainRule?: outputs.dlm.LifecyclePolicyCrossRegionCopyRetainRule;
        target?: string;
        targetRegion?: string;
    }
    interface LifecyclePolicyDeprecateRule {
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }
    interface LifecyclePolicyEncryptionConfiguration {
        cmkArn?: string;
        encrypted: boolean;
    }
    interface LifecyclePolicyEventParameters {
        descriptionRegex?: string;
        eventType: string;
        snapshotOwner: string[];
    }
    interface LifecyclePolicyEventSource {
        parameters?: outputs.dlm.LifecyclePolicyEventParameters;
        type: string;
    }
    interface LifecyclePolicyFastRestoreRule {
        availabilityZones?: string[];
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }
    interface LifecyclePolicyParameters {
        excludeBootVolume?: boolean;
        excludeDataVolumeTags?: outputs.dlm.LifecyclePolicyTag[];
        noReboot?: boolean;
    }
    interface LifecyclePolicyPolicyDetails {
        actions?: outputs.dlm.LifecyclePolicyAction[];
        eventSource?: outputs.dlm.LifecyclePolicyEventSource;
        parameters?: outputs.dlm.LifecyclePolicyParameters;
        policyType?: string;
        resourceLocations?: string[];
        resourceTypes?: string[];
        schedules?: outputs.dlm.LifecyclePolicySchedule[];
        targetTags?: outputs.dlm.LifecyclePolicyTag[];
    }
    interface LifecyclePolicyRetainRule {
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }
    interface LifecyclePolicyRetentionArchiveTier {
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }
    interface LifecyclePolicySchedule {
        archiveRule?: outputs.dlm.LifecyclePolicyArchiveRule;
        copyTags?: boolean;
        createRule?: outputs.dlm.LifecyclePolicyCreateRule;
        crossRegionCopyRules?: outputs.dlm.LifecyclePolicyCrossRegionCopyRule[];
        deprecateRule?: outputs.dlm.LifecyclePolicyDeprecateRule;
        fastRestoreRule?: outputs.dlm.LifecyclePolicyFastRestoreRule;
        name?: string;
        retainRule?: outputs.dlm.LifecyclePolicyRetainRule;
        shareRules?: outputs.dlm.LifecyclePolicyShareRule[];
        tagsToAdd?: outputs.dlm.LifecyclePolicyTag[];
        variableTags?: outputs.dlm.LifecyclePolicyTag[];
    }
    interface LifecyclePolicyShareRule {
        targetAccounts?: string[];
        unshareInterval?: number;
        unshareIntervalUnit?: string;
    }
    interface LifecyclePolicyTag {
        key: string;
        value: string;
    }
}
export declare namespace dms {
    interface EndpointDocDbSettings {
        docsToInvestigate?: number;
        extractDocId?: boolean;
        nestingLevel?: string;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }
    interface EndpointDynamoDbSettings {
        serviceAccessRoleArn?: string;
    }
    interface EndpointElasticsearchSettings {
        endpointUri?: string;
        errorRetryDuration?: number;
        fullLoadErrorPercentage?: number;
        serviceAccessRoleArn?: string;
    }
    interface EndpointGcpMySQLSettings {
        afterConnectScript?: string;
        cleanSourceMetadataOnMismatch?: boolean;
        databaseName?: string;
        eventsPollInterval?: number;
        maxFileSize?: number;
        parallelLoadThreads?: number;
        password?: string;
        port?: number;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        serverName?: string;
        serverTimezone?: string;
        username?: string;
    }
    interface EndpointIbmDb2Settings {
        currentLsn?: string;
        maxKBytesPerRead?: number;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        setDataCaptureChanges?: boolean;
    }
    interface EndpointKafkaSettings {
        broker?: string;
        includeControlDetails?: boolean;
        includeNullAndEmpty?: boolean;
        includePartitionValue?: boolean;
        includeTableAlterOperations?: boolean;
        includeTransactionDetails?: boolean;
        messageFormat?: string;
        messageMaxBytes?: number;
        noHexPrefix?: boolean;
        partitionIncludeSchemaTable?: boolean;
        saslPassword?: string;
        saslUserName?: string;
        securityProtocol?: string;
        sslCaCertificateArn?: string;
        sslClientCertificateArn?: string;
        sslClientKeyArn?: string;
        sslClientKeyPassword?: string;
        topic?: string;
    }
    interface EndpointKinesisSettings {
        includeControlDetails?: boolean;
        includeNullAndEmpty?: boolean;
        includePartitionValue?: boolean;
        includeTableAlterOperations?: boolean;
        includeTransactionDetails?: boolean;
        messageFormat?: string;
        noHexPrefix?: boolean;
        partitionIncludeSchemaTable?: boolean;
        serviceAccessRoleArn?: string;
        streamArn?: string;
    }
    interface EndpointMicrosoftSqlServerSettings {
        bcpPacketSize?: number;
        controlTablesFileGroup?: string;
        querySingleAlwaysOnNode?: boolean;
        readBackupOnly?: boolean;
        safeguardPolicy?: string;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        useBcpFullLoad?: boolean;
        useThirdPartyBackupDevice?: boolean;
    }
    interface EndpointMongoDbSettings {
        authMechanism?: string;
        authSource?: string;
        authType?: string;
        databaseName?: string;
        docsToInvestigate?: string;
        extractDocId?: string;
        nestingLevel?: string;
        password?: string;
        port?: number;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        serverName?: string;
        username?: string;
    }
    interface EndpointMySqlSettings {
        afterConnectScript?: string;
        cleanSourceMetadataOnMismatch?: boolean;
        eventsPollInterval?: number;
        maxFileSize?: number;
        parallelLoadThreads?: number;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        serverTimezone?: string;
        targetDbType?: string;
    }
    interface EndpointNeptuneSettings {
        errorRetryDuration?: number;
        iamAuthEnabled?: boolean;
        maxFileSize?: number;
        maxRetryCount?: number;
        s3BucketFolder?: string;
        s3BucketName?: string;
        serviceAccessRoleArn?: string;
    }
    interface EndpointOracleSettings {
        accessAlternateDirectly?: boolean;
        addSupplementalLogging?: boolean;
        additionalArchivedLogDestId?: number;
        allowSelectNestedTables?: boolean;
        archivedLogDestId?: number;
        archivedLogsOnly?: boolean;
        asmPassword?: string;
        asmServer?: string;
        asmUser?: string;
        charLengthSemantics?: string;
        directPathNoLog?: boolean;
        directPathParallelLoad?: boolean;
        enableHomogenousTablespace?: boolean;
        extraArchivedLogDestIds?: number[];
        failTasksOnLobTruncation?: boolean;
        numberDatatypeScale?: number;
        oraclePathPrefix?: string;
        parallelAsmReadThreads?: number;
        readAheadBlocks?: number;
        readTableSpaceName?: boolean;
        replacePathPrefix?: boolean;
        retryInterval?: number;
        secretsManagerAccessRoleArn?: string;
        secretsManagerOracleAsmAccessRoleArn?: string;
        secretsManagerOracleAsmSecretId?: string;
        secretsManagerSecretId?: string;
        securityDbEncryption?: string;
        securityDbEncryptionName?: string;
        spatialDataOptionToGeoJsonFunctionName?: string;
        standbyDelayTime?: number;
        useAlternateFolderForOnline?: boolean;
        useBFile?: boolean;
        useDirectPathFullLoad?: boolean;
        useLogminerReader?: boolean;
        usePathPrefix?: string;
    }
    interface EndpointPostgreSqlSettings {
        afterConnectScript?: string;
        captureDdls?: boolean;
        ddlArtifactsSchema?: string;
        executeTimeout?: number;
        failTasksOnLobTruncation?: boolean;
        heartbeatEnable?: boolean;
        heartbeatFrequency?: number;
        heartbeatSchema?: string;
        maxFileSize?: number;
        pluginName?: string;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        slotName?: string;
    }
    interface EndpointRedisSettings {
        authPassword?: string;
        authType?: string;
        authUserName?: string;
        port?: number;
        serverName?: string;
        sslCaCertificateArn?: string;
        sslSecurityProtocol?: string;
    }
    interface EndpointRedshiftSettings {
        acceptAnyDate?: boolean;
        afterConnectScript?: string;
        bucketFolder?: string;
        bucketName?: string;
        caseSensitiveNames?: boolean;
        compUpdate?: boolean;
        connectionTimeout?: number;
        dateFormat?: string;
        emptyAsNull?: boolean;
        encryptionMode?: string;
        explicitIds?: boolean;
        fileTransferUploadStreams?: number;
        loadTimeout?: number;
        maxFileSize?: number;
        removeQuotes?: boolean;
        replaceChars?: string;
        replaceInvalidChars?: string;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        serverSideEncryptionKmsKeyId?: string;
        serviceAccessRoleArn?: string;
        timeFormat?: string;
        trimBlanks?: boolean;
        truncateColumns?: boolean;
        writeBufferSize?: number;
    }
    interface EndpointS3Settings {
        addColumnName?: boolean;
        bucketFolder?: string;
        bucketName?: string;
        cannedAclForObjects?: string;
        cdcInsertsAndUpdates?: boolean;
        cdcInsertsOnly?: boolean;
        cdcMaxBatchInterval?: number;
        cdcMinFileSize?: number;
        cdcPath?: string;
        compressionType?: string;
        csvDelimiter?: string;
        csvNoSupValue?: string;
        csvNullValue?: string;
        csvRowDelimiter?: string;
        dataFormat?: string;
        dataPageSize?: number;
        datePartitionDelimiter?: string;
        datePartitionEnabled?: boolean;
        datePartitionSequence?: string;
        datePartitionTimezone?: string;
        dictPageSizeLimit?: number;
        enableStatistics?: boolean;
        encodingType?: string;
        encryptionMode?: string;
        externalTableDefinition?: string;
        ignoreHeaderRows?: number;
        includeOpForFullLoad?: boolean;
        maxFileSize?: number;
        parquetTimestampInMillisecond?: boolean;
        parquetVersion?: string;
        preserveTransactions?: boolean;
        rfc4180?: boolean;
        rowGroupLength?: number;
        serverSideEncryptionKmsKeyId?: string;
        serviceAccessRoleArn?: string;
        timestampColumnName?: string;
        useCsvNoSupValue?: boolean;
        useTaskStartTimeForFullLoadTimestamp?: boolean;
    }
    interface EndpointSybaseSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }
    interface EndpointTag {
        key: string;
        value: string;
    }
    interface EventSubscriptionTag {
        key: string;
        value: string;
    }
    interface ReplicationInstanceTag {
        key: string;
        value: string;
    }
    interface ReplicationSubnetGroupTag {
        key: string;
        value: string;
    }
    interface ReplicationTaskTag {
        key: string;
        value: string;
    }
}
export declare namespace docdb {
    interface DBClusterParameterGroupTag {
        key: string;
        value: string;
    }
    interface DBClusterTag {
        key: string;
        value: string;
    }
    interface DBInstanceTag {
        key: string;
        value: string;
    }
    interface DBSubnetGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace dynamodb {
    interface GlobalTableAttributeDefinition {
        attributeName: string;
        attributeType: string;
    }
    interface GlobalTableCapacityAutoScalingSettings {
        maxCapacity: number;
        minCapacity: number;
        seedCapacity?: number;
        targetTrackingScalingPolicyConfiguration: outputs.dynamodb.GlobalTableTargetTrackingScalingPolicyConfiguration;
    }
    interface GlobalTableContributorInsightsSpecification {
        enabled: boolean;
    }
    interface GlobalTableGlobalSecondaryIndex {
        indexName: string;
        keySchema: outputs.dynamodb.GlobalTableKeySchema[];
        projection: outputs.dynamodb.GlobalTableProjection;
        writeProvisionedThroughputSettings?: outputs.dynamodb.GlobalTableWriteProvisionedThroughputSettings;
    }
    interface GlobalTableKeySchema {
        attributeName: string;
        keyType: string;
    }
    interface GlobalTableLocalSecondaryIndex {
        indexName: string;
        keySchema: outputs.dynamodb.GlobalTableKeySchema[];
        projection: outputs.dynamodb.GlobalTableProjection;
    }
    interface GlobalTablePointInTimeRecoverySpecification {
        pointInTimeRecoveryEnabled?: boolean;
    }
    interface GlobalTableProjection {
        nonKeyAttributes?: string[];
        projectionType?: string;
    }
    interface GlobalTableReadProvisionedThroughputSettings {
        readCapacityAutoScalingSettings?: outputs.dynamodb.GlobalTableCapacityAutoScalingSettings;
        readCapacityUnits?: number;
    }
    interface GlobalTableReplicaGlobalSecondaryIndexSpecification {
        contributorInsightsSpecification?: outputs.dynamodb.GlobalTableContributorInsightsSpecification;
        indexName: string;
        readProvisionedThroughputSettings?: outputs.dynamodb.GlobalTableReadProvisionedThroughputSettings;
    }
    interface GlobalTableReplicaSSESpecification {
        kMSMasterKeyId: string;
    }
    interface GlobalTableReplicaSpecification {
        contributorInsightsSpecification?: outputs.dynamodb.GlobalTableContributorInsightsSpecification;
        globalSecondaryIndexes?: outputs.dynamodb.GlobalTableReplicaGlobalSecondaryIndexSpecification[];
        pointInTimeRecoverySpecification?: outputs.dynamodb.GlobalTablePointInTimeRecoverySpecification;
        readProvisionedThroughputSettings?: outputs.dynamodb.GlobalTableReadProvisionedThroughputSettings;
        region: string;
        sSESpecification?: outputs.dynamodb.GlobalTableReplicaSSESpecification;
        tableClass?: string;
        tags?: outputs.dynamodb.GlobalTableTag[];
    }
    interface GlobalTableSSESpecification {
        sSEEnabled: boolean;
        sSEType?: string;
    }
    interface GlobalTableStreamSpecification {
        streamViewType: string;
    }
    interface GlobalTableTag {
        key: string;
        value: string;
    }
    interface GlobalTableTargetTrackingScalingPolicyConfiguration {
        disableScaleIn?: boolean;
        scaleInCooldown?: number;
        scaleOutCooldown?: number;
        targetValue: number;
    }
    interface GlobalTableTimeToLiveSpecification {
        attributeName?: string;
        enabled: boolean;
    }
    interface GlobalTableWriteProvisionedThroughputSettings {
        writeCapacityAutoScalingSettings?: outputs.dynamodb.GlobalTableCapacityAutoScalingSettings;
    }
    interface TableAttributeDefinition {
        attributeName: string;
        attributeType: string;
    }
    interface TableContributorInsightsSpecification {
        enabled: boolean;
    }
    interface TableCsv {
        delimiter?: string;
        headerList?: string[];
    }
    interface TableGlobalSecondaryIndex {
        contributorInsightsSpecification?: outputs.dynamodb.TableContributorInsightsSpecification;
        indexName: string;
        keySchema: outputs.dynamodb.TableKeySchema[];
        projection: outputs.dynamodb.TableProjection;
        provisionedThroughput?: outputs.dynamodb.TableProvisionedThroughput;
    }
    interface TableImportSourceSpecification {
        inputCompressionType?: string;
        inputFormat: string;
        inputFormatOptions?: outputs.dynamodb.TableInputFormatOptions;
        s3BucketSource: outputs.dynamodb.TableS3BucketSource;
    }
    interface TableInputFormatOptions {
        csv?: outputs.dynamodb.TableCsv;
    }
    interface TableKeySchema {
        attributeName: string;
        keyType: string;
    }
    interface TableKinesisStreamSpecification {
        streamArn: string;
    }
    interface TableLocalSecondaryIndex {
        indexName: string;
        keySchema: outputs.dynamodb.TableKeySchema[];
        projection: outputs.dynamodb.TableProjection;
    }
    interface TablePointInTimeRecoverySpecification {
        pointInTimeRecoveryEnabled?: boolean;
    }
    interface TableProjection {
        nonKeyAttributes?: string[];
        projectionType?: string;
    }
    interface TableProvisionedThroughput {
        readCapacityUnits: number;
        writeCapacityUnits: number;
    }
    interface TableS3BucketSource {
        s3Bucket: string;
        s3BucketOwner?: string;
        s3KeyPrefix?: string;
    }
    interface TableSSESpecification {
        kMSMasterKeyId?: string;
        sSEEnabled: boolean;
        sSEType?: string;
    }
    interface TableStreamSpecification {
        streamViewType: string;
    }
    interface TableTag {
        key: string;
        value: string;
    }
    interface TableTimeToLiveSpecification {
        attributeName: string;
        enabled: boolean;
    }
}
export declare namespace ec2 {
    interface CapacityReservationFleetInstanceTypeSpecification {
        availabilityZone?: string;
        availabilityZoneId?: string;
        ebsOptimized?: boolean;
        instancePlatform?: string;
        instanceType?: string;
        priority?: number;
        weight?: number;
    }
    interface CapacityReservationFleetTag {
        key: string;
        value: string;
    }
    interface CapacityReservationFleetTagSpecification {
        resourceType?: string;
        tags?: outputs.ec2.CapacityReservationFleetTag[];
    }
    interface CapacityReservationTag {
        key: string;
        value: string;
    }
    interface CapacityReservationTagSpecification {
        resourceType?: string;
        tags?: outputs.ec2.CapacityReservationTag[];
    }
    interface CarrierGatewayTag {
        key?: string;
        value?: string;
    }
    interface ClientVpnEndpointCertificateAuthenticationRequest {
        clientRootCertificateChainArn: string;
    }
    interface ClientVpnEndpointClientAuthenticationRequest {
        activeDirectory?: outputs.ec2.ClientVpnEndpointDirectoryServiceAuthenticationRequest;
        federatedAuthentication?: outputs.ec2.ClientVpnEndpointFederatedAuthenticationRequest;
        mutualAuthentication?: outputs.ec2.ClientVpnEndpointCertificateAuthenticationRequest;
        type: string;
    }
    interface ClientVpnEndpointClientConnectOptions {
        enabled: boolean;
        lambdaFunctionArn?: string;
    }
    interface ClientVpnEndpointClientLoginBannerOptions {
        bannerText?: string;
        enabled: boolean;
    }
    interface ClientVpnEndpointConnectionLogOptions {
        cloudwatchLogGroup?: string;
        cloudwatchLogStream?: string;
        enabled: boolean;
    }
    interface ClientVpnEndpointDirectoryServiceAuthenticationRequest {
        directoryId: string;
    }
    interface ClientVpnEndpointFederatedAuthenticationRequest {
        sAMLProviderArn: string;
        selfServiceSAMLProviderArn?: string;
    }
    interface ClientVpnEndpointTag {
        key: string;
        value: string;
    }
    interface ClientVpnEndpointTagSpecification {
        resourceType: string;
        tags: outputs.ec2.ClientVpnEndpointTag[];
    }
    interface CustomerGatewayTag {
        key: string;
        value: string;
    }
    interface DHCPOptionsTag {
        key: string;
        value: string;
    }
    interface DestinationOptionsProperties {
        fileFormat: enums.ec2.FlowLogDestinationOptionsPropertiesFileFormat;
        hiveCompatiblePartitions: boolean;
        perHourPartition: boolean;
    }
    interface EC2FleetAcceleratorCountRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetAcceleratorTotalMemoryMiBRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetBaselineEbsBandwidthMbpsRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetCapacityRebalance {
        replacementStrategy?: enums.ec2.EC2FleetCapacityRebalanceReplacementStrategy;
        terminationDelay?: number;
    }
    interface EC2FleetCapacityReservationOptionsRequest {
        usageStrategy?: enums.ec2.EC2FleetCapacityReservationOptionsRequestUsageStrategy;
    }
    interface EC2FleetFleetLaunchTemplateConfigRequest {
        launchTemplateSpecification?: outputs.ec2.EC2FleetFleetLaunchTemplateSpecificationRequest;
        overrides?: outputs.ec2.EC2FleetFleetLaunchTemplateOverridesRequest[];
    }
    interface EC2FleetFleetLaunchTemplateOverridesRequest {
        availabilityZone?: string;
        instanceRequirements?: outputs.ec2.EC2FleetInstanceRequirementsRequest;
        instanceType?: string;
        maxPrice?: string;
        placement?: outputs.ec2.EC2FleetPlacement;
        priority?: number;
        subnetId?: string;
        weightedCapacity?: number;
    }
    interface EC2FleetFleetLaunchTemplateSpecificationRequest {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version: string;
    }
    interface EC2FleetInstanceRequirementsRequest {
        acceleratorCount?: outputs.ec2.EC2FleetAcceleratorCountRequest;
        acceleratorManufacturers?: enums.ec2.EC2FleetInstanceRequirementsRequestAcceleratorManufacturersItem[];
        acceleratorNames?: enums.ec2.EC2FleetInstanceRequirementsRequestAcceleratorNamesItem[];
        acceleratorTotalMemoryMiB?: outputs.ec2.EC2FleetAcceleratorTotalMemoryMiBRequest;
        acceleratorTypes?: enums.ec2.EC2FleetInstanceRequirementsRequestAcceleratorTypesItem[];
        allowedInstanceTypes?: string[];
        bareMetal?: enums.ec2.EC2FleetInstanceRequirementsRequestBareMetal;
        baselineEbsBandwidthMbps?: outputs.ec2.EC2FleetBaselineEbsBandwidthMbpsRequest;
        burstablePerformance?: enums.ec2.EC2FleetInstanceRequirementsRequestBurstablePerformance;
        cpuManufacturers?: enums.ec2.EC2FleetInstanceRequirementsRequestCpuManufacturersItem[];
        excludedInstanceTypes?: string[];
        instanceGenerations?: enums.ec2.EC2FleetInstanceRequirementsRequestInstanceGenerationsItem[];
        localStorage?: enums.ec2.EC2FleetInstanceRequirementsRequestLocalStorage;
        localStorageTypes?: enums.ec2.EC2FleetInstanceRequirementsRequestLocalStorageTypesItem[];
        memoryGiBPerVCpu?: outputs.ec2.EC2FleetMemoryGiBPerVCpuRequest;
        memoryMiB?: outputs.ec2.EC2FleetMemoryMiBRequest;
        networkBandwidthGbps?: outputs.ec2.EC2FleetNetworkBandwidthGbpsRequest;
        networkInterfaceCount?: outputs.ec2.EC2FleetNetworkInterfaceCountRequest;
        onDemandMaxPricePercentageOverLowestPrice?: number;
        requireHibernateSupport?: boolean;
        spotMaxPricePercentageOverLowestPrice?: number;
        totalLocalStorageGB?: outputs.ec2.EC2FleetTotalLocalStorageGBRequest;
        vCpuCount?: outputs.ec2.EC2FleetVCpuCountRangeRequest;
    }
    interface EC2FleetMaintenanceStrategies {
        capacityRebalance?: outputs.ec2.EC2FleetCapacityRebalance;
    }
    interface EC2FleetMemoryGiBPerVCpuRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetMemoryMiBRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetNetworkBandwidthGbpsRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetNetworkInterfaceCountRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetOnDemandOptionsRequest {
        allocationStrategy?: string;
        capacityReservationOptions?: outputs.ec2.EC2FleetCapacityReservationOptionsRequest;
        maxTotalPrice?: string;
        minTargetCapacity?: number;
        singleAvailabilityZone?: boolean;
        singleInstanceType?: boolean;
    }
    interface EC2FleetPlacement {
        affinity?: string;
        availabilityZone?: string;
        groupName?: string;
        hostId?: string;
        hostResourceGroupArn?: string;
        partitionNumber?: number;
        spreadDomain?: string;
        tenancy?: string;
    }
    interface EC2FleetSpotOptionsRequest {
        allocationStrategy?: enums.ec2.EC2FleetSpotOptionsRequestAllocationStrategy;
        instanceInterruptionBehavior?: enums.ec2.EC2FleetSpotOptionsRequestInstanceInterruptionBehavior;
        instancePoolsToUseCount?: number;
        maintenanceStrategies?: outputs.ec2.EC2FleetMaintenanceStrategies;
        maxTotalPrice?: string;
        minTargetCapacity?: number;
        singleAvailabilityZone?: boolean;
        singleInstanceType?: boolean;
    }
    interface EC2FleetTag {
        key: string;
        value: string;
    }
    interface EC2FleetTagSpecification {
        resourceType?: enums.ec2.EC2FleetTagSpecificationResourceType;
        tags?: outputs.ec2.EC2FleetTag[];
    }
    interface EC2FleetTargetCapacitySpecificationRequest {
        defaultTargetCapacityType?: enums.ec2.EC2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType;
        onDemandTargetCapacity?: number;
        spotTargetCapacity?: number;
        targetCapacityUnitType?: enums.ec2.EC2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType;
        totalTargetCapacity: number;
    }
    interface EC2FleetTotalLocalStorageGBRequest {
        max?: number;
        min?: number;
    }
    interface EC2FleetVCpuCountRangeRequest {
        max?: number;
        min?: number;
    }
    interface EIPTag {
        key: string;
        value: string;
    }
    interface FlowLogTag {
        key: string;
        value: string;
    }
    /**
     * The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
     */
    interface IPAMIpamOperatingRegion {
        /**
         * The name of the region.
         */
        regionName: string;
    }
    /**
     * An address space to be inserted into this pool. All allocations must be made from this address space.
     */
    interface IPAMPoolProvisionedCidr {
        cidr: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface IPAMPoolTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface IPAMScopeTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface IPAMTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface InstanceAssociationParameter {
        key: string;
        value: string[];
    }
    interface InstanceBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.ec2.InstanceEbs;
        noDevice?: outputs.ec2.InstanceNoDevice;
        virtualName?: string;
    }
    interface InstanceCpuOptions {
        coreCount?: number;
        threadsPerCore?: number;
    }
    interface InstanceCreditSpecification {
        cPUCredits?: string;
    }
    interface InstanceEbs {
        deleteOnTermination?: boolean;
        encrypted?: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        volumeSize?: number;
        volumeType?: string;
    }
    interface InstanceElasticGpuSpecification {
        type: string;
    }
    interface InstanceElasticInferenceAccelerator {
        count?: number;
        type: string;
    }
    interface InstanceEnclaveOptions {
        enabled?: boolean;
    }
    interface InstanceHibernationOptions {
        configured?: boolean;
    }
    interface InstanceIpv6Address {
        ipv6Address: string;
    }
    interface InstanceLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version: string;
    }
    interface InstanceLicenseSpecification {
        licenseConfigurationArn: string;
    }
    interface InstanceNetworkInterface {
        associateCarrierIpAddress?: boolean;
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description?: string;
        deviceIndex: string;
        groupSet?: string[];
        ipv6AddressCount?: number;
        ipv6Addresses?: outputs.ec2.InstanceIpv6Address[];
        networkInterfaceId?: string;
        privateIpAddress?: string;
        privateIpAddresses?: outputs.ec2.InstancePrivateIpAddressSpecification[];
        secondaryPrivateIpAddressCount?: number;
        subnetId?: string;
    }
    interface InstanceNoDevice {
    }
    interface InstancePrivateDnsNameOptions {
        enableResourceNameDnsAAAARecord?: boolean;
        enableResourceNameDnsARecord?: boolean;
        hostnameType?: string;
    }
    interface InstancePrivateIpAddressSpecification {
        primary: boolean;
        privateIpAddress: string;
    }
    interface InstanceSsmAssociation {
        associationParameters?: outputs.ec2.InstanceAssociationParameter[];
        documentName: string;
    }
    interface InstanceTag {
        key: string;
        value: string;
    }
    interface InstanceVolume {
        device: string;
        volumeId: string;
    }
    interface InternetGatewayTag {
        key: string;
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface KeyPairTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface LaunchTemplateAcceleratorCount {
        max?: number;
        min?: number;
    }
    interface LaunchTemplateAcceleratorTotalMemoryMiB {
        max?: number;
        min?: number;
    }
    interface LaunchTemplateBaselineEbsBandwidthMbps {
        max?: number;
        min?: number;
    }
    interface LaunchTemplateBlockDeviceMapping {
        deviceName?: string;
        ebs?: outputs.ec2.LaunchTemplateEbs;
        noDevice?: string;
        virtualName?: string;
    }
    interface LaunchTemplateCapacityReservationSpecification {
        capacityReservationPreference?: string;
        capacityReservationTarget?: outputs.ec2.LaunchTemplateCapacityReservationTarget;
    }
    interface LaunchTemplateCapacityReservationTarget {
        capacityReservationId?: string;
        capacityReservationResourceGroupArn?: string;
    }
    interface LaunchTemplateCpuOptions {
        coreCount?: number;
        threadsPerCore?: number;
    }
    interface LaunchTemplateCreditSpecification {
        cpuCredits?: string;
    }
    interface LaunchTemplateData {
        blockDeviceMappings?: outputs.ec2.LaunchTemplateBlockDeviceMapping[];
        capacityReservationSpecification?: outputs.ec2.LaunchTemplateCapacityReservationSpecification;
        cpuOptions?: outputs.ec2.LaunchTemplateCpuOptions;
        creditSpecification?: outputs.ec2.LaunchTemplateCreditSpecification;
        disableApiStop?: boolean;
        disableApiTermination?: boolean;
        ebsOptimized?: boolean;
        elasticGpuSpecifications?: outputs.ec2.LaunchTemplateElasticGpuSpecification[];
        elasticInferenceAccelerators?: outputs.ec2.LaunchTemplateElasticInferenceAccelerator[];
        enclaveOptions?: outputs.ec2.LaunchTemplateEnclaveOptions;
        hibernationOptions?: outputs.ec2.LaunchTemplateHibernationOptions;
        iamInstanceProfile?: outputs.ec2.LaunchTemplateIamInstanceProfile;
        imageId?: string;
        instanceInitiatedShutdownBehavior?: string;
        instanceMarketOptions?: outputs.ec2.LaunchTemplateInstanceMarketOptions;
        instanceRequirements?: outputs.ec2.LaunchTemplateInstanceRequirements;
        instanceType?: string;
        kernelId?: string;
        keyName?: string;
        licenseSpecifications?: outputs.ec2.LaunchTemplateLicenseSpecification[];
        maintenanceOptions?: outputs.ec2.LaunchTemplateMaintenanceOptions;
        metadataOptions?: outputs.ec2.LaunchTemplateMetadataOptions;
        monitoring?: outputs.ec2.LaunchTemplateMonitoring;
        networkInterfaces?: outputs.ec2.LaunchTemplateNetworkInterface[];
        placement?: outputs.ec2.LaunchTemplatePlacement;
        privateDnsNameOptions?: outputs.ec2.LaunchTemplatePrivateDnsNameOptions;
        ramDiskId?: string;
        securityGroupIds?: string[];
        securityGroups?: string[];
        tagSpecifications?: outputs.ec2.LaunchTemplateTagSpecification[];
        userData?: string;
    }
    interface LaunchTemplateEbs {
        deleteOnTermination?: boolean;
        encrypted?: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType?: string;
    }
    interface LaunchTemplateElasticGpuSpecification {
        type?: string;
    }
    interface LaunchTemplateElasticInferenceAccelerator {
        count?: number;
        type?: string;
    }
    interface LaunchTemplateEnclaveOptions {
        enabled?: boolean;
    }
    interface LaunchTemplateHibernationOptions {
        configured?: boolean;
    }
    interface LaunchTemplateIamInstanceProfile {
        arn?: string;
        name?: string;
    }
    interface LaunchTemplateInstanceMarketOptions {
        marketType?: string;
        spotOptions?: outputs.ec2.LaunchTemplateSpotOptions;
    }
    interface LaunchTemplateInstanceRequirements {
        acceleratorCount?: outputs.ec2.LaunchTemplateAcceleratorCount;
        acceleratorManufacturers?: string[];
        acceleratorNames?: string[];
        acceleratorTotalMemoryMiB?: outputs.ec2.LaunchTemplateAcceleratorTotalMemoryMiB;
        acceleratorTypes?: string[];
        bareMetal?: string;
        baselineEbsBandwidthMbps?: outputs.ec2.LaunchTemplateBaselineEbsBandwidthMbps;
        burstablePerformance?: string;
        cpuManufacturers?: string[];
        excludedInstanceTypes?: string[];
        instanceGenerations?: string[];
        localStorage?: string;
        localStorageTypes?: string[];
        memoryGiBPerVCpu?: outputs.ec2.LaunchTemplateMemoryGiBPerVCpu;
        memoryMiB?: outputs.ec2.LaunchTemplateMemoryMiB;
        networkInterfaceCount?: outputs.ec2.LaunchTemplateNetworkInterfaceCount;
        onDemandMaxPricePercentageOverLowestPrice?: number;
        requireHibernateSupport?: boolean;
        spotMaxPricePercentageOverLowestPrice?: number;
        totalLocalStorageGB?: outputs.ec2.LaunchTemplateTotalLocalStorageGB;
        vCpuCount?: outputs.ec2.LaunchTemplateVCpuCount;
    }
    interface LaunchTemplateIpv4PrefixSpecification {
        ipv4Prefix?: string;
    }
    interface LaunchTemplateIpv6Add {
        ipv6Address?: string;
    }
    interface LaunchTemplateIpv6PrefixSpecification {
        ipv6Prefix?: string;
    }
    interface LaunchTemplateLicenseSpecification {
        licenseConfigurationArn?: string;
    }
    interface LaunchTemplateMaintenanceOptions {
        autoRecovery?: string;
    }
    interface LaunchTemplateMemoryGiBPerVCpu {
        max?: number;
        min?: number;
    }
    interface LaunchTemplateMemoryMiB {
        max?: number;
        min?: number;
    }
    interface LaunchTemplateMetadataOptions {
        httpEndpoint?: string;
        httpProtocolIpv6?: string;
        httpPutResponseHopLimit?: number;
        httpTokens?: string;
        instanceMetadataTags?: string;
    }
    interface LaunchTemplateMonitoring {
        enabled?: boolean;
    }
    interface LaunchTemplateNetworkInterface {
        associateCarrierIpAddress?: boolean;
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description?: string;
        deviceIndex?: number;
        groups?: string[];
        interfaceType?: string;
        ipv4PrefixCount?: number;
        ipv4Prefixes?: outputs.ec2.LaunchTemplateIpv4PrefixSpecification[];
        ipv6AddressCount?: number;
        ipv6Addresses?: outputs.ec2.LaunchTemplateIpv6Add[];
        ipv6PrefixCount?: number;
        ipv6Prefixes?: outputs.ec2.LaunchTemplateIpv6PrefixSpecification[];
        networkCardIndex?: number;
        networkInterfaceId?: string;
        privateIpAddress?: string;
        privateIpAddresses?: outputs.ec2.LaunchTemplatePrivateIpAdd[];
        secondaryPrivateIpAddressCount?: number;
        subnetId?: string;
    }
    interface LaunchTemplateNetworkInterfaceCount {
        max?: number;
        min?: number;
    }
    interface LaunchTemplatePlacement {
        affinity?: string;
        availabilityZone?: string;
        groupName?: string;
        hostId?: string;
        hostResourceGroupArn?: string;
        partitionNumber?: number;
        spreadDomain?: string;
        tenancy?: string;
    }
    interface LaunchTemplatePrivateDnsNameOptions {
        enableResourceNameDnsAAAARecord?: boolean;
        enableResourceNameDnsARecord?: boolean;
        hostnameType?: string;
    }
    interface LaunchTemplatePrivateIpAdd {
        primary?: boolean;
        privateIpAddress?: string;
    }
    interface LaunchTemplateSpotOptions {
        blockDurationMinutes?: number;
        instanceInterruptionBehavior?: string;
        maxPrice?: string;
        spotInstanceType?: string;
        validUntil?: string;
    }
    interface LaunchTemplateTag {
        key: string;
        value: string;
    }
    interface LaunchTemplateTagSpecification {
        resourceType?: string;
        tags?: outputs.ec2.LaunchTemplateTag[];
    }
    interface LaunchTemplateTotalLocalStorageGB {
        max?: number;
        min?: number;
    }
    interface LaunchTemplateVCpuCount {
        max?: number;
        min?: number;
    }
    interface LocalGatewayRouteTableVPCAssociationTag {
        key?: string;
        value?: string;
    }
    interface NatGatewayTag {
        key: string;
        value: string;
    }
    interface NetworkAclEntryIcmp {
        code?: number;
        type?: number;
    }
    interface NetworkAclEntryPortRange {
        from?: number;
        to?: number;
    }
    interface NetworkAclTag {
        key: string;
        value: string;
    }
    interface NetworkInsightsAccessScopeAccessScopePathRequest {
        destination?: outputs.ec2.NetworkInsightsAccessScopePathStatementRequest;
        source?: outputs.ec2.NetworkInsightsAccessScopePathStatementRequest;
        throughResources?: outputs.ec2.NetworkInsightsAccessScopeThroughResourcesStatementRequest[];
    }
    interface NetworkInsightsAccessScopeAnalysisTag {
        key: string;
        value?: string;
    }
    interface NetworkInsightsAccessScopePacketHeaderStatementRequest {
        destinationAddresses?: string[];
        destinationPorts?: string[];
        destinationPrefixLists?: string[];
        protocols?: enums.ec2.NetworkInsightsAccessScopeProtocol[];
        sourceAddresses?: string[];
        sourcePorts?: string[];
        sourcePrefixLists?: string[];
    }
    interface NetworkInsightsAccessScopePathStatementRequest {
        packetHeaderStatement?: outputs.ec2.NetworkInsightsAccessScopePacketHeaderStatementRequest;
        resourceStatement?: outputs.ec2.NetworkInsightsAccessScopeResourceStatementRequest;
    }
    interface NetworkInsightsAccessScopeResourceStatementRequest {
        resourceTypes?: string[];
        resources?: string[];
    }
    interface NetworkInsightsAccessScopeTag {
        key: string;
        value?: string;
    }
    interface NetworkInsightsAccessScopeThroughResourcesStatementRequest {
        resourceStatement?: outputs.ec2.NetworkInsightsAccessScopeResourceStatementRequest;
    }
    interface NetworkInsightsAnalysisAdditionalDetail {
        additionalDetailType?: string;
        component?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
    }
    interface NetworkInsightsAnalysisAlternatePathHint {
        componentArn?: string;
        componentId?: string;
    }
    interface NetworkInsightsAnalysisAnalysisAclRule {
        cidr?: string;
        egress?: boolean;
        portRange?: outputs.ec2.NetworkInsightsAnalysisPortRange;
        protocol?: string;
        ruleAction?: string;
        ruleNumber?: number;
    }
    interface NetworkInsightsAnalysisAnalysisComponent {
        arn?: string;
        id?: string;
    }
    interface NetworkInsightsAnalysisAnalysisLoadBalancerListener {
        instancePort?: number;
        loadBalancerPort?: number;
    }
    interface NetworkInsightsAnalysisAnalysisLoadBalancerTarget {
        address?: string;
        availabilityZone?: string;
        instance?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        port?: number;
    }
    interface NetworkInsightsAnalysisAnalysisPacketHeader {
        destinationAddresses?: string[];
        destinationPortRanges?: outputs.ec2.NetworkInsightsAnalysisPortRange[];
        protocol?: string;
        sourceAddresses?: string[];
        sourcePortRanges?: outputs.ec2.NetworkInsightsAnalysisPortRange[];
    }
    interface NetworkInsightsAnalysisAnalysisRouteTableRoute {
        destinationCidr?: string;
        destinationPrefixListId?: string;
        egressOnlyInternetGatewayId?: string;
        gatewayId?: string;
        instanceId?: string;
        natGatewayId?: string;
        networkInterfaceId?: string;
        origin?: string;
        state?: string;
        transitGatewayId?: string;
        vpcPeeringConnectionId?: string;
    }
    interface NetworkInsightsAnalysisAnalysisSecurityGroupRule {
        cidr?: string;
        direction?: string;
        portRange?: outputs.ec2.NetworkInsightsAnalysisPortRange;
        prefixListId?: string;
        protocol?: string;
        securityGroupId?: string;
    }
    interface NetworkInsightsAnalysisExplanation {
        acl?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        aclRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisAclRule;
        address?: string;
        addresses?: string[];
        attachedTo?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        availabilityZones?: string[];
        cidrs?: string[];
        classicLoadBalancerListener?: outputs.ec2.NetworkInsightsAnalysisAnalysisLoadBalancerListener;
        component?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        componentAccount?: string;
        componentRegion?: string;
        customerGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        destination?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        destinationVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        direction?: string;
        elasticLoadBalancerListener?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        explanationCode?: string;
        ingressRouteTable?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        internetGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        loadBalancerArn?: string;
        loadBalancerListenerPort?: number;
        loadBalancerTarget?: outputs.ec2.NetworkInsightsAnalysisAnalysisLoadBalancerTarget;
        loadBalancerTargetGroup?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        loadBalancerTargetGroups?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent[];
        loadBalancerTargetPort?: number;
        missingComponent?: string;
        natGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        networkInterface?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        packetField?: string;
        port?: number;
        portRanges?: outputs.ec2.NetworkInsightsAnalysisPortRange[];
        prefixList?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        protocols?: string[];
        routeTable?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        routeTableRoute?: outputs.ec2.NetworkInsightsAnalysisAnalysisRouteTableRoute;
        securityGroup?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        securityGroupRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisSecurityGroupRule;
        securityGroups?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent[];
        sourceVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        state?: string;
        subnet?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        subnetRouteTable?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        transitGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        transitGatewayAttachment?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        transitGatewayRouteTable?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        transitGatewayRouteTableRoute?: outputs.ec2.NetworkInsightsAnalysisTransitGatewayRouteTableRoute;
        vpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpcEndpoint?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpcPeeringConnection?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpnConnection?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpnGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
    }
    interface NetworkInsightsAnalysisPathComponent {
        aclRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisAclRule;
        additionalDetails?: outputs.ec2.NetworkInsightsAnalysisAdditionalDetail[];
        component?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        destinationVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        elasticLoadBalancerListener?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        explanations?: outputs.ec2.NetworkInsightsAnalysisExplanation[];
        inboundHeader?: outputs.ec2.NetworkInsightsAnalysisAnalysisPacketHeader;
        outboundHeader?: outputs.ec2.NetworkInsightsAnalysisAnalysisPacketHeader;
        routeTableRoute?: outputs.ec2.NetworkInsightsAnalysisAnalysisRouteTableRoute;
        securityGroupRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisSecurityGroupRule;
        sequenceNumber?: number;
        sourceVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        subnet?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        transitGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        transitGatewayRouteTableRoute?: outputs.ec2.NetworkInsightsAnalysisTransitGatewayRouteTableRoute;
        vpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
    }
    interface NetworkInsightsAnalysisPortRange {
        from?: number;
        to?: number;
    }
    interface NetworkInsightsAnalysisTag {
        key: string;
        value?: string;
    }
    interface NetworkInsightsAnalysisTransitGatewayRouteTableRoute {
        attachmentId?: string;
        destinationCidr?: string;
        prefixListId?: string;
        resourceId?: string;
        resourceType?: string;
        routeOrigin?: string;
        state?: string;
    }
    interface NetworkInsightsPathTag {
        key: string;
        value?: string;
    }
    interface NetworkInterfaceInstanceIpv6Address {
        ipv6Address: string;
    }
    interface NetworkInterfacePrivateIpAddressSpecification {
        primary: boolean;
        privateIpAddress: string;
    }
    interface NetworkInterfaceTag {
        key: string;
        value: string;
    }
    /**
     * The options for the transit gateway vpc attachment.
     */
    interface OptionsProperties {
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        applianceModeSupport?: string;
        /**
         * Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
         */
        dnsSupport?: string;
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        ipv6Support?: string;
    }
    interface PrefixListEntry {
        cidr: string;
        description?: string;
    }
    interface PrefixListTag {
        key: string;
        value?: string;
    }
    interface PrivateDnsNameOptionsOnLaunchProperties {
        enableResourceNameDnsAAAARecord?: boolean;
        enableResourceNameDnsARecord?: boolean;
        hostnameType?: string;
    }
    interface RouteTableTag {
        key: string;
        value: string;
    }
    interface SecurityGroupEgress {
        cidrIp?: string;
        cidrIpv6?: string;
        description?: string;
        destinationPrefixListId?: string;
        destinationSecurityGroupId?: string;
        fromPort?: number;
        ipProtocol: string;
        toPort?: number;
    }
    interface SecurityGroupIngress {
        cidrIp?: string;
        cidrIpv6?: string;
        description?: string;
        fromPort?: number;
        ipProtocol: string;
        sourcePrefixListId?: string;
        sourceSecurityGroupId?: string;
        sourceSecurityGroupName?: string;
        sourceSecurityGroupOwnerId?: string;
        toPort?: number;
    }
    interface SecurityGroupTag {
        key: string;
        value: string;
    }
    interface SpotFleetAcceleratorCountRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetAcceleratorTotalMemoryMiBRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetBaselineEbsBandwidthMbpsRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.ec2.SpotFleetEbsBlockDevice;
        noDevice?: string;
        virtualName?: string;
    }
    interface SpotFleetClassicLoadBalancer {
        name: string;
    }
    interface SpotFleetClassicLoadBalancersConfig {
        classicLoadBalancers: outputs.ec2.SpotFleetClassicLoadBalancer[];
    }
    interface SpotFleetEbsBlockDevice {
        deleteOnTermination?: boolean;
        encrypted?: boolean;
        iops?: number;
        snapshotId?: string;
        volumeSize?: number;
        volumeType?: enums.ec2.SpotFleetEbsBlockDeviceVolumeType;
    }
    interface SpotFleetFleetLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version: string;
    }
    interface SpotFleetGroupIdentifier {
        groupId: string;
    }
    interface SpotFleetIamInstanceProfileSpecification {
        arn?: string;
    }
    interface SpotFleetInstanceIpv6Address {
        ipv6Address: string;
    }
    interface SpotFleetInstanceNetworkInterfaceSpecification {
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description?: string;
        deviceIndex?: number;
        groups?: string[];
        ipv6AddressCount?: number;
        ipv6Addresses?: outputs.ec2.SpotFleetInstanceIpv6Address[];
        networkInterfaceId?: string;
        privateIpAddresses?: outputs.ec2.SpotFleetPrivateIpAddressSpecification[];
        secondaryPrivateIpAddressCount?: number;
        subnetId?: string;
    }
    interface SpotFleetInstanceRequirementsRequest {
        acceleratorCount?: outputs.ec2.SpotFleetAcceleratorCountRequest;
        acceleratorManufacturers?: enums.ec2.SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem[];
        acceleratorNames?: enums.ec2.SpotFleetInstanceRequirementsRequestAcceleratorNamesItem[];
        acceleratorTotalMemoryMiB?: outputs.ec2.SpotFleetAcceleratorTotalMemoryMiBRequest;
        acceleratorTypes?: enums.ec2.SpotFleetInstanceRequirementsRequestAcceleratorTypesItem[];
        allowedInstanceTypes?: string[];
        bareMetal?: enums.ec2.SpotFleetInstanceRequirementsRequestBareMetal;
        baselineEbsBandwidthMbps?: outputs.ec2.SpotFleetBaselineEbsBandwidthMbpsRequest;
        burstablePerformance?: enums.ec2.SpotFleetInstanceRequirementsRequestBurstablePerformance;
        cpuManufacturers?: enums.ec2.SpotFleetInstanceRequirementsRequestCpuManufacturersItem[];
        excludedInstanceTypes?: string[];
        instanceGenerations?: enums.ec2.SpotFleetInstanceRequirementsRequestInstanceGenerationsItem[];
        localStorage?: enums.ec2.SpotFleetInstanceRequirementsRequestLocalStorage;
        localStorageTypes?: enums.ec2.SpotFleetInstanceRequirementsRequestLocalStorageTypesItem[];
        memoryGiBPerVCpu?: outputs.ec2.SpotFleetMemoryGiBPerVCpuRequest;
        memoryMiB?: outputs.ec2.SpotFleetMemoryMiBRequest;
        networkBandwidthGbps?: outputs.ec2.SpotFleetNetworkBandwidthGbpsRequest;
        networkInterfaceCount?: outputs.ec2.SpotFleetNetworkInterfaceCountRequest;
        onDemandMaxPricePercentageOverLowestPrice?: number;
        requireHibernateSupport?: boolean;
        spotMaxPricePercentageOverLowestPrice?: number;
        totalLocalStorageGB?: outputs.ec2.SpotFleetTotalLocalStorageGBRequest;
        vCpuCount?: outputs.ec2.SpotFleetVCpuCountRangeRequest;
    }
    interface SpotFleetLaunchSpecification {
        blockDeviceMappings?: outputs.ec2.SpotFleetBlockDeviceMapping[];
        ebsOptimized?: boolean;
        iamInstanceProfile?: outputs.ec2.SpotFleetIamInstanceProfileSpecification;
        imageId: string;
        instanceRequirements?: outputs.ec2.SpotFleetInstanceRequirementsRequest;
        instanceType?: string;
        kernelId?: string;
        keyName?: string;
        monitoring?: outputs.ec2.SpotFleetMonitoring;
        networkInterfaces?: outputs.ec2.SpotFleetInstanceNetworkInterfaceSpecification[];
        placement?: outputs.ec2.SpotFleetSpotPlacement;
        ramdiskId?: string;
        securityGroups?: outputs.ec2.SpotFleetGroupIdentifier[];
        spotPrice?: string;
        subnetId?: string;
        tagSpecifications?: outputs.ec2.SpotFleetTagSpecification[];
        userData?: string;
        weightedCapacity?: number;
    }
    interface SpotFleetLaunchTemplateConfig {
        launchTemplateSpecification?: outputs.ec2.SpotFleetFleetLaunchTemplateSpecification;
        overrides?: outputs.ec2.SpotFleetLaunchTemplateOverrides[];
    }
    interface SpotFleetLaunchTemplateOverrides {
        availabilityZone?: string;
        instanceRequirements?: outputs.ec2.SpotFleetInstanceRequirementsRequest;
        instanceType?: string;
        priority?: number;
        spotPrice?: string;
        subnetId?: string;
        weightedCapacity?: number;
    }
    interface SpotFleetLoadBalancersConfig {
        classicLoadBalancersConfig?: outputs.ec2.SpotFleetClassicLoadBalancersConfig;
        targetGroupsConfig?: outputs.ec2.SpotFleetTargetGroupsConfig;
    }
    interface SpotFleetMemoryGiBPerVCpuRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetMemoryMiBRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetMonitoring {
        enabled?: boolean;
    }
    interface SpotFleetNetworkBandwidthGbpsRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetNetworkInterfaceCountRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetPrivateIpAddressSpecification {
        primary?: boolean;
        privateIpAddress: string;
    }
    interface SpotFleetRequestConfigData {
        allocationStrategy?: enums.ec2.SpotFleetRequestConfigDataAllocationStrategy;
        context?: string;
        excessCapacityTerminationPolicy?: enums.ec2.SpotFleetRequestConfigDataExcessCapacityTerminationPolicy;
        iamFleetRole: string;
        instanceInterruptionBehavior?: enums.ec2.SpotFleetRequestConfigDataInstanceInterruptionBehavior;
        instancePoolsToUseCount?: number;
        launchSpecifications?: outputs.ec2.SpotFleetLaunchSpecification[];
        launchTemplateConfigs?: outputs.ec2.SpotFleetLaunchTemplateConfig[];
        loadBalancersConfig?: outputs.ec2.SpotFleetLoadBalancersConfig;
        onDemandAllocationStrategy?: string;
        onDemandMaxTotalPrice?: string;
        onDemandTargetCapacity?: number;
        replaceUnhealthyInstances?: boolean;
        spotMaintenanceStrategies?: outputs.ec2.SpotFleetSpotMaintenanceStrategies;
        spotMaxTotalPrice?: string;
        spotPrice?: string;
        tagSpecifications?: outputs.ec2.SpotFleetTagSpecification[];
        targetCapacity: number;
        targetCapacityUnitType?: enums.ec2.SpotFleetRequestConfigDataTargetCapacityUnitType;
        terminateInstancesWithExpiration?: boolean;
        type?: enums.ec2.SpotFleetRequestConfigDataType;
        validFrom?: string;
        validUntil?: string;
    }
    interface SpotFleetSpotCapacityRebalance {
        replacementStrategy?: enums.ec2.SpotFleetSpotCapacityRebalanceReplacementStrategy;
        terminationDelay?: number;
    }
    interface SpotFleetSpotMaintenanceStrategies {
        capacityRebalance?: outputs.ec2.SpotFleetSpotCapacityRebalance;
    }
    interface SpotFleetSpotPlacement {
        availabilityZone?: string;
        groupName?: string;
        tenancy?: enums.ec2.SpotFleetSpotPlacementTenancy;
    }
    interface SpotFleetTag {
        key: string;
        value: string;
    }
    interface SpotFleetTagSpecification {
        resourceType?: enums.ec2.SpotFleetTagSpecificationResourceType;
        tags?: outputs.ec2.SpotFleetTag[];
    }
    interface SpotFleetTargetGroup {
        arn: string;
    }
    interface SpotFleetTargetGroupsConfig {
        targetGroups: outputs.ec2.SpotFleetTargetGroup[];
    }
    interface SpotFleetTotalLocalStorageGBRequest {
        max?: number;
        min?: number;
    }
    interface SpotFleetVCpuCountRangeRequest {
        max?: number;
        min?: number;
    }
    interface SubnetTag {
        key: string;
        value: string;
    }
    interface TrafficMirrorFilterRuleTrafficMirrorPortRange {
        fromPort: number;
        toPort: number;
    }
    interface TrafficMirrorFilterTag {
        key: string;
        value: string;
    }
    interface TrafficMirrorSessionTag {
        key: string;
        value: string;
    }
    interface TrafficMirrorTargetTag {
        key: string;
        value: string;
    }
    interface TransitGatewayAttachmentTag {
        key: string;
        value: string;
    }
    interface TransitGatewayConnectOptions {
        /**
         * The tunnel protocol.
         */
        protocol?: string;
    }
    interface TransitGatewayConnectTag {
        /**
         * The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
         */
        key?: string;
        /**
         * The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
         */
        value?: string;
    }
    interface TransitGatewayMulticastDomainTag {
        /**
         * The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
         */
        key?: string;
        /**
         * The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
         */
        value?: string;
    }
    interface TransitGatewayPeeringAttachmentPeeringAttachmentStatus {
        /**
         * The status code.
         */
        code?: string;
        /**
         * The status message, if applicable.
         */
        message?: string;
    }
    interface TransitGatewayPeeringAttachmentTag {
        /**
         * The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
         */
        key?: string;
        /**
         * The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
         */
        value?: string;
    }
    interface TransitGatewayRouteTableTag {
        key: string;
        value: string;
    }
    interface TransitGatewayTag {
        key: string;
        value: string;
    }
    interface TransitGatewayVpcAttachmentTag {
        key: string;
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface VPCPeeringConnectionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface VPCTag {
        key: string;
        value: string;
    }
    interface VPNConnectionTag {
        key: string;
        value: string;
    }
    interface VPNConnectionVpnTunnelOptionsSpecification {
        preSharedKey?: string;
        tunnelInsideCidr?: string;
    }
    interface VPNGatewayTag {
        key: string;
        value: string;
    }
    interface VolumeTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace ecr {
    /**
     * A key-value pair to associate with a resource.
     */
    interface PublicRepositoryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * An object representing the replication configuration for a registry.
     */
    interface ReplicationConfiguration {
        /**
         * An array of objects representing the replication rules for a replication configuration. A replication configuration may contain a maximum of 10 rules.
         */
        rules: outputs.ecr.ReplicationConfigurationReplicationRule[];
    }
    /**
     * An array of objects representing the details of a replication destination.
     */
    interface ReplicationConfigurationReplicationDestination {
        region: string;
        registryId: string;
    }
    /**
     * An array of objects representing the details of a replication destination.
     */
    interface ReplicationConfigurationReplicationRule {
        /**
         * An array of objects representing the details of a replication destination.
         */
        destinations: outputs.ecr.ReplicationConfigurationReplicationDestination[];
        /**
         * An array of objects representing the details of a repository filter.
         */
        repositoryFilters?: outputs.ecr.ReplicationConfigurationRepositoryFilter[];
    }
    /**
     * An array of objects representing the details of a repository filter.
     */
    interface ReplicationConfigurationRepositoryFilter {
        filter: string;
        filterType: enums.ecr.ReplicationConfigurationFilterType;
    }
    /**
     * The CatalogData property type specifies Catalog data for ECR Public Repository. For information about Catalog Data, see <link>
     */
    interface RepositoryCatalogDataProperties {
        aboutText?: string;
        architectures?: string[];
        operatingSystems?: string[];
        repositoryDescription?: string;
        usageText?: string;
    }
    /**
     * The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
     *
     * By default, when no encryption configuration is set or the AES256 encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This does not require any action on your part.
     *
     * For more information, see https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html
     */
    interface RepositoryEncryptionConfiguration {
        encryptionType: enums.ecr.RepositoryEncryptionType;
        kmsKey?: string;
    }
    /**
     * The image scanning configuration for the repository. This setting determines whether images are scanned for known vulnerabilities after being pushed to the repository.
     */
    interface RepositoryImageScanningConfiguration {
        scanOnPush?: boolean;
    }
    /**
     * The LifecyclePolicy property type specifies a lifecycle policy. For information about lifecycle policy syntax, see https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html
     */
    interface RepositoryLifecyclePolicy {
        lifecyclePolicyText?: string;
        registryId?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface RepositoryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace ecs {
    interface CapacityProviderAutoScalingGroupProvider {
        autoScalingGroupArn: string;
        managedScaling?: outputs.ecs.CapacityProviderManagedScaling;
        managedTerminationProtection?: enums.ecs.CapacityProviderAutoScalingGroupProviderManagedTerminationProtection;
    }
    /**
     * The managed scaling settings for the Auto Scaling group capacity provider.
     */
    interface CapacityProviderManagedScaling {
        instanceWarmupPeriod?: number;
        maximumScalingStepSize?: number;
        minimumScalingStepSize?: number;
        status?: enums.ecs.CapacityProviderManagedScalingStatus;
        targetCapacity?: number;
    }
    interface CapacityProviderTag {
        key?: string;
        value?: string;
    }
    interface ClusterCapacityProviderAssociationsCapacityProviderStrategy {
        base?: number;
        capacityProvider: enums.ecs.ClusterCapacityProviderAssociationsCapacityProvider | string;
        weight?: number;
    }
    /**
     * A capacity provider strategy consists of one or more capacity providers along with the `base` and `weight` to assign to them. A capacity provider must be associated with the cluster to be used in a capacity provider strategy. The PutClusterCapacityProviders API is used to associate a capacity provider with a cluster. Only capacity providers with an `ACTIVE` or `UPDATING` status can be used.
     */
    interface ClusterCapacityProviderStrategyItem {
        base?: number;
        capacityProvider?: string;
        weight?: number;
    }
    /**
     * The configurations to be set at cluster level.
     */
    interface ClusterConfiguration {
        executeCommandConfiguration?: outputs.ecs.ClusterExecuteCommandConfiguration;
    }
    /**
     * The configuration for ExecuteCommand.
     */
    interface ClusterExecuteCommandConfiguration {
        kmsKeyId?: string;
        logConfiguration?: outputs.ecs.ClusterExecuteCommandLogConfiguration;
        logging?: string;
    }
    /**
     * The session logging configuration for ExecuteCommand.
     */
    interface ClusterExecuteCommandLogConfiguration {
        cloudWatchEncryptionEnabled?: boolean;
        cloudWatchLogGroupName?: string;
        s3BucketName?: string;
        s3EncryptionEnabled?: boolean;
        s3KeyPrefix?: string;
    }
    /**
     * The setting to use when creating a cluster. This parameter is used to enable CloudWatch Container Insights for a cluster. If this value is specified, it will override the containerInsights value set with PutAccountSetting or PutAccountSettingDefault.
     */
    interface ClusterSettings {
        name?: string;
        value?: string;
    }
    /**
     * The metadata that you apply to the cluster to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
     */
    interface ClusterTag {
        key?: string;
        value?: string;
    }
    interface ServiceAwsVpcConfiguration {
        assignPublicIp?: enums.ecs.ServiceAwsVpcConfigurationAssignPublicIp;
        securityGroups?: string[];
        subnets?: string[];
    }
    interface ServiceCapacityProviderStrategyItem {
        base?: number;
        capacityProvider?: string;
        weight?: number;
    }
    interface ServiceDeploymentCircuitBreaker {
        enable: boolean;
        rollback: boolean;
    }
    interface ServiceDeploymentConfiguration {
        deploymentCircuitBreaker?: outputs.ecs.ServiceDeploymentCircuitBreaker;
        maximumPercent?: number;
        minimumHealthyPercent?: number;
    }
    interface ServiceDeploymentController {
        type?: enums.ecs.ServiceDeploymentControllerType;
    }
    interface ServiceLoadBalancer {
        containerName?: string;
        containerPort?: number;
        loadBalancerName?: string;
        targetGroupArn?: string;
    }
    interface ServiceNetworkConfiguration {
        awsvpcConfiguration?: outputs.ecs.ServiceAwsVpcConfiguration;
    }
    interface ServicePlacementConstraint {
        expression?: string;
        type: enums.ecs.ServicePlacementConstraintType;
    }
    interface ServicePlacementStrategy {
        field?: string;
        type: enums.ecs.ServicePlacementStrategyType;
    }
    interface ServiceRegistry {
        containerName?: string;
        containerPort?: number;
        port?: number;
        registryArn?: string;
    }
    interface ServiceTag {
        key?: string;
        value?: string;
    }
    interface TaskDefinitionAuthorizationConfig {
        accessPointId?: string;
        iAM?: enums.ecs.TaskDefinitionAuthorizationConfigIAM;
    }
    /**
     * List of container definitions that are passed to the Docker daemon on a container instance
     */
    interface TaskDefinitionContainerDefinition {
        command?: string[];
        cpu?: number;
        dependsOn?: outputs.ecs.TaskDefinitionContainerDependency[];
        disableNetworking?: boolean;
        dnsSearchDomains?: string[];
        dnsServers?: string[];
        dockerLabels?: any;
        dockerSecurityOptions?: string[];
        entryPoint?: string[];
        /**
         * The environment variables to pass to a container
         */
        environment?: outputs.ecs.TaskDefinitionKeyValuePair[];
        /**
         * The list of one or more files that contain the environment variables to pass to a container
         */
        environmentFiles?: outputs.ecs.TaskDefinitionEnvironmentFile[];
        essential?: boolean;
        extraHosts?: outputs.ecs.TaskDefinitionHostEntry[];
        firelensConfiguration?: outputs.ecs.TaskDefinitionFirelensConfiguration;
        healthCheck?: outputs.ecs.TaskDefinitionHealthCheck;
        hostname?: string;
        /**
         * The image used to start a container. This string is passed directly to the Docker daemon.
         */
        image: string;
        interactive?: boolean;
        links?: string[];
        linuxParameters?: outputs.ecs.TaskDefinitionLinuxParameters;
        logConfiguration?: outputs.ecs.TaskDefinitionLogConfiguration;
        /**
         * The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed.
         */
        memory?: number;
        memoryReservation?: number;
        mountPoints?: outputs.ecs.TaskDefinitionMountPoint[];
        /**
         * The name of a container. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed
         */
        name: string;
        /**
         * Port mappings allow containers to access ports on the host container instance to send or receive traffic.
         */
        portMappings?: outputs.ecs.TaskDefinitionPortMapping[];
        privileged?: boolean;
        pseudoTerminal?: boolean;
        readonlyRootFilesystem?: boolean;
        repositoryCredentials?: outputs.ecs.TaskDefinitionRepositoryCredentials;
        resourceRequirements?: outputs.ecs.TaskDefinitionResourceRequirement[];
        secrets?: outputs.ecs.TaskDefinitionSecret[];
        startTimeout?: number;
        stopTimeout?: number;
        systemControls?: outputs.ecs.TaskDefinitionSystemControl[];
        ulimits?: outputs.ecs.TaskDefinitionUlimit[];
        user?: string;
        volumesFrom?: outputs.ecs.TaskDefinitionVolumeFrom[];
        workingDirectory?: string;
    }
    interface TaskDefinitionContainerDependency {
        condition?: string;
        containerName?: string;
    }
    interface TaskDefinitionDevice {
        containerPath?: string;
        hostPath?: string;
        permissions?: string[];
    }
    interface TaskDefinitionDockerVolumeConfiguration {
        autoprovision?: boolean;
        driver?: string;
        driverOpts?: any;
        labels?: any;
        scope?: string;
    }
    interface TaskDefinitionEFSVolumeConfiguration {
        authorizationConfig?: outputs.ecs.TaskDefinitionAuthorizationConfig;
        filesystemId: string;
        rootDirectory?: string;
        transitEncryption?: enums.ecs.TaskDefinitionEFSVolumeConfigurationTransitEncryption;
        transitEncryptionPort?: number;
    }
    interface TaskDefinitionEnvironmentFile {
        type?: string;
        value?: string;
    }
    interface TaskDefinitionEphemeralStorage {
        sizeInGiB?: number;
    }
    interface TaskDefinitionFirelensConfiguration {
        options?: any;
        type?: string;
    }
    /**
     * The health check command and associated configuration parameters for the container.
     */
    interface TaskDefinitionHealthCheck {
        /**
         * A string array representing the command that the container runs to determine if it is healthy.
         */
        command?: string[];
        /**
         * The time period in seconds between each health check execution. You may specify between 5 and 300 seconds. The default value is 30 seconds.
         */
        interval?: number;
        /**
         * The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries. The default value is three retries.
         */
        retries?: number;
        /**
         * The optional grace period within which to provide containers time to bootstrap before failed health checks count towards the maximum number of retries. You may specify between 0 and 300 seconds. The startPeriod is disabled by default.
         */
        startPeriod?: number;
        /**
         * The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds. The default value is 5 seconds.
         */
        timeout?: number;
    }
    interface TaskDefinitionHostEntry {
        hostname?: string;
        ipAddress?: string;
    }
    interface TaskDefinitionHostVolumeProperties {
        sourcePath?: string;
    }
    interface TaskDefinitionInferenceAccelerator {
        deviceName?: string;
        deviceType?: string;
    }
    interface TaskDefinitionKernelCapabilities {
        add?: string[];
        drop?: string[];
    }
    interface TaskDefinitionKeyValuePair {
        name?: string;
        value?: string;
    }
    interface TaskDefinitionLinuxParameters {
        capabilities?: outputs.ecs.TaskDefinitionKernelCapabilities;
        devices?: outputs.ecs.TaskDefinitionDevice[];
        initProcessEnabled?: boolean;
        maxSwap?: number;
        sharedMemorySize?: number;
        swappiness?: number;
        tmpfs?: outputs.ecs.TaskDefinitionTmpfs[];
    }
    interface TaskDefinitionLogConfiguration {
        logDriver: string;
        options?: any;
        secretOptions?: outputs.ecs.TaskDefinitionSecret[];
    }
    interface TaskDefinitionMountPoint {
        containerPath?: string;
        readOnly?: boolean;
        sourceVolume?: string;
    }
    interface TaskDefinitionPlacementConstraint {
        expression?: string;
        type: string;
    }
    interface TaskDefinitionPortMapping {
        containerPort?: number;
        hostPort?: number;
        protocol?: string;
    }
    interface TaskDefinitionProxyConfiguration {
        containerName: string;
        proxyConfigurationProperties?: outputs.ecs.TaskDefinitionKeyValuePair[];
        type?: string;
    }
    interface TaskDefinitionRepositoryCredentials {
        credentialsParameter?: string;
    }
    interface TaskDefinitionResourceRequirement {
        type: string;
        value: string;
    }
    interface TaskDefinitionRuntimePlatform {
        cpuArchitecture?: string;
        operatingSystemFamily?: string;
    }
    interface TaskDefinitionSecret {
        name: string;
        valueFrom: string;
    }
    interface TaskDefinitionSystemControl {
        namespace?: string;
        value?: string;
    }
    interface TaskDefinitionTag {
        key?: string;
        value?: string;
    }
    interface TaskDefinitionTmpfs {
        containerPath?: string;
        mountOptions?: string[];
        size: number;
    }
    interface TaskDefinitionUlimit {
        hardLimit: number;
        name: string;
        softLimit: number;
    }
    interface TaskDefinitionVolume {
        dockerVolumeConfiguration?: outputs.ecs.TaskDefinitionDockerVolumeConfiguration;
        eFSVolumeConfiguration?: outputs.ecs.TaskDefinitionEFSVolumeConfiguration;
        host?: outputs.ecs.TaskDefinitionHostVolumeProperties;
        name?: string;
    }
    interface TaskDefinitionVolumeFrom {
        readOnly?: boolean;
        sourceContainer?: string;
    }
    /**
     * The VPC subnets and security groups associated with a task. All specified subnets and security groups must be from the same VPC.
     */
    interface TaskSetAwsVpcConfiguration {
        /**
         * Whether the task's elastic network interface receives a public IP address. The default value is DISABLED.
         */
        assignPublicIp?: enums.ecs.TaskSetAwsVpcConfigurationAssignPublicIp;
        /**
         * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used. There is a limit of 5 security groups that can be specified per AwsVpcConfiguration.
         */
        securityGroups?: string[];
        /**
         * The subnets associated with the task or service. There is a limit of 16 subnets that can be specified per AwsVpcConfiguration.
         */
        subnets: string[];
    }
    /**
     * A load balancer object representing the load balancer to use with the task set. The supported load balancer types are either an Application Load Balancer or a Network Load Balancer.
     */
    interface TaskSetLoadBalancer {
        /**
         * The name of the container (as it appears in a container definition) to associate with the load balancer.
         */
        containerName?: string;
        /**
         * The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the hostPort of the port mapping.
         */
        containerPort?: number;
        /**
         * The name of the load balancer to associate with the Amazon ECS service or task set. A load balancer name is only specified when using a Classic Load Balancer. If you are using an Application Load Balancer or a Network Load Balancer this should be omitted.
         */
        loadBalancerName?: string;
        /**
         * The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group or groups associated with a service or task set. A target group ARN is only specified when using an Application Load Balancer or Network Load Balancer. If you are using a Classic Load Balancer this should be omitted. For services using the ECS deployment controller, you can specify one or multiple target groups. For more information, see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/register-multiple-targetgroups.html in the Amazon Elastic Container Service Developer Guide. For services using the CODE_DEPLOY deployment controller, you are required to define two target groups for the load balancer. For more information, see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-bluegreen.html in the Amazon Elastic Container Service Developer Guide. If your service's task definition uses the awsvpc network mode (which is required for the Fargate launch type), you must choose ip as the target type, not instance, when creating your target groups because tasks that use the awsvpc network mode are associated with an elastic network interface, not an Amazon EC2 instance.
         */
        targetGroupArn?: string;
    }
    /**
     * An object representing the network configuration for a task or service.
     */
    interface TaskSetNetworkConfiguration {
        awsVpcConfiguration?: outputs.ecs.TaskSetAwsVpcConfiguration;
    }
    interface TaskSetScale {
        /**
         * The unit of measure for the scale value.
         */
        unit?: enums.ecs.TaskSetScaleUnit;
        /**
         * The value, specified as a percent total of a service's desiredCount, to scale the task set. Accepted values are numbers between 0 and 100.
         */
        value?: number;
    }
    interface TaskSetServiceRegistry {
        /**
         * The container name value, already specified in the task definition, to be used for your service discovery service. If the task definition that your service task specifies uses the bridge or host network mode, you must specify a containerName and containerPort combination from the task definition. If the task definition that your service task specifies uses the awsvpc network mode and a type SRV DNS record is used, you must specify either a containerName and containerPort combination or a port value, but not both.
         */
        containerName?: string;
        /**
         * The port value, already specified in the task definition, to be used for your service discovery service. If the task definition your service task specifies uses the bridge or host network mode, you must specify a containerName and containerPort combination from the task definition. If the task definition your service task specifies uses the awsvpc network mode and a type SRV DNS record is used, you must specify either a containerName and containerPort combination or a port value, but not both.
         */
        containerPort?: number;
        /**
         * The port value used if your service discovery service specified an SRV record. This field may be used if both the awsvpc network mode and SRV records are used.
         */
        port?: number;
        /**
         * The Amazon Resource Name (ARN) of the service registry. The currently supported service registry is AWS Cloud Map. For more information, see https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html
         */
        registryArn?: string;
    }
}
export declare namespace efs {
    interface AccessPointCreationInfo {
        /**
         * Specifies the POSIX group ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
         */
        ownerGid: string;
        /**
         * Specifies the POSIX user ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
         */
        ownerUid: string;
        /**
         * Specifies the POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
         */
        permissions: string;
    }
    interface AccessPointPosixUser {
        /**
         * The POSIX group ID used for all file system operations using this access point.
         */
        gid: string;
        /**
         * Secondary POSIX group IDs used for all file system operations using this access point.
         */
        secondaryGids?: string[];
        /**
         * The POSIX user ID used for all file system operations using this access point.
         */
        uid: string;
    }
    interface AccessPointRootDirectory {
        /**
         * (Optional) Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory. If the RootDirectory>Path specified does not exist, EFS creates the root directory using the CreationInfo settings when a client connects to an access point. When specifying the CreationInfo, you must provide values for all properties.   If you do not provide CreationInfo and the specified RootDirectory>Path does not exist, attempts to mount the file system using the access point will fail.
         */
        creationInfo?: outputs.efs.AccessPointCreationInfo;
        /**
         * Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide the CreationInfo.
         */
        path?: string;
    }
    interface AccessPointTag {
        key?: string;
        value?: string;
    }
    interface FileSystemBackupPolicy {
        status: string;
    }
    interface FileSystemElasticFileSystemTag {
        key: string;
        value: string;
    }
    interface FileSystemLifecyclePolicy {
        transitionToIA?: string;
        transitionToPrimaryStorageClass?: string;
    }
}
export declare namespace eks {
    /**
     * A key-value pair to associate with a resource.
     */
    interface AddonTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The encryption configuration for the cluster
     */
    interface ClusterEncryptionConfig {
        /**
         * The encryption provider for the cluster.
         */
        provider?: outputs.eks.ClusterProvider;
        /**
         * Specifies the resources to be encrypted. The only supported value is "secrets".
         */
        resources?: string[];
    }
    /**
     * The Kubernetes network configuration for the cluster.
     */
    interface ClusterKubernetesNetworkConfig {
        /**
         * Ipv4 or Ipv6. You can only specify ipv6 for 1.21 and later clusters that use version 1.10.1 or later of the Amazon VPC CNI add-on
         */
        ipFamily?: enums.eks.ClusterKubernetesNetworkConfigIpFamily;
        /**
         * The CIDR block to assign Kubernetes service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC.
         */
        serviceIpv4Cidr?: string;
        /**
         * The CIDR block to assign Kubernetes service IP addresses from.
         */
        serviceIpv6Cidr?: string;
    }
    /**
     * Enable exporting the Kubernetes control plane logs for your cluster to CloudWatch Logs based on log types. By default, cluster control plane logs aren't exported to CloudWatch Logs.
     */
    interface ClusterLogging {
        /**
         * The cluster control plane logging configuration for your cluster.
         */
        clusterLogging?: outputs.eks.ClusterLogging;
    }
    /**
     * An object representing the Outpost configuration to use for AWS EKS outpost cluster.
     */
    interface ClusterOutpostConfig {
        /**
         * Specify the Instance type of the machines that should be used to create your cluster.
         */
        controlPlaneInstanceType: string;
        /**
         * Specify one or more Arn(s) of Outpost(s) on which you would like to create your cluster.
         */
        outpostArns: string[];
    }
    interface ClusterProvider {
        /**
         * Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric, created in the same region as the cluster, and if the KMS key was created in a different account, the user must have access to the KMS key.
         */
        keyArn?: string;
    }
    /**
     * An object representing the VPC configuration to use for an Amazon EKS cluster.
     */
    interface ClusterResourcesVpcConfig {
        /**
         * Set this value to true to enable private access for your cluster's Kubernetes API server endpoint. If you enable private access, Kubernetes API requests from within your cluster's VPC use the private VPC endpoint. The default value for this parameter is false, which disables private access for your Kubernetes API server. If you disable private access and you have nodes or AWS Fargate pods in the cluster, then ensure that publicAccessCidrs includes the necessary CIDR blocks for communication with the nodes or Fargate pods.
         */
        endpointPrivateAccess?: boolean;
        /**
         * Set this value to false to disable public access to your cluster's Kubernetes API server endpoint. If you disable public access, your cluster's Kubernetes API server can only receive requests from within the cluster VPC. The default value for this parameter is true, which enables public access for your Kubernetes API server.
         */
        endpointPublicAccess?: boolean;
        /**
         * The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint. Communication to the endpoint from addresses outside of the CIDR blocks that you specify is denied. The default value is 0.0.0.0/0. If you've disabled private endpoint access and you have nodes or AWS Fargate pods in the cluster, then ensure that you specify the necessary CIDR blocks.
         */
        publicAccessCidrs?: string[];
        /**
         * Specify one or more security groups for the cross-account elastic network interfaces that Amazon EKS creates to use to allow communication between your worker nodes and the Kubernetes control plane. If you don't specify a security group, the default security group for your VPC is used.
         */
        securityGroupIds?: string[];
        /**
         * Specify subnets for your Amazon EKS nodes. Amazon EKS creates cross-account elastic network interfaces in these subnets to allow communication between your nodes and the Kubernetes control plane.
         */
        subnetIds: string[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ClusterTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a pod.
     */
    interface FargateProfileLabel {
        /**
         * The key name of the label.
         */
        key: string;
        /**
         * The value for the label.
         */
        value: string;
    }
    interface FargateProfileSelector {
        labels?: outputs.eks.FargateProfileLabel[];
        namespace: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface FargateProfileTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * An object representing an OpenID Connect (OIDC) configuration.
     */
    interface IdentityProviderConfigOidcIdentityProviderConfig {
        /**
         * This is also known as audience. The ID for the client application that makes authentication requests to the OpenID identity provider.
         */
        clientId: string;
        /**
         * The JWT claim that the provider uses to return your groups.
         */
        groupsClaim?: string;
        /**
         * The prefix that is prepended to group claims to prevent clashes with existing names (such as system: groups).
         */
        groupsPrefix?: string;
        /**
         * The URL of the OpenID identity provider that allows the API server to discover public signing keys for verifying tokens.
         */
        issuerUrl: string;
        requiredClaims?: outputs.eks.IdentityProviderConfigRequiredClaim[];
        /**
         * The JSON Web Token (JWT) claim to use as the username. The default is sub, which is expected to be a unique identifier of the end user. You can choose other claims, such as email or name, depending on the OpenID identity provider. Claims other than email are prefixed with the issuer URL to prevent naming clashes with other plug-ins.
         */
        usernameClaim?: string;
        /**
         * The prefix that is prepended to username claims to prevent clashes with existing names. If you do not provide this field, and username is a value other than email, the prefix defaults to issuerurl#. You can use the value - to disable all prefixing.
         */
        usernamePrefix?: string;
    }
    /**
     * The key value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.
     */
    interface IdentityProviderConfigRequiredClaim {
        /**
         * The key of the requiredClaims.
         */
        key: string;
        /**
         * The value for the requiredClaims.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface IdentityProviderConfigTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * An object representing a launch template specification for AWS EKS Nodegroup.
     */
    interface NodegroupLaunchTemplateSpecification {
        id?: string;
        name?: string;
        version?: string;
    }
    /**
     * An object representing a remote access configuration specification for AWS EKS Nodegroup.
     */
    interface NodegroupRemoteAccess {
        ec2SshKey: string;
        sourceSecurityGroups?: string[];
    }
    /**
     * An object representing a auto scaling group specification for AWS EKS Nodegroup.
     */
    interface NodegroupScalingConfig {
        desiredSize?: number;
        maxSize?: number;
        minSize?: number;
    }
    /**
     * An object representing a Taint specification for AWS EKS Nodegroup.
     */
    interface NodegroupTaint {
        effect?: string;
        key?: string;
        value?: string;
    }
    /**
     * The node group update configuration.
     */
    interface NodegroupUpdateConfig {
        /**
         * The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. This value or maxUnavailablePercentage is required to have a value.The maximum number is 100.
         */
        maxUnavailable?: number;
        /**
         * The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or maxUnavailable is required to have a value.
         */
        maxUnavailablePercentage?: number;
    }
}
export declare namespace elasticache {
    interface CacheClusterCloudWatchLogsDestinationDetails {
        logGroup: string;
    }
    interface CacheClusterDestinationDetails {
        cloudWatchLogsDetails?: outputs.elasticache.CacheClusterCloudWatchLogsDestinationDetails;
        kinesisFirehoseDetails?: outputs.elasticache.CacheClusterKinesisFirehoseDestinationDetails;
    }
    interface CacheClusterKinesisFirehoseDestinationDetails {
        deliveryStream: string;
    }
    interface CacheClusterLogDeliveryConfigurationRequest {
        destinationDetails: outputs.elasticache.CacheClusterDestinationDetails;
        destinationType: string;
        logFormat: string;
        logType: string;
    }
    interface CacheClusterTag {
        key: string;
        value: string;
    }
    interface GlobalReplicationGroupMember {
        /**
         * Regionally unique identifier for the member i.e. ReplicationGroupId.
         */
        replicationGroupId?: string;
        /**
         * The AWS region of the Global Datastore member.
         */
        replicationGroupRegion?: string;
        /**
         * Indicates the role of the member, primary or secondary.
         */
        role?: enums.elasticache.GlobalReplicationGroupMemberRole;
    }
    interface GlobalReplicationGroupRegionalConfiguration {
        /**
         * The replication group id of the Global Datastore member.
         */
        replicationGroupId?: string;
        /**
         * The AWS region of the Global Datastore member.
         */
        replicationGroupRegion?: string;
        /**
         * A list of PreferredAvailabilityZones objects that specifies the configuration of a node group in the resharded cluster.
         */
        reshardingConfigurations?: outputs.elasticache.GlobalReplicationGroupReshardingConfiguration[];
    }
    interface GlobalReplicationGroupReshardingConfiguration {
        /**
         * Unique identifier for the Node Group. This is either auto-generated by ElastiCache (4-digit id) or a user supplied id.
         */
        nodeGroupId?: string;
        /**
         * A list of preferred availability zones for the nodes of new node groups.
         */
        preferredAvailabilityZones?: string[];
    }
    interface ParameterGroupTag {
        key: string;
        value: string;
    }
    interface ReplicationGroupCloudWatchLogsDestinationDetails {
        logGroup: string;
    }
    interface ReplicationGroupDestinationDetails {
        cloudWatchLogsDetails?: outputs.elasticache.ReplicationGroupCloudWatchLogsDestinationDetails;
        kinesisFirehoseDetails?: outputs.elasticache.ReplicationGroupKinesisFirehoseDestinationDetails;
    }
    interface ReplicationGroupKinesisFirehoseDestinationDetails {
        deliveryStream: string;
    }
    interface ReplicationGroupLogDeliveryConfigurationRequest {
        destinationDetails: outputs.elasticache.ReplicationGroupDestinationDetails;
        destinationType: string;
        logFormat: string;
        logType: string;
    }
    interface ReplicationGroupNodeGroupConfiguration {
        nodeGroupId?: string;
        primaryAvailabilityZone?: string;
        replicaAvailabilityZones?: string[];
        replicaCount?: number;
        slots?: string;
    }
    interface ReplicationGroupTag {
        key: string;
        value: string;
    }
    interface SecurityGroupTag {
        key: string;
        value: string;
    }
    /**
     * A tag that can be added to an ElastiCache subnet group. Tags are composed of a Key/Value pair. You can use tags to categorize and track all your subnet groups. A tag with a null Value is permitted.
     */
    interface SubnetGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace elasticbeanstalk {
    interface ApplicationMaxAgeRule {
        /**
         * Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
         */
        deleteSourceFromS3?: boolean;
        /**
         * Specify true to apply the rule, or false to disable it.
         */
        enabled?: boolean;
        /**
         * Specify the number of days to retain an application versions.
         */
        maxAgeInDays?: number;
    }
    interface ApplicationMaxCountRule {
        /**
         * Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
         */
        deleteSourceFromS3?: boolean;
        /**
         * Specify true to apply the rule, or false to disable it.
         */
        enabled?: boolean;
        /**
         * Specify the maximum number of application versions to retain.
         */
        maxCount?: number;
    }
    interface ApplicationResourceLifecycleConfig {
        /**
         * The ARN of an IAM service role that Elastic Beanstalk has permission to assume. The ServiceRole property is required the first time that you provide a ResourceLifecycleConfig for the application. After you provide it once, Elastic Beanstalk persists the Service Role with the application, and you don't need to specify it again. You can, however, specify it in subsequent updates to change the Service Role to another value.
         */
        serviceRole?: string;
        /**
         * Defines lifecycle settings for application versions.
         */
        versionLifecycleConfig?: outputs.elasticbeanstalk.ApplicationVersionLifecycleConfig;
    }
    interface ApplicationVersionLifecycleConfig {
        /**
         * Specify a max age rule to restrict the length of time that application versions are retained for an application.
         */
        maxAgeRule?: outputs.elasticbeanstalk.ApplicationMaxAgeRule;
        /**
         * Specify a max count rule to restrict the number of application versions that are retained for an application.
         */
        maxCountRule?: outputs.elasticbeanstalk.ApplicationMaxCountRule;
    }
    interface ApplicationVersionSourceBundle {
        /**
         * The Amazon S3 bucket where the data is located.
         */
        s3Bucket: string;
        /**
         * The Amazon S3 key where the data is located.
         */
        s3Key: string;
    }
    interface ConfigurationTemplateConfigurationOptionSetting {
        namespace: string;
        optionName: string;
        resourceName?: string;
        value?: string;
    }
    interface ConfigurationTemplateSourceConfiguration {
        applicationName: string;
        templateName: string;
    }
    interface EnvironmentOptionSetting {
        namespace: string;
        optionName: string;
        resourceName?: string;
        value?: string;
    }
    interface EnvironmentTag {
        key: string;
        value: string;
    }
    interface EnvironmentTier {
        name?: string;
        type?: string;
        version?: string;
    }
}
export declare namespace elasticloadbalancing {
    interface LoadBalancerAccessLoggingPolicy {
        emitInterval?: number;
        enabled: boolean;
        s3BucketName: string;
        s3BucketPrefix?: string;
    }
    interface LoadBalancerAppCookieStickinessPolicy {
        cookieName: string;
        policyName: string;
    }
    interface LoadBalancerConnectionDrainingPolicy {
        enabled: boolean;
        timeout?: number;
    }
    interface LoadBalancerConnectionSettings {
        idleTimeout: number;
    }
    interface LoadBalancerHealthCheck {
        healthyThreshold: string;
        interval: string;
        target: string;
        timeout: string;
        unhealthyThreshold: string;
    }
    interface LoadBalancerLBCookieStickinessPolicy {
        cookieExpirationPeriod?: string;
        policyName?: string;
    }
    interface LoadBalancerListeners {
        instancePort: string;
        instanceProtocol?: string;
        loadBalancerPort: string;
        policyNames?: string[];
        protocol: string;
        sSLCertificateId?: string;
    }
    interface LoadBalancerPolicies {
        attributes: any[];
        instancePorts?: string[];
        loadBalancerPorts?: string[];
        policyName: string;
        policyType: string;
    }
    interface LoadBalancerTag {
        key: string;
        value: string;
    }
}
export declare namespace elasticloadbalancingv2 {
    interface ListenerAction {
        authenticateCognitoConfig?: outputs.elasticloadbalancingv2.ListenerAuthenticateCognitoConfig;
        authenticateOidcConfig?: outputs.elasticloadbalancingv2.ListenerAuthenticateOidcConfig;
        fixedResponseConfig?: outputs.elasticloadbalancingv2.ListenerFixedResponseConfig;
        forwardConfig?: outputs.elasticloadbalancingv2.ListenerForwardConfig;
        order?: number;
        redirectConfig?: outputs.elasticloadbalancingv2.ListenerRedirectConfig;
        targetGroupArn?: string;
        type: string;
    }
    interface ListenerAuthenticateCognitoConfig {
        authenticationRequestExtraParams?: any;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: string;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }
    interface ListenerAuthenticateOidcConfig {
        authenticationRequestExtraParams?: any;
        authorizationEndpoint: string;
        clientId: string;
        clientSecret?: string;
        issuer: string;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: string;
        tokenEndpoint: string;
        useExistingClientSecret?: boolean;
        userInfoEndpoint: string;
    }
    interface ListenerCertificate {
        certificateArn?: string;
    }
    interface ListenerCertificateCertificate {
        certificateArn?: string;
    }
    interface ListenerFixedResponseConfig {
        contentType?: string;
        messageBody?: string;
        statusCode: string;
    }
    interface ListenerForwardConfig {
        targetGroupStickinessConfig?: outputs.elasticloadbalancingv2.ListenerTargetGroupStickinessConfig;
        targetGroups?: outputs.elasticloadbalancingv2.ListenerTargetGroupTuple[];
    }
    interface ListenerRedirectConfig {
        host?: string;
        path?: string;
        port?: string;
        protocol?: string;
        query?: string;
        statusCode: string;
    }
    interface ListenerRuleAction {
        authenticateCognitoConfig?: outputs.elasticloadbalancingv2.ListenerRuleAuthenticateCognitoConfig;
        authenticateOidcConfig?: outputs.elasticloadbalancingv2.ListenerRuleAuthenticateOidcConfig;
        fixedResponseConfig?: outputs.elasticloadbalancingv2.ListenerRuleFixedResponseConfig;
        forwardConfig?: outputs.elasticloadbalancingv2.ListenerRuleForwardConfig;
        order?: number;
        redirectConfig?: outputs.elasticloadbalancingv2.ListenerRuleRedirectConfig;
        targetGroupArn?: string;
        type: string;
    }
    interface ListenerRuleAuthenticateCognitoConfig {
        authenticationRequestExtraParams?: any;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: number;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }
    interface ListenerRuleAuthenticateOidcConfig {
        authenticationRequestExtraParams?: any;
        authorizationEndpoint: string;
        clientId: string;
        clientSecret?: string;
        issuer: string;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: number;
        tokenEndpoint: string;
        useExistingClientSecret?: boolean;
        userInfoEndpoint: string;
    }
    interface ListenerRuleFixedResponseConfig {
        contentType?: string;
        messageBody?: string;
        statusCode: string;
    }
    interface ListenerRuleForwardConfig {
        targetGroupStickinessConfig?: outputs.elasticloadbalancingv2.ListenerRuleTargetGroupStickinessConfig;
        targetGroups?: outputs.elasticloadbalancingv2.ListenerRuleTargetGroupTuple[];
    }
    interface ListenerRuleHostHeaderConfig {
        values?: string[];
    }
    interface ListenerRuleHttpHeaderConfig {
        httpHeaderName?: string;
        values?: string[];
    }
    interface ListenerRuleHttpRequestMethodConfig {
        values?: string[];
    }
    interface ListenerRulePathPatternConfig {
        values?: string[];
    }
    interface ListenerRuleQueryStringConfig {
        values?: outputs.elasticloadbalancingv2.ListenerRuleQueryStringKeyValue[];
    }
    interface ListenerRuleQueryStringKeyValue {
        key?: string;
        value?: string;
    }
    interface ListenerRuleRedirectConfig {
        host?: string;
        path?: string;
        port?: string;
        protocol?: string;
        query?: string;
        statusCode: string;
    }
    interface ListenerRuleRuleCondition {
        field?: string;
        hostHeaderConfig?: outputs.elasticloadbalancingv2.ListenerRuleHostHeaderConfig;
        httpHeaderConfig?: outputs.elasticloadbalancingv2.ListenerRuleHttpHeaderConfig;
        httpRequestMethodConfig?: outputs.elasticloadbalancingv2.ListenerRuleHttpRequestMethodConfig;
        pathPatternConfig?: outputs.elasticloadbalancingv2.ListenerRulePathPatternConfig;
        queryStringConfig?: outputs.elasticloadbalancingv2.ListenerRuleQueryStringConfig;
        sourceIpConfig?: outputs.elasticloadbalancingv2.ListenerRuleSourceIpConfig;
        values?: string[];
    }
    interface ListenerRuleSourceIpConfig {
        values?: string[];
    }
    interface ListenerRuleTargetGroupStickinessConfig {
        durationSeconds?: number;
        enabled?: boolean;
    }
    interface ListenerRuleTargetGroupTuple {
        targetGroupArn?: string;
        weight?: number;
    }
    interface ListenerTargetGroupStickinessConfig {
        durationSeconds?: number;
        enabled?: boolean;
    }
    interface ListenerTargetGroupTuple {
        targetGroupArn?: string;
        weight?: number;
    }
    interface LoadBalancerAttribute {
        key?: string;
        value?: string;
    }
    interface LoadBalancerSubnetMapping {
        allocationId?: string;
        iPv6Address?: string;
        privateIPv4Address?: string;
        subnetId: string;
    }
    interface LoadBalancerTag {
        key: string;
        value: string;
    }
    interface TargetGroupAttribute {
        key?: string;
        value?: string;
    }
    interface TargetGroupMatcher {
        grpcCode?: string;
        httpCode?: string;
    }
    interface TargetGroupTag {
        key: string;
        value: string;
    }
    interface TargetGroupTargetDescription {
        availabilityZone?: string;
        id: string;
        port?: number;
    }
}
export declare namespace elasticsearch {
    interface DomainAdvancedSecurityOptionsInput {
        anonymousAuthEnabled?: boolean;
        enabled?: boolean;
        internalUserDatabaseEnabled?: boolean;
        masterUserOptions?: outputs.elasticsearch.DomainMasterUserOptions;
    }
    interface DomainCognitoOptions {
        enabled?: boolean;
        identityPoolId?: string;
        roleArn?: string;
        userPoolId?: string;
    }
    interface DomainColdStorageOptions {
        enabled?: boolean;
    }
    interface DomainEBSOptions {
        eBSEnabled?: boolean;
        iops?: number;
        volumeSize?: number;
        volumeType?: string;
    }
    interface DomainElasticsearchClusterConfig {
        coldStorageOptions?: outputs.elasticsearch.DomainColdStorageOptions;
        dedicatedMasterCount?: number;
        dedicatedMasterEnabled?: boolean;
        dedicatedMasterType?: string;
        instanceCount?: number;
        instanceType?: string;
        warmCount?: number;
        warmEnabled?: boolean;
        warmType?: string;
        zoneAwarenessConfig?: outputs.elasticsearch.DomainZoneAwarenessConfig;
        zoneAwarenessEnabled?: boolean;
    }
    interface DomainEncryptionAtRestOptions {
        enabled?: boolean;
        kmsKeyId?: string;
    }
    interface DomainEndpointOptions {
        customEndpoint?: string;
        customEndpointCertificateArn?: string;
        customEndpointEnabled?: boolean;
        enforceHTTPS?: boolean;
        tLSSecurityPolicy?: string;
    }
    interface DomainMasterUserOptions {
        masterUserARN?: string;
        masterUserName?: string;
        masterUserPassword?: string;
    }
    interface DomainNodeToNodeEncryptionOptions {
        enabled?: boolean;
    }
    interface DomainSnapshotOptions {
        automatedSnapshotStartHour?: number;
    }
    interface DomainTag {
        key: string;
        value: string;
    }
    interface DomainVPCOptions {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }
    interface DomainZoneAwarenessConfig {
        availabilityZoneCount?: number;
    }
}
export declare namespace emr {
    interface ClusterApplication {
        additionalInfo?: any;
        args?: string[];
        name?: string;
        version?: string;
    }
    interface ClusterAutoScalingPolicy {
        constraints: outputs.emr.ClusterScalingConstraints;
        rules: outputs.emr.ClusterScalingRule[];
    }
    interface ClusterAutoTerminationPolicy {
        idleTimeout?: number;
    }
    interface ClusterBootstrapActionConfig {
        name: string;
        scriptBootstrapAction: outputs.emr.ClusterScriptBootstrapActionConfig;
    }
    interface ClusterCloudWatchAlarmDefinition {
        comparisonOperator: string;
        dimensions?: outputs.emr.ClusterMetricDimension[];
        evaluationPeriods?: number;
        metricName: string;
        namespace?: string;
        period: number;
        statistic?: string;
        threshold: number;
        unit?: string;
    }
    interface ClusterComputeLimits {
        maximumCapacityUnits: number;
        maximumCoreCapacityUnits?: number;
        maximumOnDemandCapacityUnits?: number;
        minimumCapacityUnits: number;
        unitType: string;
    }
    interface ClusterConfiguration {
        classification?: string;
        configurationProperties?: any;
        configurations?: outputs.emr.ClusterConfiguration[];
    }
    interface ClusterEbsBlockDeviceConfig {
        volumeSpecification: outputs.emr.ClusterVolumeSpecification;
        volumesPerInstance?: number;
    }
    interface ClusterEbsConfiguration {
        ebsBlockDeviceConfigs?: outputs.emr.ClusterEbsBlockDeviceConfig[];
        ebsOptimized?: boolean;
    }
    interface ClusterHadoopJarStepConfig {
        args?: string[];
        jar: string;
        mainClass?: string;
        stepProperties?: outputs.emr.ClusterKeyValue[];
    }
    interface ClusterInstanceFleetConfig {
        instanceTypeConfigs?: outputs.emr.ClusterInstanceTypeConfig[];
        launchSpecifications?: outputs.emr.ClusterInstanceFleetProvisioningSpecifications;
        name?: string;
        targetOnDemandCapacity?: number;
        targetSpotCapacity?: number;
    }
    interface ClusterInstanceFleetProvisioningSpecifications {
        onDemandSpecification?: outputs.emr.ClusterOnDemandProvisioningSpecification;
        spotSpecification?: outputs.emr.ClusterSpotProvisioningSpecification;
    }
    interface ClusterInstanceGroupConfig {
        autoScalingPolicy?: outputs.emr.ClusterAutoScalingPolicy;
        bidPrice?: string;
        configurations?: outputs.emr.ClusterConfiguration[];
        customAmiId?: string;
        ebsConfiguration?: outputs.emr.ClusterEbsConfiguration;
        instanceCount: number;
        instanceType: string;
        market?: string;
        name?: string;
    }
    interface ClusterInstanceTypeConfig {
        bidPrice?: string;
        bidPriceAsPercentageOfOnDemandPrice?: number;
        configurations?: outputs.emr.ClusterConfiguration[];
        customAmiId?: string;
        ebsConfiguration?: outputs.emr.ClusterEbsConfiguration;
        instanceType: string;
        weightedCapacity?: number;
    }
    interface ClusterJobFlowInstancesConfig {
        additionalMasterSecurityGroups?: string[];
        additionalSlaveSecurityGroups?: string[];
        coreInstanceFleet?: outputs.emr.ClusterInstanceFleetConfig;
        coreInstanceGroup?: outputs.emr.ClusterInstanceGroupConfig;
        ec2KeyName?: string;
        ec2SubnetId?: string;
        ec2SubnetIds?: string[];
        emrManagedMasterSecurityGroup?: string;
        emrManagedSlaveSecurityGroup?: string;
        hadoopVersion?: string;
        keepJobFlowAliveWhenNoSteps?: boolean;
        masterInstanceFleet?: outputs.emr.ClusterInstanceFleetConfig;
        masterInstanceGroup?: outputs.emr.ClusterInstanceGroupConfig;
        placement?: outputs.emr.ClusterPlacementType;
        serviceAccessSecurityGroup?: string;
        taskInstanceFleets?: outputs.emr.ClusterInstanceFleetConfig[];
        taskInstanceGroups?: outputs.emr.ClusterInstanceGroupConfig[];
        terminationProtected?: boolean;
    }
    interface ClusterKerberosAttributes {
        aDDomainJoinPassword?: string;
        aDDomainJoinUser?: string;
        crossRealmTrustPrincipalPassword?: string;
        kdcAdminPassword: string;
        realm: string;
    }
    interface ClusterKeyValue {
        key?: string;
        value?: string;
    }
    interface ClusterManagedScalingPolicy {
        computeLimits?: outputs.emr.ClusterComputeLimits;
    }
    interface ClusterMetricDimension {
        key: string;
        value: string;
    }
    interface ClusterOnDemandProvisioningSpecification {
        allocationStrategy: string;
    }
    interface ClusterPlacementType {
        availabilityZone: string;
    }
    interface ClusterScalingAction {
        market?: string;
        simpleScalingPolicyConfiguration: outputs.emr.ClusterSimpleScalingPolicyConfiguration;
    }
    interface ClusterScalingConstraints {
        maxCapacity: number;
        minCapacity: number;
    }
    interface ClusterScalingRule {
        action: outputs.emr.ClusterScalingAction;
        description?: string;
        name: string;
        trigger: outputs.emr.ClusterScalingTrigger;
    }
    interface ClusterScalingTrigger {
        cloudWatchAlarmDefinition: outputs.emr.ClusterCloudWatchAlarmDefinition;
    }
    interface ClusterScriptBootstrapActionConfig {
        args?: string[];
        path: string;
    }
    interface ClusterSimpleScalingPolicyConfiguration {
        adjustmentType?: string;
        coolDown?: number;
        scalingAdjustment: number;
    }
    interface ClusterSpotProvisioningSpecification {
        allocationStrategy?: string;
        blockDurationMinutes?: number;
        timeoutAction: string;
        timeoutDurationMinutes: number;
    }
    interface ClusterStepConfig {
        actionOnFailure?: string;
        hadoopJarStep: outputs.emr.ClusterHadoopJarStepConfig;
        name: string;
    }
    interface ClusterTag {
        key: string;
        value: string;
    }
    interface ClusterVolumeSpecification {
        iops?: number;
        sizeInGB: number;
        volumeType: string;
    }
    interface InstanceFleetConfigConfiguration {
        classification?: string;
        configurationProperties?: any;
        configurations?: outputs.emr.InstanceFleetConfigConfiguration[];
    }
    interface InstanceFleetConfigEbsBlockDeviceConfig {
        volumeSpecification: outputs.emr.InstanceFleetConfigVolumeSpecification;
        volumesPerInstance?: number;
    }
    interface InstanceFleetConfigEbsConfiguration {
        ebsBlockDeviceConfigs?: outputs.emr.InstanceFleetConfigEbsBlockDeviceConfig[];
        ebsOptimized?: boolean;
    }
    interface InstanceFleetConfigInstanceFleetProvisioningSpecifications {
        onDemandSpecification?: outputs.emr.InstanceFleetConfigOnDemandProvisioningSpecification;
        spotSpecification?: outputs.emr.InstanceFleetConfigSpotProvisioningSpecification;
    }
    interface InstanceFleetConfigInstanceTypeConfig {
        bidPrice?: string;
        bidPriceAsPercentageOfOnDemandPrice?: number;
        configurations?: outputs.emr.InstanceFleetConfigConfiguration[];
        customAmiId?: string;
        ebsConfiguration?: outputs.emr.InstanceFleetConfigEbsConfiguration;
        instanceType: string;
        weightedCapacity?: number;
    }
    interface InstanceFleetConfigOnDemandProvisioningSpecification {
        allocationStrategy: string;
    }
    interface InstanceFleetConfigSpotProvisioningSpecification {
        allocationStrategy?: string;
        blockDurationMinutes?: number;
        timeoutAction: string;
        timeoutDurationMinutes: number;
    }
    interface InstanceFleetConfigVolumeSpecification {
        iops?: number;
        sizeInGB: number;
        volumeType: string;
    }
    interface InstanceGroupConfigAutoScalingPolicy {
        constraints: outputs.emr.InstanceGroupConfigScalingConstraints;
        rules: outputs.emr.InstanceGroupConfigScalingRule[];
    }
    interface InstanceGroupConfigCloudWatchAlarmDefinition {
        comparisonOperator: string;
        dimensions?: outputs.emr.InstanceGroupConfigMetricDimension[];
        evaluationPeriods?: number;
        metricName: string;
        namespace?: string;
        period: number;
        statistic?: string;
        threshold: number;
        unit?: string;
    }
    interface InstanceGroupConfigConfiguration {
        classification?: string;
        configurationProperties?: any;
        configurations?: outputs.emr.InstanceGroupConfigConfiguration[];
    }
    interface InstanceGroupConfigEbsBlockDeviceConfig {
        volumeSpecification: outputs.emr.InstanceGroupConfigVolumeSpecification;
        volumesPerInstance?: number;
    }
    interface InstanceGroupConfigEbsConfiguration {
        ebsBlockDeviceConfigs?: outputs.emr.InstanceGroupConfigEbsBlockDeviceConfig[];
        ebsOptimized?: boolean;
    }
    interface InstanceGroupConfigMetricDimension {
        key: string;
        value: string;
    }
    interface InstanceGroupConfigScalingAction {
        market?: string;
        simpleScalingPolicyConfiguration: outputs.emr.InstanceGroupConfigSimpleScalingPolicyConfiguration;
    }
    interface InstanceGroupConfigScalingConstraints {
        maxCapacity: number;
        minCapacity: number;
    }
    interface InstanceGroupConfigScalingRule {
        action: outputs.emr.InstanceGroupConfigScalingAction;
        description?: string;
        name: string;
        trigger: outputs.emr.InstanceGroupConfigScalingTrigger;
    }
    interface InstanceGroupConfigScalingTrigger {
        cloudWatchAlarmDefinition: outputs.emr.InstanceGroupConfigCloudWatchAlarmDefinition;
    }
    interface InstanceGroupConfigSimpleScalingPolicyConfiguration {
        adjustmentType?: string;
        coolDown?: number;
        scalingAdjustment: number;
    }
    interface InstanceGroupConfigVolumeSpecification {
        iops?: number;
        sizeInGB: number;
        volumeType: string;
    }
    interface StepHadoopJarStepConfig {
        args?: string[];
        jar: string;
        mainClass?: string;
        stepProperties?: outputs.emr.StepKeyValue[];
    }
    interface StepKeyValue {
        key?: string;
        value?: string;
    }
    /**
     * An arbitrary set of tags (key-value pairs) for this EMR Studio.
     */
    interface StudioTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace emrcontainers {
    interface VirtualClusterContainerInfo {
        eksInfo: outputs.emrcontainers.VirtualClusterEksInfo;
    }
    interface VirtualClusterContainerProvider {
        /**
         * The ID of the container cluster
         */
        id: string;
        info: outputs.emrcontainers.VirtualClusterContainerInfo;
        /**
         * The type of the container provider
         */
        type: string;
    }
    interface VirtualClusterEksInfo {
        namespace: string;
    }
    /**
     * An arbitrary set of tags (key-value pairs) for this virtual cluster.
     */
    interface VirtualClusterTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace emrserverless {
    /**
     * Configuration for Auto Start of Application
     */
    interface ApplicationAutoStartConfiguration {
        /**
         * If set to true, the Application will automatically start. Defaults to true.
         */
        enabled?: boolean;
    }
    /**
     * Configuration for Auto Stop of Application
     */
    interface ApplicationAutoStopConfiguration {
        /**
         * If set to true, the Application will automatically stop after being idle. Defaults to true.
         */
        enabled?: boolean;
        /**
         * The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
         */
        idleTimeoutMinutes?: number;
    }
    interface ApplicationInitialCapacityConfig {
        workerConfiguration: outputs.emrserverless.ApplicationWorkerConfiguration;
        /**
         * Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
         */
        workerCount: number;
    }
    interface ApplicationInitialCapacityConfigKeyValuePair {
        /**
         * Worker type for an analytics framework.
         */
        key: string;
        value: outputs.emrserverless.ApplicationInitialCapacityConfig;
    }
    interface ApplicationMaximumAllowedResources {
        /**
         * Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
         */
        cpu: string;
        /**
         * Per worker Disk resource. GB is the only supported unit and specifying GB is optional
         */
        disk?: string;
        /**
         * Per worker memory resource. GB is the only supported unit and specifying GB is optional.
         */
        memory: string;
    }
    interface ApplicationNetworkConfiguration {
        /**
         * The ID of the security groups in the VPC to which you want to connect your job or application.
         */
        securityGroupIds?: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect your job or application.
         */
        subnetIds?: string[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ApplicationTag {
        /**
         * The value for the tag. You can specify a value that is 1 to 128 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ApplicationWorkerConfiguration {
        /**
         * Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
         */
        cpu: string;
        /**
         * Per worker Disk resource. GB is the only supported unit and specifying GB is optional
         */
        disk?: string;
        /**
         * Per worker memory resource. GB is the only supported unit and specifying GB is optional.
         */
        memory: string;
    }
}
export declare namespace events {
    interface ConnectionApiKeyAuthParameters {
        apiKeyName: string;
        apiKeyValue: string;
    }
    interface ConnectionAuthParameters {
        apiKeyAuthParameters?: outputs.events.ConnectionApiKeyAuthParameters;
        basicAuthParameters?: outputs.events.ConnectionBasicAuthParameters;
        invocationHttpParameters?: outputs.events.ConnectionHttpParameters;
        oAuthParameters?: outputs.events.ConnectionOAuthParameters;
    }
    interface ConnectionBasicAuthParameters {
        password: string;
        username: string;
    }
    interface ConnectionClientParameters {
        clientID: string;
        clientSecret: string;
    }
    interface ConnectionHttpParameters {
        bodyParameters?: outputs.events.ConnectionParameter[];
        headerParameters?: outputs.events.ConnectionParameter[];
        queryStringParameters?: outputs.events.ConnectionParameter[];
    }
    interface ConnectionOAuthParameters {
        authorizationEndpoint: string;
        clientParameters: outputs.events.ConnectionClientParameters;
        httpMethod: enums.events.ConnectionOAuthParametersHttpMethod;
        oAuthHttpParameters?: outputs.events.ConnectionHttpParameters;
    }
    interface ConnectionParameter {
        isValueSecret?: boolean;
        key: string;
        value: string;
    }
    interface EndpointEventBus {
        eventBusArn: string;
    }
    interface EndpointFailoverConfig {
        primary: outputs.events.EndpointPrimary;
        secondary: outputs.events.EndpointSecondary;
    }
    interface EndpointPrimary {
        healthCheck: string;
    }
    interface EndpointReplicationConfig {
        state: enums.events.EndpointReplicationState;
    }
    interface EndpointRoutingConfig {
        failoverConfig: outputs.events.EndpointFailoverConfig;
    }
    interface EndpointSecondary {
        route: string;
    }
    interface EventBusPolicyCondition {
        key?: string;
        type?: string;
        value?: string;
    }
    interface EventBusTagEntry {
        key: string;
        value: string;
    }
    interface RuleAwsVpcConfiguration {
        assignPublicIp?: string;
        securityGroups?: string[];
        subnets: string[];
    }
    interface RuleBatchArrayProperties {
        size?: number;
    }
    interface RuleBatchParameters {
        arrayProperties?: outputs.events.RuleBatchArrayProperties;
        jobDefinition: string;
        jobName: string;
        retryStrategy?: outputs.events.RuleBatchRetryStrategy;
    }
    interface RuleBatchRetryStrategy {
        attempts?: number;
    }
    interface RuleCapacityProviderStrategyItem {
        base?: number;
        capacityProvider: string;
        weight?: number;
    }
    interface RuleDeadLetterConfig {
        arn?: string;
    }
    interface RuleEcsParameters {
        capacityProviderStrategy?: outputs.events.RuleCapacityProviderStrategyItem[];
        enableECSManagedTags?: boolean;
        enableExecuteCommand?: boolean;
        group?: string;
        launchType?: string;
        networkConfiguration?: outputs.events.RuleNetworkConfiguration;
        placementConstraints?: outputs.events.RulePlacementConstraint[];
        placementStrategies?: outputs.events.RulePlacementStrategy[];
        platformVersion?: string;
        propagateTags?: string;
        referenceId?: string;
        tagList?: outputs.events.RuleTag[];
        taskCount?: number;
        taskDefinitionArn: string;
    }
    interface RuleHttpParameters {
        headerParameters?: any;
        pathParameterValues?: string[];
        queryStringParameters?: any;
    }
    interface RuleInputTransformer {
        inputPathsMap?: any;
        inputTemplate: string;
    }
    interface RuleKinesisParameters {
        partitionKeyPath: string;
    }
    interface RuleNetworkConfiguration {
        awsVpcConfiguration?: outputs.events.RuleAwsVpcConfiguration;
    }
    interface RulePlacementConstraint {
        expression?: string;
        type?: string;
    }
    interface RulePlacementStrategy {
        field?: string;
        type?: string;
    }
    interface RuleRedshiftDataParameters {
        database: string;
        dbUser?: string;
        secretManagerArn?: string;
        sql: string;
        statementName?: string;
        withEvent?: boolean;
    }
    interface RuleRetryPolicy {
        maximumEventAgeInSeconds?: number;
        maximumRetryAttempts?: number;
    }
    interface RuleRunCommandParameters {
        runCommandTargets: outputs.events.RuleRunCommandTarget[];
    }
    interface RuleRunCommandTarget {
        key: string;
        values: string[];
    }
    interface RuleSageMakerPipelineParameter {
        name: string;
        value: string;
    }
    interface RuleSageMakerPipelineParameters {
        pipelineParameterList?: outputs.events.RuleSageMakerPipelineParameter[];
    }
    interface RuleSqsParameters {
        messageGroupId: string;
    }
    interface RuleTag {
        key?: string;
        value?: string;
    }
    interface RuleTarget {
        arn: string;
        batchParameters?: outputs.events.RuleBatchParameters;
        deadLetterConfig?: outputs.events.RuleDeadLetterConfig;
        ecsParameters?: outputs.events.RuleEcsParameters;
        httpParameters?: outputs.events.RuleHttpParameters;
        id: string;
        input?: string;
        inputPath?: string;
        inputTransformer?: outputs.events.RuleInputTransformer;
        kinesisParameters?: outputs.events.RuleKinesisParameters;
        redshiftDataParameters?: outputs.events.RuleRedshiftDataParameters;
        retryPolicy?: outputs.events.RuleRetryPolicy;
        roleArn?: string;
        runCommandParameters?: outputs.events.RuleRunCommandParameters;
        sageMakerPipelineParameters?: outputs.events.RuleSageMakerPipelineParameters;
        sqsParameters?: outputs.events.RuleSqsParameters;
    }
}
export declare namespace eventschemas {
    interface DiscovererTagsEntry {
        key: string;
        value: string;
    }
    interface RegistryTagsEntry {
        key: string;
        value: string;
    }
    interface SchemaTagsEntry {
        key: string;
        value: string;
    }
}
export declare namespace evidently {
    interface ExperimentMetricGoalObject {
        desiredChange: enums.evidently.ExperimentMetricGoalObjectDesiredChange;
        /**
         * The JSON path to reference the entity id in the event.
         */
        entityIdKey: string;
        /**
         * Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
         */
        eventPattern: string;
        metricName: string;
        unitLabel?: string;
        /**
         * The JSON path to reference the numerical metric value in the event.
         */
        valueKey: string;
    }
    interface ExperimentOnlineAbConfigObject {
        controlTreatmentName?: string;
        treatmentWeights?: outputs.evidently.ExperimentTreatmentToWeight[];
    }
    interface ExperimentRunningStatusObject {
        /**
         * Provide the analysis Completion time for an experiment
         */
        analysisCompleteTime?: string;
        /**
         * Provide CANCELLED or COMPLETED desired state when stopping an experiment
         */
        desiredState?: string;
        /**
         * Reason is a required input for stopping the experiment
         */
        reason?: string;
        /**
         * Provide START or STOP action to apply on an experiment
         */
        status?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ExperimentTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ExperimentTreatmentObject {
        description?: string;
        feature: string;
        treatmentName: string;
        variation: string;
    }
    interface ExperimentTreatmentToWeight {
        splitWeight: number;
        treatment: string;
    }
    interface FeatureEntityOverride {
        entityId?: string;
        variation?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface FeatureTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface FeatureVariationObject {
        booleanValue?: boolean;
        doubleValue?: number;
        longValue?: number;
        stringValue?: string;
        variationName?: string;
    }
    interface LaunchExecutionStatusObject {
        /**
         * Provide CANCELLED or COMPLETED as the launch desired state. Defaults to Completed if not provided.
         */
        desiredState?: string;
        /**
         * Provide a reason for stopping the launch. Defaults to empty if not provided.
         */
        reason?: string;
        /**
         * Provide START or STOP action to apply on a launch
         */
        status: string;
    }
    interface LaunchGroupObject {
        description?: string;
        feature: string;
        groupName: string;
        variation: string;
    }
    interface LaunchGroupToWeight {
        groupName: string;
        splitWeight: number;
    }
    interface LaunchMetricDefinitionObject {
        /**
         * The JSON path to reference the entity id in the event.
         */
        entityIdKey: string;
        /**
         * Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
         */
        eventPattern: string;
        metricName: string;
        unitLabel?: string;
        /**
         * The JSON path to reference the numerical metric value in the event.
         */
        valueKey: string;
    }
    interface LaunchSegmentOverride {
        evaluationOrder: number;
        segment: string;
        weights: outputs.evidently.LaunchGroupToWeight[];
    }
    interface LaunchStepConfig {
        groupWeights: outputs.evidently.LaunchGroupToWeight[];
        segmentOverrides?: outputs.evidently.LaunchSegmentOverride[];
        startTime: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LaunchTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ProjectAppConfigResourceObject {
        applicationId: string;
        environmentId: string;
    }
    /**
     * Destinations for data.
     */
    interface ProjectDataDeliveryObject {
        logGroup?: string;
        s3?: outputs.evidently.ProjectS3Destination;
    }
    interface ProjectS3Destination {
        bucketName: string;
        prefix?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ProjectTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface SegmentTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace finspace {
    /**
     * Additional parameters to identify Federation mode
     */
    interface EnvironmentFederationParameters {
        /**
         * SAML metadata URL to link with the Environment
         */
        applicationCallBackURL?: string;
        /**
         * Attribute map for SAML configuration
         */
        attributeMap?: any;
        /**
         * Federation provider name to link with the Environment
         */
        federationProviderName?: string;
        /**
         * SAML metadata URL to link with the Environment
         */
        federationURN?: string;
        /**
         * SAML metadata document to link the federation provider to the Environment
         */
        samlMetadataDocument?: string;
        /**
         * SAML metadata URL to link with the Environment
         */
        samlMetadataURL?: string;
    }
    /**
     * Parameters of the first Superuser for the FinSpace Environment
     */
    interface EnvironmentSuperuserParameters {
        /**
         * Email address
         */
        emailAddress?: string;
        /**
         * First name
         */
        firstName?: string;
        /**
         * Last name
         */
        lastName?: string;
    }
}
export declare namespace fis {
    /**
     * The actions for the experiment.
     */
    interface ExperimentTemplateActionMap {
    }
    interface ExperimentTemplateLogConfiguration {
        cloudWatchLogsConfiguration?: outputs.fis.ExperimentTemplateLogConfigurationCloudWatchLogsConfigurationProperties;
        logSchemaVersion: number;
        s3Configuration?: outputs.fis.ExperimentTemplateLogConfigurationS3ConfigurationProperties;
    }
    interface ExperimentTemplateLogConfigurationCloudWatchLogsConfigurationProperties {
        logGroupArn: string;
    }
    interface ExperimentTemplateLogConfigurationS3ConfigurationProperties {
        bucketName: string;
        prefix?: string;
    }
    interface ExperimentTemplateStopCondition {
        source: string;
        value?: string;
    }
    /**
     * The targets for the experiment.
     */
    interface ExperimentTemplateTargetMap {
    }
}
export declare namespace fms {
    /**
     * An FMS includeMap or excludeMap.
     */
    interface PolicyIEMap {
        aCCOUNT?: string[];
        oRGUNIT?: string[];
    }
    /**
     * Network firewall policy.
     */
    interface PolicyNetworkFirewallPolicy {
        firewallDeploymentModel: enums.fms.PolicyFirewallDeploymentModel;
    }
    /**
     * Firewall policy option.
     */
    interface PolicyOption {
        networkFirewallPolicy?: outputs.fms.PolicyNetworkFirewallPolicy;
        thirdPartyFirewallPolicy?: outputs.fms.PolicyThirdPartyFirewallPolicy;
    }
    /**
     * A resource tag.
     */
    interface PolicyResourceTag {
        key: string;
        value?: string;
    }
    /**
     * Firewall security service policy data.
     */
    interface PolicySecurityServicePolicyData {
        managedServiceData?: string;
        policyOption?: outputs.fms.PolicyOption;
        type: enums.fms.PolicyType;
    }
    /**
     * A policy tag.
     */
    interface PolicyTag {
        key: string;
        value: string;
    }
    /**
     * Third party firewall policy.
     */
    interface PolicyThirdPartyFirewallPolicy {
        firewallDeploymentModel: enums.fms.PolicyFirewallDeploymentModel;
    }
}
export declare namespace forecast {
    interface AttributesItemProperties {
        /**
         * Name of the dataset field
         */
        attributeName?: string;
        /**
         * Data type of the field
         */
        attributeType?: enums.forecast.DatasetAttributesItemPropertiesAttributeType;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DatasetGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface EncryptionConfigProperties {
        kmsKeyArn?: string;
        roleArn?: string;
    }
    interface SchemaProperties {
        attributes?: outputs.forecast.AttributesItemProperties[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface TagsItemProperties {
        key: string;
        value: string;
    }
}
export declare namespace frauddetector {
    interface DetectorEntityType {
        arn?: string;
        /**
         * The time when the entity type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the entity type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this entity type.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }
    interface DetectorEventType {
        /**
         * The ARN of the event type.
         */
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description of the event type.
         */
        description?: string;
        entityTypes?: outputs.frauddetector.DetectorEntityType[];
        eventVariables?: outputs.frauddetector.DetectorEventVariable[];
        inline?: boolean;
        labels?: outputs.frauddetector.DetectorLabel[];
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        /**
         * The name for the event type
         */
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }
    interface DetectorEventVariable {
        arn?: string;
        /**
         * The time when the event variable was created.
         */
        createdTime?: string;
        dataSource?: enums.frauddetector.DetectorEventVariableDataSource;
        dataType?: enums.frauddetector.DetectorEventVariableDataType;
        defaultValue?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event variable was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event variable.
         */
        tags?: outputs.frauddetector.DetectorTag[];
        variableType?: enums.frauddetector.DetectorEventVariableVariableType;
    }
    interface DetectorLabel {
        arn?: string;
        /**
         * The time when the label was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the label was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this label.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }
    /**
     * A model to associate with a detector.
     */
    interface DetectorModel {
        arn?: string;
    }
    interface DetectorOutcome {
        arn?: string;
        /**
         * The time when the outcome was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the outcome was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this outcome.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }
    interface DetectorRule {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        detectorId?: string;
        expression?: string;
        language?: enums.frauddetector.DetectorRuleLanguage;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        outcomes?: outputs.frauddetector.DetectorOutcome[];
        ruleId?: string;
        ruleVersion?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }
    interface DetectorTag {
        key: string;
        value: string;
    }
    interface EntityTypeTag {
        key: string;
        value: string;
    }
    interface EventTypeEntityType {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.EventTypeTag[];
    }
    interface EventTypeEventVariable {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        dataSource?: enums.frauddetector.EventTypeEventVariableDataSource;
        dataType?: enums.frauddetector.EventTypeEventVariableDataType;
        defaultValue?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.EventTypeTag[];
        variableType?: enums.frauddetector.EventTypeEventVariableVariableType;
    }
    interface EventTypeLabel {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.EventTypeTag[];
    }
    interface EventTypeTag {
        key: string;
        value: string;
    }
    interface LabelTag {
        key: string;
        value: string;
    }
    interface OutcomeTag {
        key: string;
        value: string;
    }
    interface VariableTag {
        key: string;
        value: string;
    }
}
export declare namespace fsx {
    /**
     * Specifies the type of updated objects (new, changed, deleted) that will be automatically exported from your file system to the linked S3 bucket.
     */
    interface DataRepositoryAssociationAutoExportPolicy {
        events: enums.fsx.DataRepositoryAssociationEventType[];
    }
    /**
     * Specifies the type of updated objects (new, changed, deleted) that will be automatically imported from the linked S3 bucket to your file system.
     */
    interface DataRepositoryAssociationAutoImportPolicy {
        events: enums.fsx.DataRepositoryAssociationEventType[];
    }
    /**
     * The configuration for an Amazon S3 data repository linked to an Amazon FSx Lustre file system with a data repository association. The configuration defines which file events (new, changed, or deleted files or directories) are automatically imported from the linked data repository to the file system or automatically exported from the file system to the data repository.
     */
    interface DataRepositoryAssociationS3 {
        autoExportPolicy?: outputs.fsx.DataRepositoryAssociationAutoExportPolicy;
        autoImportPolicy?: outputs.fsx.DataRepositoryAssociationAutoImportPolicy;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DataRepositoryAssociationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface FileSystemAuditLogConfiguration {
        auditLogDestination?: string;
        fileAccessAuditLogLevel: string;
        fileShareAccessAuditLogLevel: string;
    }
    interface FileSystemClientConfigurations {
        clients?: string;
        options?: string[];
    }
    interface FileSystemDiskIopsConfiguration {
        iops?: number;
        mode?: string;
    }
    interface FileSystemLustreConfiguration {
        autoImportPolicy?: string;
        automaticBackupRetentionDays?: number;
        copyTagsToBackups?: boolean;
        dailyAutomaticBackupStartTime?: string;
        dataCompressionType?: string;
        deploymentType?: string;
        driveCacheType?: string;
        exportPath?: string;
        importPath?: string;
        importedFileChunkSize?: number;
        perUnitStorageThroughput?: number;
        weeklyMaintenanceStartTime?: string;
    }
    interface FileSystemNfsExports {
        clientConfigurations?: outputs.fsx.FileSystemClientConfigurations[];
    }
    interface FileSystemOntapConfiguration {
        automaticBackupRetentionDays?: number;
        dailyAutomaticBackupStartTime?: string;
        deploymentType: string;
        diskIopsConfiguration?: outputs.fsx.FileSystemDiskIopsConfiguration;
        endpointIpAddressRange?: string;
        fsxAdminPassword?: string;
        preferredSubnetId?: string;
        routeTableIds?: string[];
        throughputCapacity?: number;
        weeklyMaintenanceStartTime?: string;
    }
    interface FileSystemOpenZFSConfiguration {
        automaticBackupRetentionDays?: number;
        copyTagsToBackups?: boolean;
        copyTagsToVolumes?: boolean;
        dailyAutomaticBackupStartTime?: string;
        deploymentType: string;
        diskIopsConfiguration?: outputs.fsx.FileSystemDiskIopsConfiguration;
        options?: string[];
        rootVolumeConfiguration?: outputs.fsx.FileSystemRootVolumeConfiguration;
        throughputCapacity?: number;
        weeklyMaintenanceStartTime?: string;
    }
    interface FileSystemRootVolumeConfiguration {
        copyTagsToSnapshots?: boolean;
        dataCompressionType?: string;
        nfsExports?: outputs.fsx.FileSystemNfsExports[];
        readOnly?: boolean;
        recordSizeKiB?: number;
        userAndGroupQuotas?: outputs.fsx.FileSystemUserAndGroupQuotas[];
    }
    interface FileSystemSelfManagedActiveDirectoryConfiguration {
        dnsIps?: string[];
        domainName?: string;
        fileSystemAdministratorsGroup?: string;
        organizationalUnitDistinguishedName?: string;
        password?: string;
        userName?: string;
    }
    interface FileSystemTag {
        key: string;
        value: string;
    }
    interface FileSystemUserAndGroupQuotas {
        id?: number;
        storageCapacityQuotaGiB?: number;
        type?: string;
    }
    interface FileSystemWindowsConfiguration {
        activeDirectoryId?: string;
        aliases?: string[];
        auditLogConfiguration?: outputs.fsx.FileSystemAuditLogConfiguration;
        automaticBackupRetentionDays?: number;
        copyTagsToBackups?: boolean;
        dailyAutomaticBackupStartTime?: string;
        deploymentType?: string;
        preferredSubnetId?: string;
        selfManagedActiveDirectoryConfiguration?: outputs.fsx.FileSystemSelfManagedActiveDirectoryConfiguration;
        throughputCapacity: number;
        weeklyMaintenanceStartTime?: string;
    }
    interface SnapshotTag {
        key: string;
        value: string;
    }
    interface StorageVirtualMachineActiveDirectoryConfiguration {
        netBiosName?: string;
        selfManagedActiveDirectoryConfiguration?: outputs.fsx.StorageVirtualMachineSelfManagedActiveDirectoryConfiguration;
    }
    interface StorageVirtualMachineSelfManagedActiveDirectoryConfiguration {
        dnsIps?: string[];
        domainName?: string;
        fileSystemAdministratorsGroup?: string;
        organizationalUnitDistinguishedName?: string;
        password?: string;
        userName?: string;
    }
    interface StorageVirtualMachineTag {
        key: string;
        value: string;
    }
    interface VolumeClientConfigurations {
        clients: string;
        options: string[];
    }
    interface VolumeNfsExports {
        clientConfigurations: outputs.fsx.VolumeClientConfigurations[];
    }
    interface VolumeOntapConfiguration {
        junctionPath: string;
        securityStyle?: string;
        sizeInMegabytes: string;
        storageEfficiencyEnabled: string;
        storageVirtualMachineId: string;
        tieringPolicy?: outputs.fsx.VolumeTieringPolicy;
    }
    interface VolumeOpenZFSConfiguration {
        copyTagsToSnapshots?: boolean;
        dataCompressionType?: string;
        nfsExports?: outputs.fsx.VolumeNfsExports[];
        options?: string[];
        originSnapshot?: outputs.fsx.VolumeOriginSnapshot;
        parentVolumeId: string;
        readOnly?: boolean;
        recordSizeKiB?: number;
        storageCapacityQuotaGiB?: number;
        storageCapacityReservationGiB?: number;
        userAndGroupQuotas?: outputs.fsx.VolumeUserAndGroupQuotas[];
    }
    interface VolumeOriginSnapshot {
        copyStrategy: string;
        snapshotARN: string;
    }
    interface VolumeTag {
        key: string;
        value: string;
    }
    interface VolumeTieringPolicy {
        coolingPeriod?: number;
        name?: string;
    }
    interface VolumeUserAndGroupQuotas {
        id: number;
        storageCapacityQuotaGiB: number;
        type: string;
    }
}
export declare namespace gamelift {
    interface AliasRoutingStrategy {
        /**
         * A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
         */
        fleetId?: string;
        /**
         * The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
         */
        message?: string;
        /**
         * Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
         */
        type: enums.gamelift.AliasRoutingStrategyType;
    }
    interface BuildS3Location {
        bucket: string;
        key: string;
        objectVersion?: string;
        roleArn: string;
    }
    /**
     * Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
     */
    interface FleetCertificateConfiguration {
        certificateType: enums.gamelift.FleetCertificateConfigurationCertificateType;
    }
    /**
     * A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
     */
    interface FleetIpPermission {
        /**
         * A starting value for a range of allowed port numbers.
         */
        fromPort: number;
        /**
         * A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
         */
        ipRange: string;
        /**
         * The network communication protocol used by the fleet.
         */
        protocol: enums.gamelift.FleetIpPermissionProtocol;
        /**
         * An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
         */
        toPort: number;
    }
    /**
     * Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
     */
    interface FleetLocationCapacity {
        /**
         * The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
         */
        desiredEC2Instances: number;
        /**
         * The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
         */
        maxSize: number;
        /**
         * The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
         */
        minSize: number;
    }
    /**
     * A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
     */
    interface FleetLocationConfiguration {
        location: string;
        locationCapacity?: outputs.gamelift.FleetLocationCapacity;
    }
    /**
     * A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
     *
     * The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
     */
    interface FleetResourceCreationLimitPolicy {
        /**
         * The maximum number of game sessions that an individual can create during the policy period.
         */
        newGameSessionsPerCreator?: number;
        /**
         * The time span used in evaluating the resource creation limit policy.
         */
        policyPeriodInMinutes?: number;
    }
    /**
     * A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
     *
     * The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
     *
     * An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
     */
    interface FleetRuntimeConfiguration {
        /**
         * The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
         */
        gameSessionActivationTimeoutSeconds?: number;
        /**
         * The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
         */
        maxConcurrentGameSessionActivations?: number;
        /**
         * A collection of server process configurations that describe which server processes to run on each instance in a fleet.
         */
        serverProcesses?: outputs.gamelift.FleetServerProcess[];
    }
    /**
     * A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
     */
    interface FleetServerProcess {
        /**
         * The number of server processes that use this configuration to run concurrently on an instance.
         */
        concurrentExecutions: number;
        /**
         * The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
         *
         * Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
         *
         * Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
         */
        launchPath: string;
        /**
         * An optional list of parameters to pass to the server executable or Realtime script on launch.
         */
        parameters?: string;
    }
    /**
     * Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
     */
    interface GameServerGroupAutoScalingPolicy {
        estimatedInstanceWarmup?: number;
        targetTrackingConfiguration: outputs.gamelift.GameServerGroupTargetTrackingConfiguration;
    }
    /**
     * An allowed instance type for your game server group.
     */
    interface GameServerGroupInstanceDefinition {
        instanceType: string;
        weightedCapacity?: string;
    }
    /**
     * The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
     */
    interface GameServerGroupLaunchTemplate {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version?: string;
    }
    interface GameServerGroupTag {
        /**
         * The key for a developer-defined key:value pair for tagging an AWS resource.
         */
        key?: string;
        /**
         * The value for a developer-defined key:value pair for tagging an AWS resource.
         */
        value?: string;
    }
    /**
     * Settings for a target-based scaling policy applied to Auto Scaling group.
     */
    interface GameServerGroupTargetTrackingConfiguration {
        targetValue: number;
    }
    interface GameSessionQueueDestination {
        destinationArn?: string;
    }
    interface GameSessionQueueFilterConfiguration {
        allowedLocations?: string[];
    }
    interface GameSessionQueuePlayerLatencyPolicy {
        maximumIndividualPlayerLatencyMilliseconds?: number;
        policyDurationSeconds?: number;
    }
    interface GameSessionQueuePriorityConfiguration {
        locationOrder?: string[];
        priorityOrder?: string[];
    }
    interface GameSessionQueueTag {
        key: string;
        value: string;
    }
    interface MatchmakingConfigurationGameProperty {
        key: string;
        value: string;
    }
    interface MatchmakingConfigurationTag {
        key: string;
        value: string;
    }
    interface MatchmakingRuleSetTag {
        key: string;
        value: string;
    }
    interface ScriptS3Location {
        bucket: string;
        key: string;
        objectVersion?: string;
        roleArn: string;
    }
    interface ScriptTag {
        key: string;
        value: string;
    }
}
export declare namespace globalaccelerator {
    /**
     * Tag is a key-value pair associated with accelerator.
     */
    interface AcceleratorTag {
        /**
         * Key of the tag. Value can be 1 to 127 characters.
         */
        key: string;
        /**
         * Value for the tag. Value can be 1 to 255 characters.
         */
        value: string;
    }
    /**
     * The configuration for a given endpoint
     */
    interface EndpointGroupEndpointConfiguration {
        /**
         * true if client ip should be preserved
         */
        clientIPPreservationEnabled?: boolean;
        /**
         * Id of the endpoint. For Network/Application Load Balancer this value is the ARN.  For EIP, this value is the allocation ID.  For EC2 instances, this is the EC2 instance ID
         */
        endpointId: string;
        /**
         * The weight for the endpoint.
         */
        weight?: number;
    }
    /**
     * listener to endpoint port mapping.
     */
    interface EndpointGroupPortOverride {
        endpointPort: number;
        listenerPort: number;
    }
    /**
     * A port range to support for connections from  clients to your accelerator.
     */
    interface ListenerPortRange {
        fromPort: number;
        toPort: number;
    }
}
export declare namespace glue {
    interface ClassifierCsvClassifier {
        allowSingleColumn?: boolean;
        containsHeader?: string;
        delimiter?: string;
        disableValueTrimming?: boolean;
        header?: string[];
        name?: string;
        quoteSymbol?: string;
    }
    interface ClassifierGrokClassifier {
        classification: string;
        customPatterns?: string;
        grokPattern: string;
        name?: string;
    }
    interface ClassifierJsonClassifier {
        jsonPath: string;
        name?: string;
    }
    interface ClassifierXMLClassifier {
        classification: string;
        name?: string;
        rowTag: string;
    }
    interface ConnectionInput {
        connectionProperties?: any;
        connectionType: string;
        description?: string;
        matchCriteria?: string[];
        name?: string;
        physicalConnectionRequirements?: outputs.glue.ConnectionPhysicalConnectionRequirements;
    }
    interface ConnectionPhysicalConnectionRequirements {
        availabilityZone?: string;
        securityGroupIdList?: string[];
        subnetId?: string;
    }
    interface CrawlerCatalogTarget {
        databaseName?: string;
        tables?: string[];
    }
    interface CrawlerDynamoDBTarget {
        path?: string;
    }
    interface CrawlerJdbcTarget {
        connectionName?: string;
        exclusions?: string[];
        path?: string;
    }
    interface CrawlerMongoDBTarget {
        connectionName?: string;
        path?: string;
    }
    interface CrawlerRecrawlPolicy {
        recrawlBehavior?: string;
    }
    interface CrawlerS3Target {
        connectionName?: string;
        dlqEventQueueArn?: string;
        eventQueueArn?: string;
        exclusions?: string[];
        path?: string;
        sampleSize?: number;
    }
    interface CrawlerSchedule {
        scheduleExpression?: string;
    }
    interface CrawlerSchemaChangePolicy {
        deleteBehavior?: string;
        updateBehavior?: string;
    }
    interface CrawlerTargets {
        catalogTargets?: outputs.glue.CrawlerCatalogTarget[];
        dynamoDBTargets?: outputs.glue.CrawlerDynamoDBTarget[];
        jdbcTargets?: outputs.glue.CrawlerJdbcTarget[];
        mongoDBTargets?: outputs.glue.CrawlerMongoDBTarget[];
        s3Targets?: outputs.glue.CrawlerS3Target[];
    }
    interface DataCatalogEncryptionSettings {
        connectionPasswordEncryption?: outputs.glue.DataCatalogEncryptionSettingsConnectionPasswordEncryption;
        encryptionAtRest?: outputs.glue.DataCatalogEncryptionSettingsEncryptionAtRest;
    }
    interface DataCatalogEncryptionSettingsConnectionPasswordEncryption {
        kmsKeyId?: string;
        returnConnectionPasswordEncrypted?: boolean;
    }
    interface DataCatalogEncryptionSettingsEncryptionAtRest {
        catalogEncryptionMode?: string;
        sseAwsKmsKeyId?: string;
    }
    interface DatabaseDataLakePrincipal {
        dataLakePrincipalIdentifier?: string;
    }
    interface DatabaseIdentifier {
        catalogId?: string;
        databaseName?: string;
    }
    interface DatabaseInput {
        createTableDefaultPermissions?: outputs.glue.DatabasePrincipalPrivileges[];
        description?: string;
        locationUri?: string;
        name?: string;
        parameters?: any;
        targetDatabase?: outputs.glue.DatabaseIdentifier;
    }
    interface DatabasePrincipalPrivileges {
        permissions?: string[];
        principal?: outputs.glue.DatabaseDataLakePrincipal;
    }
    interface JobCommand {
        name?: string;
        pythonVersion?: string;
        scriptLocation?: string;
    }
    interface JobConnectionsList {
        connections?: string[];
    }
    interface JobExecutionProperty {
        maxConcurrentRuns?: number;
    }
    interface JobNotificationProperty {
        notifyDelayAfter?: number;
    }
    interface MLTransformFindMatchesParameters {
        accuracyCostTradeoff?: number;
        enforceProvidedLabels?: boolean;
        precisionRecallTradeoff?: number;
        primaryKeyColumnName: string;
    }
    interface MLTransformGlueTables {
        catalogId?: string;
        connectionName?: string;
        databaseName: string;
        tableName: string;
    }
    interface MLTransformInputRecordTables {
        glueTables?: outputs.glue.MLTransformGlueTables[];
    }
    interface MLTransformMLUserDataEncryption {
        kmsKeyId?: string;
        mLUserDataEncryptionMode: string;
    }
    interface MLTransformTransformEncryption {
        mLUserDataEncryption?: outputs.glue.MLTransformMLUserDataEncryption;
        taskRunSecurityConfigurationName?: string;
    }
    interface MLTransformTransformParameters {
        findMatchesParameters?: outputs.glue.MLTransformFindMatchesParameters;
        transformType: string;
    }
    interface PartitionColumn {
        comment?: string;
        name: string;
        type?: string;
    }
    interface PartitionInput {
        parameters?: any;
        storageDescriptor?: outputs.glue.PartitionStorageDescriptor;
        values: string[];
    }
    interface PartitionOrder {
        column: string;
        sortOrder?: number;
    }
    interface PartitionSchemaId {
        registryName?: string;
        schemaArn?: string;
        schemaName?: string;
    }
    interface PartitionSchemaReference {
        schemaId?: outputs.glue.PartitionSchemaId;
        schemaVersionId?: string;
        schemaVersionNumber?: number;
    }
    interface PartitionSerdeInfo {
        name?: string;
        parameters?: any;
        serializationLibrary?: string;
    }
    interface PartitionSkewedInfo {
        skewedColumnNames?: string[];
        skewedColumnValueLocationMaps?: any;
        skewedColumnValues?: string[];
    }
    interface PartitionStorageDescriptor {
        bucketColumns?: string[];
        columns?: outputs.glue.PartitionColumn[];
        compressed?: boolean;
        inputFormat?: string;
        location?: string;
        numberOfBuckets?: number;
        outputFormat?: string;
        parameters?: any;
        schemaReference?: outputs.glue.PartitionSchemaReference;
        serdeInfo?: outputs.glue.PartitionSerdeInfo;
        skewedInfo?: outputs.glue.PartitionSkewedInfo;
        sortColumns?: outputs.glue.PartitionOrder[];
        storedAsSubDirectories?: boolean;
    }
    interface RegistryTag {
        /**
         * A key to identify the tag.
         */
        key: string;
        /**
         * Corresponding tag value for the key.
         */
        value: string;
    }
    /**
     * Identifier for the registry which the schema is part of.
     */
    interface SchemaRegistry {
        /**
         * Amazon Resource Name for the Registry.
         */
        arn?: string;
        /**
         * Name of the registry in which the schema will be created.
         */
        name?: string;
    }
    interface SchemaTag {
        /**
         * A key to identify the tag.
         */
        key: string;
        /**
         * Corresponding tag value for the key.
         */
        value: string;
    }
    /**
     * Specify checkpoint version for update. This is only required to update the Compatibility.
     */
    interface SchemaVersion {
        /**
         * Indicates if the latest version needs to be updated.
         */
        isLatest?: boolean;
        /**
         * Indicates the version number in the schema to update.
         */
        versionNumber?: number;
    }
    /**
     * Identifier for the schema where the schema version will be created.
     */
    interface SchemaVersionSchema {
        /**
         * Name of the registry to identify where the Schema is located.
         */
        registryName?: string;
        /**
         * Amazon Resource Name for the Schema. This attribute can be used to uniquely represent the Schema.
         */
        schemaArn?: string;
        /**
         * Name of the schema. This parameter requires RegistryName to be provided.
         */
        schemaName?: string;
    }
    interface SecurityConfigurationCloudWatchEncryption {
        cloudWatchEncryptionMode?: string;
        kmsKeyArn?: string;
    }
    interface SecurityConfigurationEncryptionConfiguration {
        cloudWatchEncryption?: outputs.glue.SecurityConfigurationCloudWatchEncryption;
        jobBookmarksEncryption?: outputs.glue.SecurityConfigurationJobBookmarksEncryption;
        s3Encryptions?: outputs.glue.SecurityConfigurationS3Encryptions;
    }
    interface SecurityConfigurationJobBookmarksEncryption {
        jobBookmarksEncryptionMode?: string;
        kmsKeyArn?: string;
    }
    interface SecurityConfigurationS3Encryptions {
    }
    interface TableColumn {
        comment?: string;
        name: string;
        type?: string;
    }
    interface TableIdentifier {
        catalogId?: string;
        databaseName?: string;
        name?: string;
    }
    interface TableInput {
        description?: string;
        name?: string;
        owner?: string;
        parameters?: any;
        partitionKeys?: outputs.glue.TableColumn[];
        retention?: number;
        storageDescriptor?: outputs.glue.TableStorageDescriptor;
        tableType?: string;
        targetTable?: outputs.glue.TableIdentifier;
        viewExpandedText?: string;
        viewOriginalText?: string;
    }
    interface TableOrder {
        column: string;
        sortOrder: number;
    }
    interface TableSchemaId {
        registryName?: string;
        schemaArn?: string;
        schemaName?: string;
    }
    interface TableSchemaReference {
        schemaId?: outputs.glue.TableSchemaId;
        schemaVersionId?: string;
        schemaVersionNumber?: number;
    }
    interface TableSerdeInfo {
        name?: string;
        parameters?: any;
        serializationLibrary?: string;
    }
    interface TableSkewedInfo {
        skewedColumnNames?: string[];
        skewedColumnValueLocationMaps?: any;
        skewedColumnValues?: string[];
    }
    interface TableStorageDescriptor {
        bucketColumns?: string[];
        columns?: outputs.glue.TableColumn[];
        compressed?: boolean;
        inputFormat?: string;
        location?: string;
        numberOfBuckets?: number;
        outputFormat?: string;
        parameters?: any;
        schemaReference?: outputs.glue.TableSchemaReference;
        serdeInfo?: outputs.glue.TableSerdeInfo;
        skewedInfo?: outputs.glue.TableSkewedInfo;
        sortColumns?: outputs.glue.TableOrder[];
        storedAsSubDirectories?: boolean;
    }
    interface TriggerAction {
        arguments?: any;
        crawlerName?: string;
        jobName?: string;
        notificationProperty?: outputs.glue.TriggerNotificationProperty;
        securityConfiguration?: string;
        timeout?: number;
    }
    interface TriggerCondition {
        crawlState?: string;
        crawlerName?: string;
        jobName?: string;
        logicalOperator?: string;
        state?: string;
    }
    interface TriggerEventBatchingCondition {
        batchSize: number;
        batchWindow?: number;
    }
    interface TriggerNotificationProperty {
        notifyDelayAfter?: number;
    }
    interface TriggerPredicate {
        conditions?: outputs.glue.TriggerCondition[];
        logical?: string;
    }
}
export declare namespace greengrass {
    interface ConnectorDefinitionConnector {
        connectorArn: string;
        id: string;
        parameters?: any;
    }
    interface ConnectorDefinitionVersion {
        connectors: outputs.greengrass.ConnectorDefinitionConnector[];
    }
    interface ConnectorDefinitionVersionConnector {
        connectorArn: string;
        id: string;
        parameters?: any;
    }
    interface CoreDefinitionCore {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }
    interface CoreDefinitionVersion {
        cores: outputs.greengrass.CoreDefinitionCore[];
    }
    interface CoreDefinitionVersionCore {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }
    interface DeviceDefinitionDevice {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }
    interface DeviceDefinitionVersion {
        devices: outputs.greengrass.DeviceDefinitionDevice[];
    }
    interface DeviceDefinitionVersionDevice {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }
    interface FunctionDefinitionDefaultConfig {
        execution: outputs.greengrass.FunctionDefinitionExecution;
    }
    interface FunctionDefinitionEnvironment {
        accessSysfs?: boolean;
        execution?: outputs.greengrass.FunctionDefinitionExecution;
        resourceAccessPolicies?: outputs.greengrass.FunctionDefinitionResourceAccessPolicy[];
        variables?: any;
    }
    interface FunctionDefinitionExecution {
        isolationMode?: string;
        runAs?: outputs.greengrass.FunctionDefinitionRunAs;
    }
    interface FunctionDefinitionFunction {
        functionArn: string;
        functionConfiguration: outputs.greengrass.FunctionDefinitionFunctionConfiguration;
        id: string;
    }
    interface FunctionDefinitionFunctionConfiguration {
        encodingType?: string;
        environment?: outputs.greengrass.FunctionDefinitionEnvironment;
        execArgs?: string;
        executable?: string;
        memorySize?: number;
        pinned?: boolean;
        timeout?: number;
    }
    interface FunctionDefinitionResourceAccessPolicy {
        permission?: string;
        resourceId: string;
    }
    interface FunctionDefinitionRunAs {
        gid?: number;
        uid?: number;
    }
    interface FunctionDefinitionVersion {
        defaultConfig?: outputs.greengrass.FunctionDefinitionDefaultConfig;
        functions: outputs.greengrass.FunctionDefinitionFunction[];
    }
    interface FunctionDefinitionVersionDefaultConfig {
        execution: outputs.greengrass.FunctionDefinitionVersionExecution;
    }
    interface FunctionDefinitionVersionEnvironment {
        accessSysfs?: boolean;
        execution?: outputs.greengrass.FunctionDefinitionVersionExecution;
        resourceAccessPolicies?: outputs.greengrass.FunctionDefinitionVersionResourceAccessPolicy[];
        variables?: any;
    }
    interface FunctionDefinitionVersionExecution {
        isolationMode?: string;
        runAs?: outputs.greengrass.FunctionDefinitionVersionRunAs;
    }
    interface FunctionDefinitionVersionFunction {
        functionArn: string;
        functionConfiguration: outputs.greengrass.FunctionDefinitionVersionFunctionConfiguration;
        id: string;
    }
    interface FunctionDefinitionVersionFunctionConfiguration {
        encodingType?: string;
        environment?: outputs.greengrass.FunctionDefinitionVersionEnvironment;
        execArgs?: string;
        executable?: string;
        memorySize?: number;
        pinned?: boolean;
        timeout?: number;
    }
    interface FunctionDefinitionVersionResourceAccessPolicy {
        permission?: string;
        resourceId: string;
    }
    interface FunctionDefinitionVersionRunAs {
        gid?: number;
        uid?: number;
    }
    interface GroupVersion {
        connectorDefinitionVersionArn?: string;
        coreDefinitionVersionArn?: string;
        deviceDefinitionVersionArn?: string;
        functionDefinitionVersionArn?: string;
        loggerDefinitionVersionArn?: string;
        resourceDefinitionVersionArn?: string;
        subscriptionDefinitionVersionArn?: string;
    }
    interface LoggerDefinitionLogger {
        component: string;
        id: string;
        level: string;
        space?: number;
        type: string;
    }
    interface LoggerDefinitionVersion {
        loggers: outputs.greengrass.LoggerDefinitionLogger[];
    }
    interface LoggerDefinitionVersionLogger {
        component: string;
        id: string;
        level: string;
        space?: number;
        type: string;
    }
    interface ResourceDefinitionGroupOwnerSetting {
        autoAddGroupOwner: boolean;
        groupOwner?: string;
    }
    interface ResourceDefinitionLocalDeviceResourceData {
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionGroupOwnerSetting;
        sourcePath: string;
    }
    interface ResourceDefinitionLocalVolumeResourceData {
        destinationPath: string;
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionGroupOwnerSetting;
        sourcePath: string;
    }
    interface ResourceDefinitionResourceDataContainer {
        localDeviceResourceData?: outputs.greengrass.ResourceDefinitionLocalDeviceResourceData;
        localVolumeResourceData?: outputs.greengrass.ResourceDefinitionLocalVolumeResourceData;
        s3MachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionS3MachineLearningModelResourceData;
        sageMakerMachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionSageMakerMachineLearningModelResourceData;
        secretsManagerSecretResourceData?: outputs.greengrass.ResourceDefinitionSecretsManagerSecretResourceData;
    }
    interface ResourceDefinitionResourceDownloadOwnerSetting {
        groupOwner: string;
        groupPermission: string;
    }
    interface ResourceDefinitionResourceInstance {
        id: string;
        name: string;
        resourceDataContainer: outputs.greengrass.ResourceDefinitionResourceDataContainer;
    }
    interface ResourceDefinitionS3MachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionResourceDownloadOwnerSetting;
        s3Uri: string;
    }
    interface ResourceDefinitionSageMakerMachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionResourceDownloadOwnerSetting;
        sageMakerJobArn: string;
    }
    interface ResourceDefinitionSecretsManagerSecretResourceData {
        aRN: string;
        additionalStagingLabelsToDownload?: string[];
    }
    interface ResourceDefinitionVersion {
        resources: outputs.greengrass.ResourceDefinitionResourceInstance[];
    }
    interface ResourceDefinitionVersionGroupOwnerSetting {
        autoAddGroupOwner: boolean;
        groupOwner?: string;
    }
    interface ResourceDefinitionVersionLocalDeviceResourceData {
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionVersionGroupOwnerSetting;
        sourcePath: string;
    }
    interface ResourceDefinitionVersionLocalVolumeResourceData {
        destinationPath: string;
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionVersionGroupOwnerSetting;
        sourcePath: string;
    }
    interface ResourceDefinitionVersionResourceDataContainer {
        localDeviceResourceData?: outputs.greengrass.ResourceDefinitionVersionLocalDeviceResourceData;
        localVolumeResourceData?: outputs.greengrass.ResourceDefinitionVersionLocalVolumeResourceData;
        s3MachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionVersionS3MachineLearningModelResourceData;
        sageMakerMachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionVersionSageMakerMachineLearningModelResourceData;
        secretsManagerSecretResourceData?: outputs.greengrass.ResourceDefinitionVersionSecretsManagerSecretResourceData;
    }
    interface ResourceDefinitionVersionResourceDownloadOwnerSetting {
        groupOwner: string;
        groupPermission: string;
    }
    interface ResourceDefinitionVersionResourceInstance {
        id: string;
        name: string;
        resourceDataContainer: outputs.greengrass.ResourceDefinitionVersionResourceDataContainer;
    }
    interface ResourceDefinitionVersionS3MachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionVersionResourceDownloadOwnerSetting;
        s3Uri: string;
    }
    interface ResourceDefinitionVersionSageMakerMachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionVersionResourceDownloadOwnerSetting;
        sageMakerJobArn: string;
    }
    interface ResourceDefinitionVersionSecretsManagerSecretResourceData {
        aRN: string;
        additionalStagingLabelsToDownload?: string[];
    }
    interface SubscriptionDefinitionSubscription {
        id: string;
        source: string;
        subject: string;
        target: string;
    }
    interface SubscriptionDefinitionVersion {
        subscriptions: outputs.greengrass.SubscriptionDefinitionSubscription[];
    }
    interface SubscriptionDefinitionVersionSubscription {
        id: string;
        source: string;
        subject: string;
        target: string;
    }
}
export declare namespace greengrassv2 {
    interface ComponentVersionComponentPlatform {
        attributes?: any;
        name?: string;
    }
    interface ComponentVersionLambdaContainerParams {
        devices?: outputs.greengrassv2.ComponentVersionLambdaDeviceMount[];
        memorySizeInKB?: number;
        mountROSysfs?: boolean;
        volumes?: outputs.greengrassv2.ComponentVersionLambdaVolumeMount[];
    }
    interface ComponentVersionLambdaDeviceMount {
        addGroupOwner?: boolean;
        path?: string;
        permission?: enums.greengrassv2.ComponentVersionLambdaFilesystemPermission;
    }
    interface ComponentVersionLambdaEventSource {
        topic?: string;
        type?: enums.greengrassv2.ComponentVersionLambdaEventSourceType;
    }
    interface ComponentVersionLambdaExecutionParameters {
        environmentVariables?: any;
        eventSources?: outputs.greengrassv2.ComponentVersionLambdaEventSource[];
        execArgs?: string[];
        inputPayloadEncodingType?: enums.greengrassv2.ComponentVersionLambdaExecutionParametersInputPayloadEncodingType;
        linuxProcessParams?: outputs.greengrassv2.ComponentVersionLambdaLinuxProcessParams;
        maxIdleTimeInSeconds?: number;
        maxInstancesCount?: number;
        maxQueueSize?: number;
        pinned?: boolean;
        statusTimeoutInSeconds?: number;
        timeoutInSeconds?: number;
    }
    interface ComponentVersionLambdaFunctionRecipeSource {
        componentDependencies?: any;
        componentLambdaParameters?: outputs.greengrassv2.ComponentVersionLambdaExecutionParameters;
        componentName?: string;
        componentPlatforms?: outputs.greengrassv2.ComponentVersionComponentPlatform[];
        componentVersion?: string;
        lambdaArn?: string;
    }
    interface ComponentVersionLambdaLinuxProcessParams {
        containerParams?: outputs.greengrassv2.ComponentVersionLambdaContainerParams;
        isolationMode?: enums.greengrassv2.ComponentVersionLambdaLinuxProcessParamsIsolationMode;
    }
    interface ComponentVersionLambdaVolumeMount {
        addGroupOwner?: boolean;
        destinationPath?: string;
        permission?: enums.greengrassv2.ComponentVersionLambdaFilesystemPermission;
        sourcePath?: string;
    }
    interface DeploymentComponentUpdatePolicy {
        action?: enums.greengrassv2.DeploymentComponentUpdatePolicyAction;
        timeoutInSeconds?: number;
    }
    interface DeploymentConfigurationValidationPolicy {
        timeoutInSeconds?: number;
    }
    interface DeploymentIoTJobAbortConfig {
        criteriaList: outputs.greengrassv2.DeploymentIoTJobAbortCriteria[];
    }
    interface DeploymentIoTJobAbortCriteria {
        action: enums.greengrassv2.DeploymentIoTJobAbortCriteriaAction;
        failureType: enums.greengrassv2.DeploymentIoTJobAbortCriteriaFailureType;
        minNumberOfExecutedThings: number;
        thresholdPercentage: number;
    }
    interface DeploymentIoTJobConfiguration {
        abortConfig?: outputs.greengrassv2.DeploymentIoTJobAbortConfig;
        jobExecutionsRolloutConfig?: outputs.greengrassv2.DeploymentIoTJobExecutionsRolloutConfig;
        timeoutConfig?: outputs.greengrassv2.DeploymentIoTJobTimeoutConfig;
    }
    interface DeploymentIoTJobExecutionsRolloutConfig {
        exponentialRate?: outputs.greengrassv2.DeploymentIoTJobExponentialRolloutRate;
        maximumPerMinute?: number;
    }
    interface DeploymentIoTJobExponentialRolloutRate {
        baseRatePerMinute: number;
        incrementFactor: number;
        rateIncreaseCriteria: outputs.greengrassv2.DeploymentIoTJobRateIncreaseCriteria;
    }
    interface DeploymentIoTJobRateIncreaseCriteria {
    }
    interface DeploymentIoTJobTimeoutConfig {
        inProgressTimeoutInMinutes?: number;
    }
    interface DeploymentPolicies {
        componentUpdatePolicy?: outputs.greengrassv2.DeploymentComponentUpdatePolicy;
        configurationValidationPolicy?: outputs.greengrassv2.DeploymentConfigurationValidationPolicy;
        failureHandlingPolicy?: enums.greengrassv2.DeploymentPoliciesFailureHandlingPolicy;
    }
}
export declare namespace groundstation {
    interface ConfigAntennaDownlinkConfig {
        spectrumConfig?: outputs.groundstation.ConfigSpectrumConfig;
    }
    interface ConfigAntennaDownlinkDemodDecodeConfig {
        decodeConfig?: outputs.groundstation.ConfigDecodeConfig;
        demodulationConfig?: outputs.groundstation.ConfigDemodulationConfig;
        spectrumConfig?: outputs.groundstation.ConfigSpectrumConfig;
    }
    interface ConfigAntennaUplinkConfig {
        spectrumConfig?: outputs.groundstation.ConfigUplinkSpectrumConfig;
        targetEirp?: outputs.groundstation.ConfigEirp;
        transmitDisabled?: boolean;
    }
    interface ConfigData {
        antennaDownlinkConfig?: outputs.groundstation.ConfigAntennaDownlinkConfig;
        antennaDownlinkDemodDecodeConfig?: outputs.groundstation.ConfigAntennaDownlinkDemodDecodeConfig;
        antennaUplinkConfig?: outputs.groundstation.ConfigAntennaUplinkConfig;
        dataflowEndpointConfig?: outputs.groundstation.ConfigDataflowEndpointConfig;
        s3RecordingConfig?: outputs.groundstation.ConfigS3RecordingConfig;
        trackingConfig?: outputs.groundstation.ConfigTrackingConfig;
        uplinkEchoConfig?: outputs.groundstation.ConfigUplinkEchoConfig;
    }
    interface ConfigDataflowEndpointConfig {
        dataflowEndpointName?: string;
        dataflowEndpointRegion?: string;
    }
    interface ConfigDecodeConfig {
        unvalidatedJSON?: string;
    }
    interface ConfigDemodulationConfig {
        unvalidatedJSON?: string;
    }
    interface ConfigEirp {
        units?: enums.groundstation.ConfigEirpUnits;
        value?: number;
    }
    interface ConfigFrequency {
        units?: enums.groundstation.ConfigFrequencyUnits;
        value?: number;
    }
    interface ConfigFrequencyBandwidth {
        units?: enums.groundstation.ConfigBandwidthUnits;
        value?: number;
    }
    interface ConfigS3RecordingConfig {
        bucketArn?: string;
        prefix?: string;
        roleArn?: string;
    }
    interface ConfigSpectrumConfig {
        bandwidth?: outputs.groundstation.ConfigFrequencyBandwidth;
        centerFrequency?: outputs.groundstation.ConfigFrequency;
        polarization?: enums.groundstation.ConfigPolarization;
    }
    interface ConfigTag {
        key?: string;
        value?: string;
    }
    interface ConfigTrackingConfig {
        autotrack?: enums.groundstation.ConfigTrackingConfigAutotrack;
    }
    interface ConfigUplinkEchoConfig {
        antennaUplinkConfigArn?: string;
        enabled?: boolean;
    }
    interface ConfigUplinkSpectrumConfig {
        centerFrequency?: outputs.groundstation.ConfigFrequency;
        polarization?: enums.groundstation.ConfigPolarization;
    }
    interface DataflowEndpointGroupDataflowEndpoint {
        address?: outputs.groundstation.DataflowEndpointGroupSocketAddress;
        mtu?: number;
        name?: string;
    }
    interface DataflowEndpointGroupEndpointDetails {
        endpoint?: outputs.groundstation.DataflowEndpointGroupDataflowEndpoint;
        securityDetails?: outputs.groundstation.DataflowEndpointGroupSecurityDetails;
    }
    interface DataflowEndpointGroupSecurityDetails {
        roleArn?: string;
        securityGroupIds?: string[];
        subnetIds?: string[];
    }
    interface DataflowEndpointGroupSocketAddress {
        name?: string;
        port?: number;
    }
    interface DataflowEndpointGroupTag {
        key: string;
        value: string;
    }
    interface MissionProfileDataflowEdge {
        destination?: string;
        source?: string;
    }
    interface MissionProfileTag {
        key?: string;
        value?: string;
    }
}
export declare namespace guardduty {
    interface DetectorCFNDataSourceConfigurations {
        kubernetes?: outputs.guardduty.DetectorCFNKubernetesConfiguration;
        malwareProtection?: outputs.guardduty.DetectorCFNMalwareProtectionConfiguration;
        s3Logs?: outputs.guardduty.DetectorCFNS3LogsConfiguration;
    }
    interface DetectorCFNKubernetesAuditLogsConfiguration {
        enable?: boolean;
    }
    interface DetectorCFNKubernetesConfiguration {
        auditLogs?: outputs.guardduty.DetectorCFNKubernetesAuditLogsConfiguration;
    }
    interface DetectorCFNMalwareProtectionConfiguration {
        scanEc2InstanceWithFindings?: outputs.guardduty.DetectorCFNScanEc2InstanceWithFindingsConfiguration;
    }
    interface DetectorCFNS3LogsConfiguration {
        enable?: boolean;
    }
    interface DetectorCFNScanEc2InstanceWithFindingsConfiguration {
        ebsVolumes?: boolean;
    }
    interface DetectorTag {
        key: string;
        value: string;
    }
    interface FilterCondition {
        eq?: string[];
        equals?: string[];
        greaterThan?: number;
        greaterThanOrEqual?: number;
        gt?: number;
        gte?: number;
        lessThan?: number;
        lessThanOrEqual?: number;
        lt?: number;
        lte?: number;
        neq?: string[];
        notEquals?: string[];
    }
    interface FilterFindingCriteria {
        criterion?: any;
        itemType?: outputs.guardduty.FilterCondition;
    }
    interface FilterTag {
        key: string;
        value: string;
    }
    interface IPSetTag {
        key: string;
        value: string;
    }
    interface ThreatIntelSetTag {
        key: string;
        value: string;
    }
}
export declare namespace healthlake {
    /**
     * The time that a Data Store was created.
     */
    interface FHIRDatastoreCreatedAt {
        /**
         * Nanoseconds.
         */
        nanos: number;
        /**
         * Seconds since epoch.
         */
        seconds: string;
    }
    /**
     * The customer-managed-key (CMK) used when creating a Data Store. If a customer owned key is not specified, an AWS owned key will be used for encryption.
     */
    interface FHIRDatastoreKmsEncryptionConfig {
        /**
         * The type of customer-managed-key (CMK) used for encryption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
         */
        cmkType: enums.healthlake.FHIRDatastoreKmsEncryptionConfigCmkType;
        /**
         * The KMS encryption key id/alias used to encrypt the Data Store contents at rest.
         */
        kmsKeyId?: string;
    }
    /**
     * The preloaded data configuration for the Data Store. Only data preloaded from Synthea is supported.
     */
    interface FHIRDatastorePreloadDataConfig {
        /**
         * The type of preloaded data. Only Synthea preloaded data is supported.
         */
        preloadDataType: enums.healthlake.FHIRDatastorePreloadDataConfigPreloadDataType;
    }
    /**
     * The server-side encryption key configuration for a customer provided encryption key.
     */
    interface FHIRDatastoreSseConfiguration {
        kmsEncryptionConfig: outputs.healthlake.FHIRDatastoreKmsEncryptionConfig;
    }
    /**
     * A key-value pair. A tag consists of a tag key and a tag value. Tag keys and tag values are both required, but tag values can be empty (null) strings.
     */
    interface FHIRDatastoreTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The value of the tag.
         */
        value: string;
    }
}
export declare namespace iam {
    interface GroupPolicy {
        policyDocument: any;
        policyName: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface OIDCProviderTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The inline policy document that is embedded in the specified IAM role.
     */
    interface RolePolicy {
        /**
         * The policy document.
         */
        policyDocument: string;
        /**
         * The friendly name (not ARN) identifying the policy.
         */
        policyName: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface RoleTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface SAMLProviderTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ServerCertificateTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface UserLoginProfile {
        password: string;
        passwordResetRequired?: boolean;
    }
    interface UserPolicy {
        policyDocument: any;
        policyName: string;
    }
    interface UserTag {
        key: string;
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface VirtualMFADeviceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace identitystore {
    /**
     * An object containing the identifier of a group member.
     */
    interface GroupMembershipMemberId {
        /**
         * The identifier for a user in the identity store.
         */
        userId: string;
    }
}
export declare namespace imagebuilder {
    /**
     * Configuration details of the component.
     */
    interface ContainerRecipeComponentConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn?: string;
        /**
         * A group of parameter settings that are used to configure the component for a specific recipe.
         */
        parameters?: outputs.imagebuilder.ContainerRecipeComponentParameter[];
    }
    /**
     * Contains a key/value pair that sets the named component parameter.
     */
    interface ContainerRecipeComponentParameter {
        /**
         * The name of the component parameter to set.
         */
        name: string;
        /**
         * Sets the value for the named component parameter.
         */
        value: string[];
    }
    /**
     * Amazon EBS-specific block device mapping specifications.
     */
    interface ContainerRecipeEbsInstanceBlockDeviceSpecification {
        /**
         * Use to configure delete on termination of the associated device.
         */
        deleteOnTermination?: boolean;
        /**
         * Use to configure device encryption.
         */
        encrypted?: boolean;
        /**
         * Use to configure device IOPS.
         */
        iops?: number;
        /**
         * Use to configure the KMS key to use when encrypting the device.
         */
        kmsKeyId?: string;
        /**
         * The snapshot that defines the device contents.
         */
        snapshotId?: string;
        /**
         * For GP3 volumes only - The throughput in MiB/s that the volume supports.
         */
        throughput?: number;
        /**
         * Use to override the device's volume size.
         */
        volumeSize?: number;
        /**
         * Use to override the device's volume type.
         */
        volumeType?: enums.imagebuilder.ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType;
    }
    /**
     * Defines block device mappings for the instance used to configure your image.
     */
    interface ContainerRecipeInstanceBlockDeviceMapping {
        /**
         * The device to which these mappings apply.
         */
        deviceName?: string;
        /**
         * Use to manage Amazon EBS-specific configuration for this mapping.
         */
        ebs?: outputs.imagebuilder.ContainerRecipeEbsInstanceBlockDeviceSpecification;
        /**
         * Use to remove a mapping from the parent image.
         */
        noDevice?: string;
        /**
         * Use to manage instance ephemeral devices.
         */
        virtualName?: string;
    }
    /**
     * A group of options that can be used to configure an instance for building and testing container images.
     */
    interface ContainerRecipeInstanceConfiguration {
        /**
         * Defines the block devices to attach for building an instance from this Image Builder AMI.
         */
        blockDeviceMappings?: outputs.imagebuilder.ContainerRecipeInstanceBlockDeviceMapping[];
        /**
         * The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
         */
        image?: string;
    }
    /**
     * The container repository where the output container image is stored.
     */
    interface ContainerRecipeTargetContainerRepository {
        /**
         * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
         */
        repositoryName?: string;
        /**
         * Specifies the service in which this image was registered.
         */
        service?: enums.imagebuilder.ContainerRecipeTargetContainerRepositoryService;
    }
    /**
     * The specific AMI settings (for example, launch permissions, AMI tags).
     */
    interface DistributionConfigurationAmiDistributionConfiguration {
        /**
         * The tags to apply to AMIs distributed to this Region.
         */
        amiTags?: any;
        /**
         * The description of the AMI distribution configuration.
         */
        description?: string;
        /**
         * The KMS key identifier used to encrypt the distributed image.
         */
        kmsKeyId?: string;
        launchPermissionConfiguration?: outputs.imagebuilder.DistributionConfigurationLaunchPermissionConfiguration;
        /**
         * The name of the AMI distribution configuration.
         */
        name?: string;
        /**
         * The ID of accounts to which you want to distribute an image.
         */
        targetAccountIds?: string[];
    }
    /**
     * Container distribution settings for encryption, licensing, and sharing in a specific Region.
     */
    interface DistributionConfigurationContainerDistributionConfiguration {
        /**
         * Tags that are attached to the container distribution configuration.
         */
        containerTags?: string[];
        /**
         * The description of the container distribution configuration.
         */
        description?: string;
        /**
         * The destination repository for the container distribution configuration.
         */
        targetRepository?: outputs.imagebuilder.DistributionConfigurationTargetContainerRepository;
    }
    /**
     * The distributions of the distribution configuration.
     */
    interface DistributionConfigurationDistribution {
        amiDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationAmiDistributionConfiguration;
        containerDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationContainerDistributionConfiguration;
        /**
         * The Windows faster-launching configurations to use for AMI distribution.
         */
        fastLaunchConfigurations?: outputs.imagebuilder.DistributionConfigurationFastLaunchConfiguration[];
        /**
         * A group of launchTemplateConfiguration settings that apply to image distribution.
         */
        launchTemplateConfigurations?: outputs.imagebuilder.DistributionConfigurationLaunchTemplateConfiguration[];
        /**
         * The License Manager Configuration to associate with the AMI in the specified Region.
         */
        licenseConfigurationArns?: string[];
        /**
         * region
         */
        region: string;
    }
    /**
     * The Windows faster-launching configuration to use for AMI distribution.
     */
    interface DistributionConfigurationFastLaunchConfiguration {
        /**
         * The owner account ID for the fast-launch enabled Windows AMI.
         */
        accountId?: string;
        /**
         * A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
         */
        enabled?: boolean;
        /**
         * The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
         */
        launchTemplate?: outputs.imagebuilder.DistributionConfigurationFastLaunchLaunchTemplateSpecification;
        /**
         * The maximum number of parallel instances that are launched for creating resources.
         */
        maxParallelLaunches?: number;
        /**
         * Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
         */
        snapshotConfiguration?: outputs.imagebuilder.DistributionConfigurationFastLaunchSnapshotConfiguration;
    }
    /**
     * The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
     */
    interface DistributionConfigurationFastLaunchLaunchTemplateSpecification {
        /**
         * The ID of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateId?: string;
        /**
         * The name of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateName?: string;
        /**
         * The version of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateVersion?: string;
    }
    /**
     * Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
     */
    interface DistributionConfigurationFastLaunchSnapshotConfiguration {
        /**
         * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
         */
        targetResourceCount?: number;
    }
    /**
     * Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances.
     */
    interface DistributionConfigurationLaunchPermissionConfiguration {
        /**
         * The ARN for an Amazon Web Services Organization that you want to share your AMI with.
         */
        organizationArns?: string[];
        /**
         * The ARN for an Organizations organizational unit (OU) that you want to share your AMI with.
         */
        organizationalUnitArns?: string[];
        /**
         * The name of the group.
         */
        userGroups?: string[];
        /**
         * The AWS account ID.
         */
        userIds?: string[];
    }
    /**
     * launchTemplateConfiguration settings that apply to image distribution.
     */
    interface DistributionConfigurationLaunchTemplateConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId?: string;
        /**
         * Identifies the EC2 launch template to use.
         */
        launchTemplateId?: string;
        /**
         * Set the specified EC2 launch template as the default launch template for the specified account.
         */
        setDefaultVersion?: boolean;
    }
    /**
     * The destination repository for the container image.
     */
    interface DistributionConfigurationTargetContainerRepository {
        /**
         * The repository name of target container repository.
         */
        repositoryName?: string;
        /**
         * The service of target container repository.
         */
        service?: enums.imagebuilder.DistributionConfigurationTargetContainerRepositoryService;
    }
    /**
     * Image tests configuration.
     */
    interface ImagePipelineImageTestsConfiguration {
        /**
         * Defines if tests should be executed when building this image.
         */
        imageTestsEnabled?: boolean;
        /**
         * The maximum time in minutes that tests are permitted to run.
         */
        timeoutMinutes?: number;
    }
    /**
     * The schedule of the image pipeline.
     */
    interface ImagePipelineSchedule {
        /**
         * The condition configures when the pipeline should trigger a new image build.
         */
        pipelineExecutionStartCondition?: enums.imagebuilder.ImagePipelineSchedulePipelineExecutionStartCondition;
        /**
         * The expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition.
         */
        scheduleExpression?: string;
    }
    /**
     * Specify additional settings and launch scripts for your build instances.
     */
    interface ImageRecipeAdditionalInstanceConfiguration {
        /**
         * Contains settings for the SSM agent on your build instance.
         */
        systemsManagerAgent?: outputs.imagebuilder.ImageRecipeSystemsManagerAgent;
        /**
         * Use this property to provide commands or a command script to run when you launch your build instance.
         */
        userDataOverride?: string;
    }
    /**
     * Configuration details of the component.
     */
    interface ImageRecipeComponentConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn?: string;
        /**
         * A group of parameter settings that are used to configure the component for a specific recipe.
         */
        parameters?: outputs.imagebuilder.ImageRecipeComponentParameter[];
    }
    /**
     * Contains a key/value pair that sets the named component parameter.
     */
    interface ImageRecipeComponentParameter {
        /**
         * The name of the component parameter to set.
         */
        name: string;
        /**
         * Sets the value for the named component parameter.
         */
        value: string[];
    }
    /**
     * Amazon EBS-specific block device mapping specifications.
     */
    interface ImageRecipeEbsInstanceBlockDeviceSpecification {
        /**
         * Use to configure delete on termination of the associated device.
         */
        deleteOnTermination?: boolean;
        /**
         * Use to configure device encryption.
         */
        encrypted?: boolean;
        /**
         * Use to configure device IOPS.
         */
        iops?: number;
        /**
         * Use to configure the KMS key to use when encrypting the device.
         */
        kmsKeyId?: string;
        /**
         * The snapshot that defines the device contents.
         */
        snapshotId?: string;
        /**
         * For GP3 volumes only - The throughput in MiB/s that the volume supports.
         */
        throughput?: number;
        /**
         * Use to override the device's volume size.
         */
        volumeSize?: number;
        /**
         * Use to override the device's volume type.
         */
        volumeType?: enums.imagebuilder.ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType;
    }
    /**
     * Defines block device mappings for the instance used to configure your image.
     */
    interface ImageRecipeInstanceBlockDeviceMapping {
        /**
         * The device to which these mappings apply.
         */
        deviceName?: string;
        /**
         * Use to manage Amazon EBS-specific configuration for this mapping.
         */
        ebs?: outputs.imagebuilder.ImageRecipeEbsInstanceBlockDeviceSpecification;
        /**
         * Use to remove a mapping from the parent image.
         */
        noDevice?: string;
        /**
         * Use to manage instance ephemeral devices.
         */
        virtualName?: string;
    }
    /**
     * Contains settings for the SSM agent on your build instance.
     */
    interface ImageRecipeSystemsManagerAgent {
        /**
         * Controls whether the SSM agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
         */
        uninstallAfterBuild?: boolean;
    }
    /**
     * The image tests configuration used when creating this image.
     */
    interface ImageTestsConfiguration {
        /**
         * ImageTestsEnabled
         */
        imageTestsEnabled?: boolean;
        /**
         * TimeoutMinutes
         */
        timeoutMinutes?: number;
    }
    /**
     * The instance metadata option settings for the infrastructure configuration.
     */
    interface InfrastructureConfigurationInstanceMetadataOptions {
        /**
         * Limit the number of hops that an instance metadata request can traverse to reach its destination.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows:
         */
        httpTokens?: enums.imagebuilder.InfrastructureConfigurationInstanceMetadataOptionsHttpTokens;
    }
    /**
     * The logging configuration of the infrastructure configuration.
     */
    interface InfrastructureConfigurationLogging {
        s3Logs?: outputs.imagebuilder.InfrastructureConfigurationS3Logs;
    }
    /**
     * The S3 path in which to store the logs.
     */
    interface InfrastructureConfigurationS3Logs {
        /**
         * S3BucketName
         */
        s3BucketName?: string;
        /**
         * S3KeyPrefix
         */
        s3KeyPrefix?: string;
    }
}
export declare namespace inspector {
    interface AssessmentTemplateTag {
        key: string;
        value: string;
    }
    interface ResourceGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace inspectorv2 {
    interface FilterCriteria {
        awsAccountId?: outputs.inspectorv2.FilterStringFilter[];
        componentId?: outputs.inspectorv2.FilterStringFilter[];
        componentType?: outputs.inspectorv2.FilterStringFilter[];
        ec2InstanceImageId?: outputs.inspectorv2.FilterStringFilter[];
        ec2InstanceSubnetId?: outputs.inspectorv2.FilterStringFilter[];
        ec2InstanceVpcId?: outputs.inspectorv2.FilterStringFilter[];
        ecrImageArchitecture?: outputs.inspectorv2.FilterStringFilter[];
        ecrImageHash?: outputs.inspectorv2.FilterStringFilter[];
        ecrImagePushedAt?: outputs.inspectorv2.FilterDateFilter[];
        ecrImageRegistry?: outputs.inspectorv2.FilterStringFilter[];
        ecrImageRepositoryName?: outputs.inspectorv2.FilterStringFilter[];
        ecrImageTags?: outputs.inspectorv2.FilterStringFilter[];
        findingArn?: outputs.inspectorv2.FilterStringFilter[];
        findingStatus?: outputs.inspectorv2.FilterStringFilter[];
        findingType?: outputs.inspectorv2.FilterStringFilter[];
        firstObservedAt?: outputs.inspectorv2.FilterDateFilter[];
        inspectorScore?: outputs.inspectorv2.FilterNumberFilter[];
        lastObservedAt?: outputs.inspectorv2.FilterDateFilter[];
        networkProtocol?: outputs.inspectorv2.FilterStringFilter[];
        portRange?: outputs.inspectorv2.FilterPortRangeFilter[];
        relatedVulnerabilities?: outputs.inspectorv2.FilterStringFilter[];
        resourceId?: outputs.inspectorv2.FilterStringFilter[];
        resourceTags?: outputs.inspectorv2.FilterMapFilter[];
        resourceType?: outputs.inspectorv2.FilterStringFilter[];
        severity?: outputs.inspectorv2.FilterStringFilter[];
        title?: outputs.inspectorv2.FilterStringFilter[];
        updatedAt?: outputs.inspectorv2.FilterDateFilter[];
        vendorSeverity?: outputs.inspectorv2.FilterStringFilter[];
        vulnerabilityId?: outputs.inspectorv2.FilterStringFilter[];
        vulnerabilitySource?: outputs.inspectorv2.FilterStringFilter[];
        vulnerablePackages?: outputs.inspectorv2.FilterPackageFilter[];
    }
    interface FilterDateFilter {
        endInclusive?: number;
        startInclusive?: number;
    }
    interface FilterMapFilter {
        comparison: enums.inspectorv2.FilterMapComparison;
        key?: string;
        value?: string;
    }
    interface FilterNumberFilter {
        lowerInclusive?: number;
        upperInclusive?: number;
    }
    interface FilterPackageFilter {
        architecture?: outputs.inspectorv2.FilterStringFilter;
        epoch?: outputs.inspectorv2.FilterNumberFilter;
        name?: outputs.inspectorv2.FilterStringFilter;
        release?: outputs.inspectorv2.FilterStringFilter;
        sourceLayerHash?: outputs.inspectorv2.FilterStringFilter;
        version?: outputs.inspectorv2.FilterStringFilter;
    }
    interface FilterPortRangeFilter {
        beginInclusive?: number;
        endInclusive?: number;
    }
    interface FilterStringFilter {
        comparison: enums.inspectorv2.FilterStringComparison;
        value: string;
    }
}
export declare namespace iot {
    /**
     * The criteria that determine when and how a job abort takes place.
     */
    interface AbortConfigProperties {
        criteriaList: outputs.iot.JobTemplateAbortCriteria[];
    }
    /**
     * The configuration for a specific audit check.
     */
    interface AccountAuditConfigurationAuditCheckConfiguration {
        /**
         * True if the check is enabled.
         */
        enabled?: boolean;
    }
    /**
     * Specifies which audit checks are enabled and disabled for this account.
     */
    interface AccountAuditConfigurationAuditCheckConfigurations {
        authenticatedCognitoRoleOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        caCertificateExpiringCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        caCertificateKeyQualityCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        conflictingClientIdsCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        deviceCertificateExpiringCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        deviceCertificateKeyQualityCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        deviceCertificateSharedCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        iotPolicyOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        iotRoleAliasAllowsAccessToUnusedServicesCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        iotRoleAliasOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        loggingDisabledCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        revokedCaCertificateStillActiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        revokedDeviceCertificateStillActiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        unauthenticatedCognitoRoleOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
    }
    interface AccountAuditConfigurationAuditNotificationTarget {
        /**
         * True if notifications to the target are enabled.
         */
        enabled?: boolean;
        /**
         * The ARN of the role that grants permission to send notifications to the target.
         */
        roleArn?: string;
        /**
         * The ARN of the target (SNS topic) to which audit notifications are sent.
         */
        targetArn?: string;
    }
    /**
     * Information about the targets to which audit notifications are sent.
     */
    interface AccountAuditConfigurationAuditNotificationTargetConfigurations {
        sns?: outputs.iot.AccountAuditConfigurationAuditNotificationTarget;
    }
    interface AuthorizerTag {
        key: string;
        value: string;
    }
    interface CACertificateRegistrationConfig {
        roleArn?: string;
        templateBody?: string;
        templateName?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface CACertificateTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface CustomMetricTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DimensionTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }
    interface DomainConfigurationAuthorizerConfig {
        allowAuthorizerOverride?: boolean;
        defaultAuthorizerName?: string;
    }
    interface DomainConfigurationServerCertificateSummary {
        serverCertificateArn?: string;
        serverCertificateStatus?: enums.iot.DomainConfigurationServerCertificateSummaryServerCertificateStatus;
        serverCertificateStatusDetail?: string;
    }
    interface DomainConfigurationTag {
        key: string;
        value: string;
    }
    /**
     * Aggregation types supported by Fleet Indexing
     */
    interface FleetMetricAggregationType {
        /**
         * Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
         */
        name: string;
        /**
         * Fleet Indexing aggregation type values
         */
        values: string[];
    }
    /**
     * A key-value pair to associate with a resource
     */
    interface FleetMetricTag {
        /**
         * The tag's key
         */
        key: string;
        /**
         * The tag's value
         */
        value: string;
    }
    interface JobExecutionsRetryConfigProperties {
        retryCriteriaList?: outputs.iot.JobTemplateRetryCriteria[];
    }
    /**
     * Allows you to create a staged rollout of a job.
     */
    interface JobExecutionsRolloutConfigProperties {
        /**
         * The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
         */
        exponentialRolloutRate?: outputs.iot.JobTemplateExponentialRolloutRate;
        /**
         * The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
         */
        maximumPerMinute?: number;
    }
    /**
     * The criteria that determine when and how a job abort takes place.
     */
    interface JobTemplateAbortCriteria {
        /**
         * The type of job action to take to initiate the job abort.
         */
        action: enums.iot.JobTemplateAction;
        /**
         * The type of job execution failures that can initiate a job abort.
         */
        failureType: enums.iot.JobTemplateFailureType;
        /**
         * The minimum number of things which must receive job execution notifications before the job can be aborted.
         */
        minNumberOfExecutedThings: number;
        /**
         * The minimum percentage of job execution failures that must occur to initiate the job abort.
         */
        thresholdPercentage: number;
    }
    /**
     * Allows you to create an exponential rate of rollout for a job.
     */
    interface JobTemplateExponentialRolloutRate {
        /**
         * The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
         */
        baseRatePerMinute: number;
        /**
         * The exponential factor to increase the rate of rollout for a job.
         */
        incrementFactor: number;
        /**
         * The criteria to initiate the increase in rate of rollout for a job.
         */
        rateIncreaseCriteria: outputs.iot.JobTemplateRateIncreaseCriteria;
    }
    interface JobTemplateRateIncreaseCriteria {
        numberOfNotifiedThings?: number;
        numberOfSucceededThings?: number;
    }
    /**
     * Specifies how many times a failure type should be retried.
     */
    interface JobTemplateRetryCriteria {
        failureType?: enums.iot.JobTemplateJobRetryFailureType;
        numberOfRetries?: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface JobTemplateTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }
    /**
     * The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
     */
    interface MitigationActionActionParams {
        addThingsToThingGroupParams?: outputs.iot.MitigationActionAddThingsToThingGroupParams;
        enableIoTLoggingParams?: outputs.iot.MitigationActionEnableIoTLoggingParams;
        publishFindingToSnsParams?: outputs.iot.MitigationActionPublishFindingToSnsParams;
        replaceDefaultPolicyVersionParams?: outputs.iot.MitigationActionReplaceDefaultPolicyVersionParams;
        updateCACertificateParams?: outputs.iot.MitigationActionUpdateCACertificateParams;
        updateDeviceCertificateParams?: outputs.iot.MitigationActionUpdateDeviceCertificateParams;
    }
    /**
     * Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
     */
    interface MitigationActionAddThingsToThingGroupParams {
        /**
         * Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
         */
        overrideDynamicGroups?: boolean;
        /**
         * The list of groups to which you want to add the things that triggered the mitigation action.
         */
        thingGroupNames: string[];
    }
    /**
     * Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
     */
    interface MitigationActionEnableIoTLoggingParams {
        /**
         *  Specifies which types of information are logged.
         */
        logLevel: enums.iot.MitigationActionEnableIoTLoggingParamsLogLevel;
        /**
         *  The ARN of the IAM role used for logging.
         */
        roleArnForLogging: string;
    }
    /**
     * Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
     */
    interface MitigationActionPublishFindingToSnsParams {
        /**
         * The ARN of the topic to which you want to publish the findings.
         */
        topicArn: string;
    }
    /**
     * Parameters to define a mitigation action that adds a blank policy to restrict permissions.
     */
    interface MitigationActionReplaceDefaultPolicyVersionParams {
        templateName: enums.iot.MitigationActionReplaceDefaultPolicyVersionParamsTemplateName;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface MitigationActionTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }
    /**
     * Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
     */
    interface MitigationActionUpdateCACertificateParams {
        action: enums.iot.MitigationActionUpdateCACertificateParamsAction;
    }
    /**
     * Parameters to define a mitigation action that changes the state of the device certificate to inactive.
     */
    interface MitigationActionUpdateDeviceCertificateParams {
        action: enums.iot.MitigationActionUpdateDeviceCertificateParamsAction;
    }
    /**
     * Configuration for pre-signed S3 URLs.
     */
    interface PresignedUrlConfigProperties {
        expiresInSec?: number;
        roleArn: string;
    }
    interface ProvisioningTemplateProvisioningHook {
        payloadVersion?: string;
        targetArn?: string;
    }
    interface ProvisioningTemplateTag {
        key: string;
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface RoleAliasTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ScheduledAuditTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }
    /**
     * A security profile behavior.
     */
    interface SecurityProfileBehavior {
        criteria?: outputs.iot.SecurityProfileBehaviorCriteria;
        /**
         * What is measured by the behavior.
         */
        metric?: string;
        metricDimension?: outputs.iot.SecurityProfileMetricDimension;
        /**
         * The name for the behavior.
         */
        name: string;
        /**
         * Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
         */
        suppressAlerts?: boolean;
    }
    /**
     * The criteria by which the behavior is determined to be normal.
     */
    interface SecurityProfileBehaviorCriteria {
        /**
         * The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
         */
        comparisonOperator?: enums.iot.SecurityProfileBehaviorCriteriaComparisonOperator;
        /**
         * If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
         */
        consecutiveDatapointsToAlarm?: number;
        /**
         * If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
         */
        consecutiveDatapointsToClear?: number;
        /**
         * Use this to specify the time duration over which the behavior is evaluated.
         */
        durationSeconds?: number;
        mlDetectionConfig?: outputs.iot.SecurityProfileMachineLearningDetectionConfig;
        statisticalThreshold?: outputs.iot.SecurityProfileStatisticalThreshold;
        value?: outputs.iot.SecurityProfileMetricValue;
    }
    /**
     * The configuration of an ML Detect Security Profile.
     */
    interface SecurityProfileMachineLearningDetectionConfig {
        /**
         * The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
         */
        confidenceLevel?: enums.iot.SecurityProfileMachineLearningDetectionConfigConfidenceLevel;
    }
    /**
     * The dimension of a metric.
     */
    interface SecurityProfileMetricDimension {
        /**
         * A unique identifier for the dimension.
         */
        dimensionName: string;
        /**
         * Defines how the dimensionValues of a dimension are interpreted.
         */
        operator?: enums.iot.SecurityProfileMetricDimensionOperator;
    }
    /**
     * The metric you want to retain. Dimensions are optional.
     */
    interface SecurityProfileMetricToRetain {
        /**
         * What is measured by the behavior.
         */
        metric: string;
        metricDimension?: outputs.iot.SecurityProfileMetricDimension;
    }
    /**
     * The value to be compared with the metric.
     */
    interface SecurityProfileMetricValue {
        /**
         * If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
         */
        cidrs?: string[];
        /**
         * If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
         */
        count?: string;
        /**
         * The numeral value of a metric.
         */
        number?: number;
        /**
         * The numeral values of a metric.
         */
        numbers?: number[];
        /**
         * If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
         */
        ports?: number[];
        /**
         * The string values of a metric.
         */
        strings?: string[];
    }
    /**
     * A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
     */
    interface SecurityProfileStatisticalThreshold {
        /**
         * The percentile which resolves to a threshold value by which compliance with a behavior is determined
         */
        statistic?: enums.iot.SecurityProfileStatisticalThresholdStatistic;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface SecurityProfileTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }
    interface ThingAttributePayload {
        attributes?: any;
    }
    /**
     * Specifies the amount of time each device has to finish its execution of the job.
     */
    interface TimeoutConfigProperties {
        inProgressTimeoutInMinutes: number;
    }
    interface TopicRuleAction {
        cloudwatchAlarm?: outputs.iot.TopicRuleCloudwatchAlarmAction;
        cloudwatchLogs?: outputs.iot.TopicRuleCloudwatchLogsAction;
        cloudwatchMetric?: outputs.iot.TopicRuleCloudwatchMetricAction;
        dynamoDB?: outputs.iot.TopicRuleDynamoDBAction;
        dynamoDBv2?: outputs.iot.TopicRuleDynamoDBv2Action;
        elasticsearch?: outputs.iot.TopicRuleElasticsearchAction;
        firehose?: outputs.iot.TopicRuleFirehoseAction;
        http?: outputs.iot.TopicRuleHttpAction;
        iotAnalytics?: outputs.iot.TopicRuleIotAnalyticsAction;
        iotEvents?: outputs.iot.TopicRuleIotEventsAction;
        iotSiteWise?: outputs.iot.TopicRuleIotSiteWiseAction;
        kafka?: outputs.iot.TopicRuleKafkaAction;
        kinesis?: outputs.iot.TopicRuleKinesisAction;
        lambda?: outputs.iot.TopicRuleLambdaAction;
        location?: outputs.iot.TopicRuleLocationAction;
        openSearch?: outputs.iot.TopicRuleOpenSearchAction;
        republish?: outputs.iot.TopicRuleRepublishAction;
        s3?: outputs.iot.TopicRuleS3Action;
        sns?: outputs.iot.TopicRuleSnsAction;
        sqs?: outputs.iot.TopicRuleSqsAction;
        stepFunctions?: outputs.iot.TopicRuleStepFunctionsAction;
        timestream?: outputs.iot.TopicRuleTimestreamAction;
    }
    interface TopicRuleAssetPropertyTimestamp {
        offsetInNanos?: string;
        timeInSeconds: string;
    }
    interface TopicRuleAssetPropertyValue {
        quality?: string;
        timestamp: outputs.iot.TopicRuleAssetPropertyTimestamp;
        value: outputs.iot.TopicRuleAssetPropertyVariant;
    }
    interface TopicRuleAssetPropertyVariant {
        booleanValue?: string;
        doubleValue?: string;
        integerValue?: string;
        stringValue?: string;
    }
    interface TopicRuleCloudwatchAlarmAction {
        alarmName: string;
        roleArn: string;
        stateReason: string;
        stateValue: string;
    }
    interface TopicRuleCloudwatchLogsAction {
        logGroupName: string;
        roleArn: string;
    }
    interface TopicRuleCloudwatchMetricAction {
        metricName: string;
        metricNamespace: string;
        metricTimestamp?: string;
        metricUnit: string;
        metricValue: string;
        roleArn: string;
    }
    interface TopicRuleDestinationHttpUrlDestinationSummary {
        confirmationUrl?: string;
    }
    interface TopicRuleDestinationVpcDestinationProperties {
        roleArn?: string;
        securityGroups?: string[];
        subnetIds?: string[];
        vpcId?: string;
    }
    interface TopicRuleDynamoDBAction {
        hashKeyField: string;
        hashKeyType?: string;
        hashKeyValue: string;
        payloadField?: string;
        rangeKeyField?: string;
        rangeKeyType?: string;
        rangeKeyValue?: string;
        roleArn: string;
        tableName: string;
    }
    interface TopicRuleDynamoDBv2Action {
        putItem?: outputs.iot.TopicRulePutItemInput;
        roleArn?: string;
    }
    interface TopicRuleElasticsearchAction {
        endpoint: string;
        id: string;
        index: string;
        roleArn: string;
        type: string;
    }
    interface TopicRuleFirehoseAction {
        batchMode?: boolean;
        deliveryStreamName: string;
        roleArn: string;
        separator?: string;
    }
    interface TopicRuleHttpAction {
        auth?: outputs.iot.TopicRuleHttpAuthorization;
        confirmationUrl?: string;
        headers?: outputs.iot.TopicRuleHttpActionHeader[];
        url: string;
    }
    interface TopicRuleHttpActionHeader {
        key: string;
        value: string;
    }
    interface TopicRuleHttpAuthorization {
        sigv4?: outputs.iot.TopicRuleSigV4Authorization;
    }
    interface TopicRuleIotAnalyticsAction {
        batchMode?: boolean;
        channelName: string;
        roleArn: string;
    }
    interface TopicRuleIotEventsAction {
        batchMode?: boolean;
        inputName: string;
        messageId?: string;
        roleArn: string;
    }
    interface TopicRuleIotSiteWiseAction {
        putAssetPropertyValueEntries: outputs.iot.TopicRulePutAssetPropertyValueEntry[];
        roleArn: string;
    }
    interface TopicRuleKafkaAction {
        clientProperties: any;
        destinationArn: string;
        key?: string;
        partition?: string;
        topic: string;
    }
    interface TopicRuleKinesisAction {
        partitionKey?: string;
        roleArn: string;
        streamName: string;
    }
    interface TopicRuleLambdaAction {
        functionArn?: string;
    }
    interface TopicRuleLocationAction {
        deviceId: string;
        latitude: string;
        longitude: string;
        roleArn: string;
        timestamp?: outputs.iot.TopicRuleTimestamp;
        trackerName: string;
    }
    interface TopicRuleOpenSearchAction {
        endpoint: string;
        id: string;
        index: string;
        roleArn: string;
        type: string;
    }
    interface TopicRulePayload {
        actions: outputs.iot.TopicRuleAction[];
        awsIotSqlVersion?: string;
        description?: string;
        errorAction?: outputs.iot.TopicRuleAction;
        ruleDisabled?: boolean;
        sql: string;
    }
    interface TopicRulePutAssetPropertyValueEntry {
        assetId?: string;
        entryId?: string;
        propertyAlias?: string;
        propertyId?: string;
        propertyValues: outputs.iot.TopicRuleAssetPropertyValue[];
    }
    interface TopicRulePutItemInput {
        tableName: string;
    }
    interface TopicRuleRepublishAction {
        headers?: outputs.iot.TopicRuleRepublishActionHeaders;
        qos?: number;
        roleArn: string;
        topic: string;
    }
    interface TopicRuleRepublishActionHeaders {
        contentType?: string;
        correlationData?: string;
        messageExpiry?: string;
        payloadFormatIndicator?: string;
        responseTopic?: string;
        userProperties?: outputs.iot.TopicRuleUserProperty[];
    }
    interface TopicRuleS3Action {
        bucketName: string;
        cannedAcl?: enums.iot.TopicRuleCannedAccessControlList;
        key: string;
        roleArn: string;
    }
    interface TopicRuleSigV4Authorization {
        roleArn: string;
        serviceName: string;
        signingRegion: string;
    }
    interface TopicRuleSnsAction {
        messageFormat?: string;
        roleArn: string;
        targetArn: string;
    }
    interface TopicRuleSqsAction {
        queueUrl: string;
        roleArn: string;
        useBase64?: boolean;
    }
    interface TopicRuleStepFunctionsAction {
        executionNamePrefix?: string;
        roleArn: string;
        stateMachineName: string;
    }
    interface TopicRuleTag {
        key: string;
        value: string;
    }
    interface TopicRuleTimestamp {
        unit?: string;
        value: string;
    }
    interface TopicRuleTimestreamAction {
        databaseName: string;
        dimensions: outputs.iot.TopicRuleTimestreamDimension[];
        roleArn: string;
        tableName: string;
        timestamp?: outputs.iot.TopicRuleTimestreamTimestamp;
    }
    interface TopicRuleTimestreamDimension {
        name: string;
        value: string;
    }
    interface TopicRuleTimestreamTimestamp {
        unit: string;
        value: string;
    }
    interface TopicRuleUserProperty {
        key: string;
        value: string;
    }
}
export declare namespace iot1click {
    interface ProjectPlacementTemplate {
        defaultAttributes?: any;
        deviceTemplates?: any;
    }
}
export declare namespace iotanalytics {
    interface ChannelCustomerManagedS3 {
        bucket: string;
        keyPrefix?: string;
        roleArn: string;
    }
    interface ChannelRetentionPeriod {
        numberOfDays?: number;
        unlimited?: boolean;
    }
    interface ChannelServiceManagedS3 {
    }
    interface ChannelStorage {
        customerManagedS3?: outputs.iotanalytics.ChannelCustomerManagedS3;
        serviceManagedS3?: outputs.iotanalytics.ChannelServiceManagedS3;
    }
    interface ChannelTag {
        key: string;
        value: string;
    }
    interface DatasetAction {
        actionName: string;
        containerAction?: outputs.iotanalytics.DatasetContainerAction;
        queryAction?: outputs.iotanalytics.DatasetQueryAction;
    }
    interface DatasetContainerAction {
        executionRoleArn: string;
        image: string;
        resourceConfiguration: outputs.iotanalytics.DatasetResourceConfiguration;
        variables?: outputs.iotanalytics.DatasetVariable[];
    }
    interface DatasetContentDeliveryRule {
        destination: outputs.iotanalytics.DatasetContentDeliveryRuleDestination;
        entryName?: string;
    }
    interface DatasetContentDeliveryRuleDestination {
        iotEventsDestinationConfiguration?: outputs.iotanalytics.DatasetIotEventsDestinationConfiguration;
        s3DestinationConfiguration?: outputs.iotanalytics.DatasetS3DestinationConfiguration;
    }
    interface DatasetContentVersionValue {
        datasetName: string;
    }
    interface DatasetDeltaTime {
        offsetSeconds: number;
        timeExpression: string;
    }
    interface DatasetDeltaTimeSessionWindowConfiguration {
        timeoutInMinutes: number;
    }
    interface DatasetFilter {
        deltaTime?: outputs.iotanalytics.DatasetDeltaTime;
    }
    interface DatasetGlueConfiguration {
        databaseName: string;
        tableName: string;
    }
    interface DatasetIotEventsDestinationConfiguration {
        inputName: string;
        roleArn: string;
    }
    interface DatasetLateDataRule {
        ruleConfiguration: outputs.iotanalytics.DatasetLateDataRuleConfiguration;
        ruleName?: string;
    }
    interface DatasetLateDataRuleConfiguration {
        deltaTimeSessionWindowConfiguration?: outputs.iotanalytics.DatasetDeltaTimeSessionWindowConfiguration;
    }
    interface DatasetOutputFileUriValue {
        fileName: string;
    }
    interface DatasetQueryAction {
        filters?: outputs.iotanalytics.DatasetFilter[];
        sqlQuery: string;
    }
    interface DatasetResourceConfiguration {
        computeType: enums.iotanalytics.DatasetResourceConfigurationComputeType;
        volumeSizeInGB: number;
    }
    interface DatasetRetentionPeriod {
        numberOfDays?: number;
        unlimited?: boolean;
    }
    interface DatasetS3DestinationConfiguration {
        bucket: string;
        glueConfiguration?: outputs.iotanalytics.DatasetGlueConfiguration;
        key: string;
        roleArn: string;
    }
    interface DatasetSchedule {
        scheduleExpression: string;
    }
    interface DatasetTag {
        key: string;
        value: string;
    }
    interface DatasetTrigger {
        schedule?: outputs.iotanalytics.DatasetSchedule;
        triggeringDataset?: outputs.iotanalytics.DatasetTriggeringDataset;
    }
    interface DatasetTriggeringDataset {
        datasetName: string;
    }
    interface DatasetVariable {
        datasetContentVersionValue?: outputs.iotanalytics.DatasetContentVersionValue;
        doubleValue?: number;
        outputFileUriValue?: outputs.iotanalytics.DatasetOutputFileUriValue;
        stringValue?: string;
        variableName: string;
    }
    interface DatasetVersioningConfiguration {
        maxVersions?: number;
        unlimited?: boolean;
    }
    interface DatastoreColumn {
        name: string;
        type: string;
    }
    interface DatastoreCustomerManagedS3 {
        bucket: string;
        keyPrefix?: string;
        roleArn: string;
    }
    interface DatastoreCustomerManagedS3Storage {
        bucket: string;
        keyPrefix?: string;
    }
    interface DatastoreFileFormatConfiguration {
        jsonConfiguration?: outputs.iotanalytics.DatastoreJsonConfiguration;
        parquetConfiguration?: outputs.iotanalytics.DatastoreParquetConfiguration;
    }
    interface DatastoreIotSiteWiseMultiLayerStorage {
        customerManagedS3Storage?: outputs.iotanalytics.DatastoreCustomerManagedS3Storage;
    }
    interface DatastoreJsonConfiguration {
    }
    interface DatastoreParquetConfiguration {
        schemaDefinition?: outputs.iotanalytics.DatastoreSchemaDefinition;
    }
    interface DatastorePartition {
        partition?: outputs.iotanalytics.DatastorePartition;
        timestampPartition?: outputs.iotanalytics.DatastoreTimestampPartition;
    }
    interface DatastorePartitions {
        partitions?: outputs.iotanalytics.DatastorePartition[];
    }
    interface DatastoreRetentionPeriod {
        numberOfDays?: number;
        unlimited?: boolean;
    }
    interface DatastoreSchemaDefinition {
        columns?: outputs.iotanalytics.DatastoreColumn[];
    }
    interface DatastoreServiceManagedS3 {
    }
    interface DatastoreStorage {
        customerManagedS3?: outputs.iotanalytics.DatastoreCustomerManagedS3;
        iotSiteWiseMultiLayerStorage?: outputs.iotanalytics.DatastoreIotSiteWiseMultiLayerStorage;
        serviceManagedS3?: outputs.iotanalytics.DatastoreServiceManagedS3;
    }
    interface DatastoreTag {
        key: string;
        value: string;
    }
    interface DatastoreTimestampPartition {
        attributeName: string;
        timestampFormat?: string;
    }
    interface PipelineActivity {
        addAttributes?: outputs.iotanalytics.PipelineAddAttributes;
        channel?: outputs.iotanalytics.PipelineChannel;
        datastore?: outputs.iotanalytics.PipelineDatastore;
        deviceRegistryEnrich?: outputs.iotanalytics.PipelineDeviceRegistryEnrich;
        deviceShadowEnrich?: outputs.iotanalytics.PipelineDeviceShadowEnrich;
        filter?: outputs.iotanalytics.PipelineFilter;
        lambda?: outputs.iotanalytics.PipelineLambda;
        math?: outputs.iotanalytics.PipelineMath;
        removeAttributes?: outputs.iotanalytics.PipelineRemoveAttributes;
        selectAttributes?: outputs.iotanalytics.PipelineSelectAttributes;
    }
    interface PipelineAddAttributes {
        attributes: any;
        name: string;
        next?: string;
    }
    interface PipelineChannel {
        channelName: string;
        name: string;
        next?: string;
    }
    interface PipelineDatastore {
        datastoreName: string;
        name: string;
    }
    interface PipelineDeviceRegistryEnrich {
        attribute: string;
        name: string;
        next?: string;
        roleArn: string;
        thingName: string;
    }
    interface PipelineDeviceShadowEnrich {
        attribute: string;
        name: string;
        next?: string;
        roleArn: string;
        thingName: string;
    }
    interface PipelineFilter {
        filter: string;
        name: string;
        next?: string;
    }
    interface PipelineLambda {
        batchSize: number;
        lambdaName: string;
        name: string;
        next?: string;
    }
    interface PipelineMath {
        attribute: string;
        math: string;
        name: string;
        next?: string;
    }
    interface PipelineRemoveAttributes {
        attributes: string[];
        name: string;
        next?: string;
    }
    interface PipelineSelectAttributes {
        attributes: string[];
        name: string;
        next?: string;
    }
    interface PipelineTag {
        key: string;
        value: string;
    }
}
export declare namespace iotcoredeviceadvisor {
    interface SuiteDefinitionConfigurationProperties {
        devicePermissionRoleArn: string;
        devices?: outputs.iotcoredeviceadvisor.SuiteDefinitionDeviceUnderTest[];
        intendedForQualification?: boolean;
        rootGroup: string;
        suiteDefinitionName?: string;
    }
    interface SuiteDefinitionDeviceUnderTest {
        certificateArn?: string;
        thingArn?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface SuiteDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace iotevents {
    /**
     * Specifies whether to get notified for alarm state changes.
     */
    interface AlarmModelAcknowledgeFlow {
        /**
         * The value must be TRUE or FALSE. If TRUE, you receive a notification when the alarm state changes. You must choose to acknowledge the notification before the alarm state can return to NORMAL. If FALSE, you won't receive notifications. The alarm automatically changes to the NORMAL state when the input property value returns to the specified range.
         */
        enabled?: boolean;
    }
    /**
     * The actions to be performed.
     */
    interface AlarmModelAlarmAction {
        dynamoDB?: outputs.iotevents.AlarmModelDynamoDB;
        dynamoDBv2?: outputs.iotevents.AlarmModelDynamoDBv2;
        firehose?: outputs.iotevents.AlarmModelFirehose;
        iotEvents?: outputs.iotevents.AlarmModelIotEvents;
        iotSiteWise?: outputs.iotevents.AlarmModelIotSiteWise;
        iotTopicPublish?: outputs.iotevents.AlarmModelIotTopicPublish;
        lambda?: outputs.iotevents.AlarmModelLambda;
        sns?: outputs.iotevents.AlarmModelSns;
        sqs?: outputs.iotevents.AlarmModelSqs;
    }
    /**
     * Contains the configuration information of alarm state changes
     */
    interface AlarmModelAlarmCapabilities {
        acknowledgeFlow?: outputs.iotevents.AlarmModelAcknowledgeFlow;
        initializationConfiguration?: outputs.iotevents.AlarmModelInitializationConfiguration;
    }
    /**
     * Contains information about one or more alarm actions.
     */
    interface AlarmModelAlarmEventActions {
        alarmActions?: outputs.iotevents.AlarmModelAlarmAction[];
    }
    /**
     * Defines when your alarm is invoked.
     */
    interface AlarmModelAlarmRule {
        simpleRule?: outputs.iotevents.AlarmModelSimpleRule;
    }
    /**
     * A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the *AWS IoT SiteWise API Reference*.
     */
    interface AlarmModelAssetPropertyTimestamp {
        /**
         * The timestamp, in seconds, in the Unix epoch format. The valid range is between `1-31556889864403199`. You can also specify an expression.
         */
        offsetInNanos?: string;
        /**
         * The nanosecond offset converted from `timeInSeconds`. The valid range is between `0-999999999`. You can also specify an expression.
         */
        timeInSeconds: string;
    }
    /**
     * A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the *AWS IoT SiteWise API Reference*.
     */
    interface AlarmModelAssetPropertyValue {
        /**
         * The quality of the asset property value. The value must be `GOOD`, `BAD`, or `UNCERTAIN`. You can also specify an expression.
         */
        quality?: string;
        timestamp?: outputs.iotevents.AlarmModelAssetPropertyTimestamp;
        value: outputs.iotevents.AlarmModelAssetPropertyVariant;
    }
    /**
     * A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the *AWS IoT SiteWise API Reference*.
     */
    interface AlarmModelAssetPropertyVariant {
        /**
         * The asset property value is a Boolean value that must be `TRUE` or `FALSE`. You can also specify an expression. If you use an expression, the evaluated result should be a Boolean value.
         */
        booleanValue?: string;
        /**
         * The asset property value is a double. You can also specify an expression. If you use an expression, the evaluated result should be a double.
         */
        doubleValue?: string;
        /**
         * The asset property value is an integer. You can also specify an expression. If you use an expression, the evaluated result should be an integer.
         */
        integerValue?: string;
        /**
         * The asset property value is a string. You can also specify an expression. If you use an expression, the evaluated result should be a string.
         */
        stringValue?: string;
    }
    /**
     * Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the alarm model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in *AWS IoT Events Developer Guide*.
     */
    interface AlarmModelDynamoDB {
        /**
         * The name of the hash key (also called the partition key).
         */
        hashKeyField: string;
        /**
         * The data type for the hash key (also called the partition key). You can specify the following values:
         *
         * * `STRING` - The hash key is a string.
         *
         * * `NUMBER` - The hash key is a number.
         *
         * If you don't specify `hashKeyType`, the default value is `STRING`.
         */
        hashKeyType?: string;
        /**
         * The value of the hash key (also called the partition key).
         */
        hashKeyValue: string;
        /**
         * The type of operation to perform. You can specify the following values:
         *
         * * `INSERT` - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
         *
         * * `UPDATE` - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * * `DELETE` - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * If you don't specify this parameter, AWS IoT Events triggers the `INSERT` operation.
         */
        operation?: string;
        payload?: outputs.iotevents.AlarmModelPayload;
        /**
         * The name of the DynamoDB column that receives the action payload.
         *
         * If you don't specify this parameter, the name of the DynamoDB column is `payload`.
         */
        payloadField?: string;
        /**
         * The name of the range key (also called the sort key).
         */
        rangeKeyField?: string;
        /**
         * The data type for the range key (also called the sort key), You can specify the following values:
         *
         * * `STRING` - The range key is a string.
         *
         * * `NUMBER` - The range key is number.
         *
         * If you don't specify `rangeKeyField`, the default value is `STRING`.
         */
        rangeKeyType?: string;
        /**
         * The value of the range key (also called the sort key).
         */
        rangeKeyValue?: string;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    /**
     * Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the alarm model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify.
     *
     * You can use expressions for parameters that are strings. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the *AWS IoT Events Developer Guide*.
     */
    interface AlarmModelDynamoDBv2 {
        payload?: outputs.iotevents.AlarmModelPayload;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    /**
     * Sends information about the alarm model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
     */
    interface AlarmModelFirehose {
        /**
         * The name of the Kinesis Data Firehose delivery stream where the data is written.
         */
        deliveryStreamName: string;
        payload?: outputs.iotevents.AlarmModelPayload;
        /**
         * A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: string;
    }
    /**
     * Specifies the default alarm state. The configuration applies to all alarms that were created based on this alarm model.
     */
    interface AlarmModelInitializationConfiguration {
        /**
         * The value must be TRUE or FALSE. If FALSE, all alarm instances created based on the alarm model are activated. The default value is TRUE.
         */
        disabledOnInitialization: boolean;
    }
    /**
     * Sends an AWS IoT Events input, passing in information about the alarm model instance and the event that triggered the action.
     */
    interface AlarmModelIotEvents {
        /**
         * The name of the AWS IoT Events input where the data is sent.
         */
        inputName: string;
        payload?: outputs.iotevents.AlarmModelPayload;
    }
    /**
     * Sends information about the alarm model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise.
     */
    interface AlarmModelIotSiteWise {
        /**
         * The ID of the asset that has the specified property. You can specify an expression.
         */
        assetId?: string;
        /**
         * A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier. You can also specify an expression.
         */
        entryId?: string;
        /**
         * The alias of the asset property. You can also specify an expression.
         */
        propertyAlias?: string;
        /**
         * The ID of the asset property. You can specify an expression.
         */
        propertyId?: string;
        propertyValue?: outputs.iotevents.AlarmModelAssetPropertyValue;
    }
    /**
     * Information required to publish the MQTT message through the AWS IoT message broker.
     */
    interface AlarmModelIotTopicPublish {
        /**
         * The MQTT topic of the message. You can use a string expression that includes variables (`$variable.<variable-name>`) and input values (`$input.<input-name>.<path-to-datum>`) as the topic string.
         */
        mqttTopic: string;
        payload?: outputs.iotevents.AlarmModelPayload;
    }
    interface AlarmModelLambda {
        /**
         * The ARN of the Lambda function that is executed.
         */
        functionArn: string;
        payload?: outputs.iotevents.AlarmModelPayload;
    }
    /**
     * Information needed to configure the payload.
     *
     * By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the alarm model instance and the event triggered the action. To configure the action payload, you can use `contentExpression`.
     */
    interface AlarmModelPayload {
        /**
         * The content of the payload. You can use a string expression that includes quoted strings (`'<string>'`), variables (`$variable.<variable-name>`), input values (`$input.<input-name>.<path-to-datum>`), string concatenations, and quoted strings that contain `${}` as the content. The recommended maximum size of a content expression is 1 KB.
         */
        contentExpression: string;
        /**
         * The value of the payload type can be either `STRING` or `JSON`.
         */
        type: string;
    }
    /**
     * A rule that compares an input property value to a threshold value with a comparison operator.
     */
    interface AlarmModelSimpleRule {
        /**
         * The comparison operator.
         */
        comparisonOperator: enums.iotevents.AlarmModelSimpleRuleComparisonOperator;
        /**
         * The value on the left side of the comparison operator. You can specify an AWS IoT Events input attribute as an input property.
         */
        inputProperty: string;
        /**
         * The value on the right side of the comparison operator. You can enter a number or specify an AWS IoT Events input attribute.
         */
        threshold: string;
    }
    /**
     * Information required to publish the Amazon SNS message.
     */
    interface AlarmModelSns {
        payload?: outputs.iotevents.AlarmModelPayload;
        /**
         * The ARN of the Amazon SNS target where the message is sent.
         */
        targetArn: string;
    }
    interface AlarmModelSqs {
        payload?: outputs.iotevents.AlarmModelPayload;
        /**
         * The URL of the SQS queue where the data is written.
         */
        queueUrl: string;
        /**
         * Set this to `TRUE` if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to `FALSE`.
         */
        useBase64?: boolean;
    }
    /**
     * Tags to be applied to Input.
     */
    interface AlarmModelTag {
        /**
         * Key of the Tag.
         */
        key: string;
        /**
         * Value of the Tag.
         */
        value: string;
    }
    /**
     * The actions to be performed.
     */
    interface DetectorModelAction {
        clearTimer?: outputs.iotevents.DetectorModelClearTimer;
        dynamoDB?: outputs.iotevents.DetectorModelDynamoDB;
        dynamoDBv2?: outputs.iotevents.DetectorModelDynamoDBv2;
        firehose?: outputs.iotevents.DetectorModelFirehose;
        iotEvents?: outputs.iotevents.DetectorModelIotEvents;
        iotSiteWise?: outputs.iotevents.DetectorModelIotSiteWise;
        iotTopicPublish?: outputs.iotevents.DetectorModelIotTopicPublish;
        lambda?: outputs.iotevents.DetectorModelLambda;
        resetTimer?: outputs.iotevents.DetectorModelResetTimer;
        setTimer?: outputs.iotevents.DetectorModelSetTimer;
        setVariable?: outputs.iotevents.DetectorModelSetVariable;
        sns?: outputs.iotevents.DetectorModelSns;
        sqs?: outputs.iotevents.DetectorModelSqs;
    }
    /**
     * A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the *AWS IoT SiteWise API Reference*.
     */
    interface DetectorModelAssetPropertyTimestamp {
        /**
         * The timestamp, in seconds, in the Unix epoch format. The valid range is between `1-31556889864403199`. You can also specify an expression.
         */
        offsetInNanos?: string;
        /**
         * The nanosecond offset converted from `timeInSeconds`. The valid range is between `0-999999999`. You can also specify an expression.
         */
        timeInSeconds: string;
    }
    /**
     * A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the *AWS IoT SiteWise API Reference*.
     */
    interface DetectorModelAssetPropertyValue {
        /**
         * The quality of the asset property value. The value must be `GOOD`, `BAD`, or `UNCERTAIN`. You can also specify an expression.
         */
        quality?: string;
        timestamp?: outputs.iotevents.DetectorModelAssetPropertyTimestamp;
        value: outputs.iotevents.DetectorModelAssetPropertyVariant;
    }
    /**
     * A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the *AWS IoT SiteWise API Reference*.
     */
    interface DetectorModelAssetPropertyVariant {
        /**
         * The asset property value is a Boolean value that must be `TRUE` or `FALSE`. You can also specify an expression. If you use an expression, the evaluated result should be a Boolean value.
         */
        booleanValue?: string;
        /**
         * The asset property value is a double. You can also specify an expression. If you use an expression, the evaluated result should be a double.
         */
        doubleValue?: string;
        /**
         * The asset property value is an integer. You can also specify an expression. If you use an expression, the evaluated result should be an integer.
         */
        integerValue?: string;
        /**
         * The asset property value is a string. You can also specify an expression. If you use an expression, the evaluated result should be a string.
         */
        stringValue?: string;
    }
    /**
     * Information needed to clear the timer.
     */
    interface DetectorModelClearTimer {
        timerName: string;
    }
    /**
     * Information that defines how a detector operates.
     */
    interface DetectorModelDefinition {
        /**
         * The state that is entered at the creation of each detector (instance).
         */
        initialStateName: string;
        /**
         * Information about the states of the detector.
         */
        states: outputs.iotevents.DetectorModelState[];
    }
    /**
     * Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in *AWS IoT Events Developer Guide*.
     */
    interface DetectorModelDynamoDB {
        /**
         * The name of the hash key (also called the partition key).
         */
        hashKeyField: string;
        /**
         * The data type for the hash key (also called the partition key). You can specify the following values:
         *
         * * `STRING` - The hash key is a string.
         *
         * * `NUMBER` - The hash key is a number.
         *
         * If you don't specify `hashKeyType`, the default value is `STRING`.
         */
        hashKeyType?: string;
        /**
         * The value of the hash key (also called the partition key).
         */
        hashKeyValue: string;
        /**
         * The type of operation to perform. You can specify the following values:
         *
         * * `INSERT` - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
         *
         * * `UPDATE` - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * * `DELETE` - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * If you don't specify this parameter, AWS IoT Events triggers the `INSERT` operation.
         */
        operation?: string;
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The name of the DynamoDB column that receives the action payload.
         *
         * If you don't specify this parameter, the name of the DynamoDB column is `payload`.
         */
        payloadField?: string;
        /**
         * The name of the range key (also called the sort key).
         */
        rangeKeyField?: string;
        /**
         * The data type for the range key (also called the sort key), You can specify the following values:
         *
         * * `STRING` - The range key is a string.
         *
         * * `NUMBER` - The range key is number.
         *
         * If you don't specify `rangeKeyField`, the default value is `STRING`.
         */
        rangeKeyType?: string;
        /**
         * The value of the range key (also called the sort key).
         */
        rangeKeyValue?: string;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    /**
     * Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify.
     *
     * You can use expressions for parameters that are strings. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the *AWS IoT Events Developer Guide*.
     */
    interface DetectorModelDynamoDBv2 {
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    /**
     * Specifies the `actions` to be performed when the `condition` evaluates to `TRUE`.
     */
    interface DetectorModelEvent {
        /**
         * The actions to be performed.
         */
        actions?: outputs.iotevents.DetectorModelAction[];
        /**
         * The Boolean expression that, when `TRUE`, causes the `actions` to be performed. If not present, the `actions` are performed (=`TRUE`). If the expression result is not a `Boolean` value, the `actions` are not performed (=`FALSE`).
         */
        condition?: string;
        /**
         * The name of the event.
         */
        eventName: string;
    }
    /**
     * Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
     */
    interface DetectorModelFirehose {
        /**
         * The name of the Kinesis Data Firehose delivery stream where the data is written.
         */
        deliveryStreamName: string;
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: string;
    }
    /**
     * Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
     */
    interface DetectorModelIotEvents {
        /**
         * The name of the AWS IoT Events input where the data is sent.
         */
        inputName: string;
        payload?: outputs.iotevents.DetectorModelPayload;
    }
    /**
     * Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise.
     */
    interface DetectorModelIotSiteWise {
        /**
         * The ID of the asset that has the specified property. You can specify an expression.
         */
        assetId?: string;
        /**
         * A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier. You can also specify an expression.
         */
        entryId?: string;
        /**
         * The alias of the asset property. You can also specify an expression.
         */
        propertyAlias?: string;
        /**
         * The ID of the asset property. You can specify an expression.
         */
        propertyId?: string;
        propertyValue: outputs.iotevents.DetectorModelAssetPropertyValue;
    }
    /**
     * Information required to publish the MQTT message through the AWS IoT message broker.
     */
    interface DetectorModelIotTopicPublish {
        /**
         * The MQTT topic of the message. You can use a string expression that includes variables (`$variable.<variable-name>`) and input values (`$input.<input-name>.<path-to-datum>`) as the topic string.
         */
        mqttTopic: string;
        payload?: outputs.iotevents.DetectorModelPayload;
    }
    interface DetectorModelLambda {
        /**
         * The ARN of the Lambda function that is executed.
         */
        functionArn: string;
        payload?: outputs.iotevents.DetectorModelPayload;
    }
    /**
     * When entering this state, perform these `actions` if the `condition` is `TRUE`.
     */
    interface DetectorModelOnEnter {
        /**
         * Specifies the `actions` that are performed when the state is entered and the `condition` is `TRUE`.
         */
        events?: outputs.iotevents.DetectorModelEvent[];
    }
    /**
     * When exiting this state, perform these `actions` if the specified `condition` is `TRUE`.
     */
    interface DetectorModelOnExit {
        /**
         * Specifies the `actions` that are performed when the state is exited and the `condition` is `TRUE`.
         */
        events?: outputs.iotevents.DetectorModelEvent[];
    }
    /**
     * When an input is received and the `condition` is `TRUE`, perform the specified `actions`.
     */
    interface DetectorModelOnInput {
        /**
         * Specifies the `actions` performed when the `condition` evaluates to `TRUE`.
         */
        events?: outputs.iotevents.DetectorModelEvent[];
        /**
         * Specifies the `actions` performed, and the next `state` entered, when a `condition` evaluates to `TRUE`.
         */
        transitionEvents?: outputs.iotevents.DetectorModelTransitionEvent[];
    }
    /**
     * Information needed to configure the payload.
     *
     * By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use `contentExpression`.
     */
    interface DetectorModelPayload {
        /**
         * The content of the payload. You can use a string expression that includes quoted strings (`'<string>'`), variables (`$variable.<variable-name>`), input values (`$input.<input-name>.<path-to-datum>`), string concatenations, and quoted strings that contain `${}` as the content. The recommended maximum size of a content expression is 1 KB.
         */
        contentExpression: string;
        /**
         * The value of the payload type can be either `STRING` or `JSON`.
         */
        type: string;
    }
    /**
     * Information required to reset the timer. The timer is reset to the previously evaluated result of the duration. The duration expression isn't reevaluated when you reset the timer.
     */
    interface DetectorModelResetTimer {
        /**
         * The name of the timer to reset.
         */
        timerName: string;
    }
    /**
     * Information needed to set the timer.
     */
    interface DetectorModelSetTimer {
        /**
         * The duration of the timer, in seconds. You can use a string expression that includes numbers, variables (`$variable.<variable-name>`), and input values (`$input.<input-name>.<path-to-datum>`) as the duration. The range of the duration is `1-31622400` seconds. To ensure accuracy, the minimum duration is `60` seconds. The evaluated result of the duration is rounded down to the nearest whole number.
         */
        durationExpression?: string;
        /**
         * The number of seconds until the timer expires. The minimum value is `60` seconds to ensure accuracy. The maximum value is `31622400` seconds.
         */
        seconds?: number;
        /**
         * The name of the timer.
         */
        timerName: string;
    }
    /**
     * Information about the variable and its new value.
     */
    interface DetectorModelSetVariable {
        /**
         * The new value of the variable.
         */
        value: string;
        /**
         * The name of the variable.
         */
        variableName: string;
    }
    /**
     * Information required to publish the Amazon SNS message.
     */
    interface DetectorModelSns {
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The ARN of the Amazon SNS target where the message is sent.
         */
        targetArn: string;
    }
    interface DetectorModelSqs {
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The URL of the SQS queue where the data is written.
         */
        queueUrl: string;
        /**
         * Set this to `TRUE` if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to `FALSE`.
         */
        useBase64?: boolean;
    }
    /**
     * Information that defines a state of a detector.
     */
    interface DetectorModelState {
        onEnter?: outputs.iotevents.DetectorModelOnEnter;
        onExit?: outputs.iotevents.DetectorModelOnExit;
        onInput?: outputs.iotevents.DetectorModelOnInput;
        /**
         * The name of the state.
         */
        stateName: string;
    }
    /**
     * Tags to be applied to Input.
     */
    interface DetectorModelTag {
        /**
         * Key of the Tag.
         */
        key: string;
        /**
         * Value of the Tag.
         */
        value: string;
    }
    /**
     * Specifies the `actions `performed and the next `state` entered when a `condition` evaluates to `TRUE`.
     */
    interface DetectorModelTransitionEvent {
        /**
         * The actions to be performed.
         */
        actions?: outputs.iotevents.DetectorModelAction[];
        /**
         * A Boolean expression that when `TRUE` causes the `actions` to be performed and the `nextState` to be entered.
         */
        condition: string;
        /**
         * The name of the event.
         */
        eventName: string;
        /**
         * The next state to enter.
         */
        nextState: string;
    }
    /**
     * The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using `BatchPutMessage`. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the `condition` expressions used by detectors that monitor this input.
     */
    interface InputAttribute {
        /**
         * An expression that specifies an attribute-value pair in a JSON structure. Use this to specify an attribute from the JSON payload that is made available by the input. Inputs are derived from messages sent to AWS IoT Events (`BatchPutMessage`). Each such message contains a JSON payload. The attribute (and its paired value) specified here are available for use in the `condition` expressions used by detectors.
         *
         * _Syntax_: `<field-name>.<field-name>...`
         */
        jsonPath: string;
    }
    /**
     * The definition of the input.
     */
    interface InputDefinition {
        /**
         * The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using `BatchPutMessage`. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the `condition` expressions used by detectors that monitor this input.
         */
        attributes: outputs.iotevents.InputAttribute[];
    }
    /**
     * Tags to be applied to Input.
     */
    interface InputTag {
        /**
         * Key of the Tag.
         */
        key: string;
        /**
         * Value of the Tag.
         */
        value: string;
    }
}
export declare namespace iotfleethub {
    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted.
     */
    interface ApplicationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace iotfleetwise {
    interface CampaignCollectionScheme {
    }
    interface CampaignSignalInformation {
        maxSampleCount?: number;
        minimumSamplingIntervalMs?: number;
        name: string;
    }
    interface CampaignTag {
        key: string;
        value: string;
    }
    interface DecoderManifestCanInterface {
        name: string;
        protocolName?: string;
        protocolVersion?: string;
    }
    interface DecoderManifestCanNetworkInterface {
        canInterface: outputs.iotfleetwise.DecoderManifestCanInterface;
        interfaceId: string;
        type: enums.iotfleetwise.DecoderManifestCanNetworkInterfaceType;
    }
    interface DecoderManifestCanSignal {
        factor: number;
        isBigEndian: boolean;
        isSigned: boolean;
        length: number;
        messageId: number;
        name?: string;
        offset: number;
        startBit: number;
    }
    interface DecoderManifestCanSignalDecoder {
        canSignal: outputs.iotfleetwise.DecoderManifestCanSignal;
        fullyQualifiedName: string;
        interfaceId: string;
        type: enums.iotfleetwise.DecoderManifestCanSignalDecoderType;
    }
    interface DecoderManifestObdInterface {
        dtcRequestIntervalSeconds?: number;
        hasTransmissionEcu?: boolean;
        name: string;
        obdStandard?: string;
        pidRequestIntervalSeconds?: number;
        requestMessageId: number;
        useExtendedIds?: boolean;
    }
    interface DecoderManifestObdNetworkInterface {
        interfaceId: string;
        obdInterface: outputs.iotfleetwise.DecoderManifestObdInterface;
        type: enums.iotfleetwise.DecoderManifestObdNetworkInterfaceType;
    }
    interface DecoderManifestObdSignal {
        bitMaskLength?: number;
        bitRightShift?: number;
        byteLength: number;
        offset: number;
        pid: number;
        pidResponseLength: number;
        scaling: number;
        serviceMode: number;
        startByte: number;
    }
    interface DecoderManifestObdSignalDecoder {
        fullyQualifiedName: string;
        interfaceId: string;
        obdSignal: outputs.iotfleetwise.DecoderManifestObdSignal;
        type: enums.iotfleetwise.DecoderManifestObdSignalDecoderType;
    }
    interface DecoderManifestTag {
        key: string;
        value: string;
    }
    interface FleetTag {
        key: string;
        value: string;
    }
    interface ModelManifestTag {
        key: string;
        value: string;
    }
    interface SignalCatalogNode {
    }
    interface SignalCatalogNodeCounts {
        totalActuators?: number;
        totalAttributes?: number;
        totalBranches?: number;
        totalNodes?: number;
        totalSensors?: number;
    }
    interface SignalCatalogTag {
        key: string;
        value: string;
    }
    interface VehicleTag {
        key: string;
        value: string;
    }
    interface VehicleattributesMap {
    }
}
export declare namespace iotsitewise {
    /**
     * Contains information for an IAM role identity in an access policy.
     */
    interface AccessPolicyIamRole {
        /**
         * The ARN of the IAM role.
         */
        arn?: string;
    }
    /**
     * Contains information for an IAM user identity in an access policy.
     */
    interface AccessPolicyIamUser {
        /**
         * The ARN of the IAM user.
         */
        arn?: string;
    }
    /**
     * The identity for this access policy. Choose either an SSO user or group or an IAM user or role.
     */
    interface AccessPolicyIdentity {
        iamRole?: outputs.iotsitewise.AccessPolicyIamRole;
        iamUser?: outputs.iotsitewise.AccessPolicyIamUser;
        user?: outputs.iotsitewise.AccessPolicyUser;
    }
    /**
     * A portal resource.
     */
    interface AccessPolicyPortal {
        /**
         * The ID of the portal.
         */
        id?: string;
    }
    /**
     * A project resource.
     */
    interface AccessPolicyProject {
        /**
         * The ID of the project.
         */
        id?: string;
    }
    /**
     * The AWS IoT SiteWise Monitor resource for this access policy. Choose either portal or project but not both.
     */
    interface AccessPolicyResource {
        portal?: outputs.iotsitewise.AccessPolicyPortal;
        project?: outputs.iotsitewise.AccessPolicyProject;
    }
    /**
     * Contains information for a user identity in an access policy.
     */
    interface AccessPolicyUser {
        /**
         * The AWS SSO ID of the user.
         */
        id?: string;
    }
    /**
     * Contains the configuration information of an alarm created in an AWS IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.
     */
    interface AlarmsProperties {
        /**
         * The ARN of the IAM role that allows the alarm to perform actions and access AWS resources and services, such as AWS IoT Events.
         */
        alarmRoleArn?: string;
        /**
         * The ARN of the AWS Lambda function that manages alarm notifications. For more information, see Managing alarm notifications in the AWS IoT Events Developer Guide.
         */
        notificationLambdaArn?: string;
    }
    /**
     * A hierarchy specifies allowed parent/child asset relationships.
     */
    interface AssetHierarchy {
        /**
         * The ID of the child asset to be associated.
         */
        childAssetId: string;
        /**
         * The LogicalID of a hierarchy in the parent asset's model.
         */
        logicalId: string;
    }
    interface AssetModelAttribute {
        defaultValue?: string;
    }
    /**
     * Contains a composite model definition in an asset model. This composite model definition is applied to all assets created from the asset model.
     */
    interface AssetModelCompositeModel {
        /**
         * The property definitions of the asset model. You can specify up to 200 properties per asset model.
         */
        compositeModelProperties?: outputs.iotsitewise.AssetModelProperty[];
        /**
         * A description for the asset composite model.
         */
        description?: string;
        /**
         * A unique, friendly name for the asset composite model.
         */
        name: string;
        /**
         * The type of the composite model. For alarm composite models, this type is AWS/ALARM
         */
        type: string;
    }
    interface AssetModelExpressionVariable {
        /**
         * The friendly name of the variable to be used in the expression.
         */
        name: string;
        /**
         * The variable that identifies an asset property from which to use values.
         */
        value: outputs.iotsitewise.AssetModelVariableValue;
    }
    /**
     * Contains information about an asset model hierarchy.
     */
    interface AssetModelHierarchy {
        /**
         * The ID of the asset model. All assets in this hierarchy must be instances of the child AssetModelId asset model.
         */
        childAssetModelId: string;
        /**
         * Customer provided ID for hierarchy.
         */
        logicalId: string;
        /**
         * The name of the asset model hierarchy.
         */
        name: string;
    }
    interface AssetModelMetric {
        /**
         * The mathematical expression that defines the metric aggregation function. You can specify up to 10 functions per expression.
         */
        expression: string;
        /**
         * The list of variables used in the expression.
         */
        variables: outputs.iotsitewise.AssetModelExpressionVariable[];
        /**
         * The window (time interval) over which AWS IoT SiteWise computes the metric's aggregation expression
         */
        window: outputs.iotsitewise.AssetModelMetricWindow;
    }
    /**
     * Contains a time interval window used for data aggregate computations (for example, average, sum, count, and so on).
     */
    interface AssetModelMetricWindow {
        tumbling?: outputs.iotsitewise.AssetModelTumblingWindow;
    }
    /**
     * Contains information about an asset model property.
     */
    interface AssetModelProperty {
        /**
         * The data type of the asset model property.
         */
        dataType: enums.iotsitewise.AssetModelDataType;
        /**
         * The data type of the structure for this property.
         */
        dataTypeSpec?: enums.iotsitewise.AssetModelDataTypeSpec;
        /**
         * Customer provided ID for property.
         */
        logicalId: string;
        /**
         * The name of the asset model property.
         */
        name: string;
        /**
         * The property type
         */
        type: outputs.iotsitewise.AssetModelPropertyType;
        /**
         * The unit of the asset model property, such as Newtons or RPM.
         */
        unit?: string;
    }
    /**
     * Contains a property type, which can be one of attribute, measurement, metric, or transform.
     */
    interface AssetModelPropertyType {
        attribute?: outputs.iotsitewise.AssetModelAttribute;
        metric?: outputs.iotsitewise.AssetModelMetric;
        transform?: outputs.iotsitewise.AssetModelTransform;
        typeName: enums.iotsitewise.AssetModelTypeName;
    }
    interface AssetModelTag {
        key: string;
        value: string;
    }
    interface AssetModelTransform {
        /**
         * The mathematical expression that defines the transformation function. You can specify up to 10 functions per expression.
         */
        expression: string;
        /**
         * The list of variables used in the expression.
         */
        variables: outputs.iotsitewise.AssetModelExpressionVariable[];
    }
    /**
     * Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and contiguous time interval. This window is used in metric and aggregation computations.
     */
    interface AssetModelTumblingWindow {
        interval: string;
        offset?: string;
    }
    interface AssetModelVariableValue {
        hierarchyLogicalId?: string;
        propertyLogicalId: string;
    }
    /**
     * The asset property's definition, alias, unit, and notification state.
     */
    interface AssetProperty {
        /**
         * The property alias that identifies the property.
         */
        alias?: string;
        /**
         * Customer provided ID for property.
         */
        logicalId: string;
        /**
         * The MQTT notification state (ENABLED or DISABLED) for this asset property.
         */
        notificationState?: enums.iotsitewise.AssetPropertyNotificationState;
        /**
         * The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
         */
        unit?: string;
    }
    interface AssetTag {
        key: string;
        value: string;
    }
    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted
     */
    interface DashboardTag {
        key: string;
        value: string;
    }
    /**
     * Contains a summary of a gateway capability configuration.
     */
    interface GatewayCapabilitySummary {
        capabilityConfiguration?: string;
        capabilityNamespace: string;
    }
    /**
     * Contains the ARN of AWS IoT Greengrass Group V1 that the gateway runs on.
     */
    interface GatewayGreengrass {
        /**
         * The ARN of the Greengrass group.
         */
        groupArn: string;
    }
    /**
     * Contains the CoreDeviceThingName of AWS IoT Greengrass Group V2 that the gateway runs on.
     */
    interface GatewayGreengrassV2 {
        /**
         * The name of the CoreDevice in GreenGrass V2.
         */
        coreDeviceThingName: string;
    }
    /**
     * Contains a gateway's platform information.
     */
    interface GatewayPlatform {
        /**
         * A gateway that runs on AWS IoT Greengrass V1.
         */
        greengrass?: outputs.iotsitewise.GatewayGreengrass;
        /**
         * A gateway that runs on AWS IoT Greengrass V2.
         */
        greengrassV2?: outputs.iotsitewise.GatewayGreengrassV2;
    }
    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted
     */
    interface GatewayTag {
        key: string;
        value: string;
    }
    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted.
     */
    interface PortalTag {
        key: string;
        value: string;
    }
    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted
     */
    interface ProjectTag {
        key: string;
        value: string;
    }
}
export declare namespace iotthingsgraph {
    interface FlowTemplateDefinitionDocument {
        language: string;
        text: string;
    }
}
export declare namespace iottwinmaker {
    interface ComponentTypeStatus {
        error?: outputs.iottwinmaker.ComponentTypeStatusErrorProperties;
        state?: enums.iottwinmaker.ComponentTypeStatusState;
    }
    interface ComponentTypeStatusErrorProperties {
        code?: enums.iottwinmaker.ComponentTypeStatusErrorPropertiesCode;
        message?: string;
    }
    interface EntityStatus {
        error?: outputs.iottwinmaker.EntityStatusErrorProperties;
        state?: enums.iottwinmaker.EntityStatusState;
    }
    interface EntityStatusErrorProperties {
        code?: enums.iottwinmaker.EntityStatusErrorPropertiesCode;
        message?: string;
    }
}
export declare namespace iotwireless {
    interface DestinationTag {
        key?: string;
        value?: string;
    }
    interface DeviceProfileLoRaWANDeviceProfile {
        classBTimeout?: number;
        classCTimeout?: number;
        factoryPresetFreqsList?: number[];
        macVersion?: string;
        maxDutyCycle?: number;
        maxEirp?: number;
        pingSlotDr?: number;
        pingSlotFreq?: number;
        pingSlotPeriod?: number;
        regParamsRevision?: string;
        rfRegion?: string;
        rxDataRate2?: number;
        rxDelay1?: number;
        rxDrOffset1?: number;
        rxFreq2?: number;
        supports32BitFCnt?: boolean;
        supportsClassB?: boolean;
        supportsClassC?: boolean;
        supportsJoin?: boolean;
    }
    interface DeviceProfileTag {
        key?: string;
        value?: string;
    }
    interface FuotaTaskLoRaWAN {
        /**
         * FUOTA task LoRaWAN RF region
         */
        rfRegion: string;
        /**
         * FUOTA task LoRaWAN start time
         */
        startTime?: string;
    }
    interface FuotaTaskTag {
        key?: string;
        value?: string;
    }
    interface MulticastGroupLoRaWAN {
        /**
         * Multicast group LoRaWAN DL Class
         */
        dlClass: string;
        /**
         * Multicast group number of devices in group. Returned after successful read.
         */
        numberOfDevicesInGroup?: number;
        /**
         * Multicast group number of devices requested. Returned after successful read.
         */
        numberOfDevicesRequested?: number;
        /**
         * Multicast group LoRaWAN RF region
         */
        rfRegion: string;
    }
    interface MulticastGroupTag {
        key?: string;
        value?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface NetworkAnalyzerConfigurationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface PartnerAccountSidewalkAccountInfo {
        appServerPrivateKey: string;
    }
    interface PartnerAccountSidewalkAccountInfoWithFingerprint {
        amazonId?: string;
        arn?: string;
        fingerprint?: string;
    }
    interface PartnerAccountSidewalkUpdateAccount {
        appServerPrivateKey?: string;
    }
    interface PartnerAccountTag {
        key?: string;
        value?: string;
    }
    interface ServiceProfileLoRaWANServiceProfile {
        addGwMetadata?: boolean;
        channelMask?: string;
        devStatusReqFreq?: number;
        dlBucketSize?: number;
        dlRate?: number;
        dlRatePolicy?: string;
        drMax?: number;
        drMin?: number;
        hrAllowed?: boolean;
        minGwDiversity?: number;
        nwkGeoLoc?: boolean;
        prAllowed?: boolean;
        raAllowed?: boolean;
        reportDevStatusBattery?: boolean;
        reportDevStatusMargin?: boolean;
        targetPer?: number;
        ulBucketSize?: number;
        ulRate?: number;
        ulRatePolicy?: string;
    }
    interface ServiceProfileTag {
        key?: string;
        value?: string;
    }
    interface TaskDefinitionLoRaWANGatewayVersion {
        model?: string;
        packageVersion?: string;
        station?: string;
    }
    interface TaskDefinitionLoRaWANUpdateGatewayTaskCreate {
        currentVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
        sigKeyCrc?: number;
        updateSignature?: string;
        updateVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
    }
    interface TaskDefinitionLoRaWANUpdateGatewayTaskEntry {
        currentVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
        updateVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
    }
    interface TaskDefinitionTag {
        key?: string;
        value?: string;
    }
    interface TaskDefinitionUpdateWirelessGatewayTaskCreate {
        loRaWAN?: outputs.iotwireless.TaskDefinitionLoRaWANUpdateGatewayTaskCreate;
        updateDataRole?: string;
        updateDataSource?: string;
    }
    /**
     * Trace content for your wireless gateway and wireless device resources
     */
    interface TraceContentProperties {
        logLevel?: enums.iotwireless.NetworkAnalyzerConfigurationLogLevel;
        wirelessDeviceFrameInfo?: enums.iotwireless.NetworkAnalyzerConfigurationWirelessDeviceFrameInfo;
    }
    interface WirelessDeviceAbpV10x {
        devAddr: string;
        sessionKeys: outputs.iotwireless.WirelessDeviceSessionKeysAbpV10x;
    }
    interface WirelessDeviceAbpV11 {
        devAddr: string;
        sessionKeys: outputs.iotwireless.WirelessDeviceSessionKeysAbpV11;
    }
    interface WirelessDeviceLoRaWANDevice {
        abpV10x?: outputs.iotwireless.WirelessDeviceAbpV10x;
        abpV11?: outputs.iotwireless.WirelessDeviceAbpV11;
        devEui?: string;
        deviceProfileId?: string;
        otaaV10x?: outputs.iotwireless.WirelessDeviceOtaaV10x;
        otaaV11?: outputs.iotwireless.WirelessDeviceOtaaV11;
        serviceProfileId?: string;
    }
    interface WirelessDeviceOtaaV10x {
        appEui: string;
        appKey: string;
    }
    interface WirelessDeviceOtaaV11 {
        appKey: string;
        joinEui: string;
        nwkKey: string;
    }
    interface WirelessDeviceSessionKeysAbpV10x {
        appSKey: string;
        nwkSKey: string;
    }
    interface WirelessDeviceSessionKeysAbpV11 {
        appSKey: string;
        fNwkSIntKey: string;
        nwkSEncKey: string;
        sNwkSIntKey: string;
    }
    interface WirelessDeviceTag {
        key?: string;
        value?: string;
    }
    interface WirelessGatewayLoRaWANGateway {
        gatewayEui: string;
        rfRegion: string;
    }
    interface WirelessGatewayTag {
        key?: string;
        value?: string;
    }
}
export declare namespace ivs {
    interface ChannelTag {
        key: string;
        value: string;
    }
    interface PlaybackKeyPairTag {
        key: string;
        value: string;
    }
    /**
     * Recording Destination Configuration.
     */
    interface RecordingConfigurationDestinationConfiguration {
        s3: outputs.ivs.RecordingConfigurationS3DestinationConfiguration;
    }
    /**
     * Recording S3 Destination Configuration.
     */
    interface RecordingConfigurationS3DestinationConfiguration {
        bucketName: string;
    }
    interface RecordingConfigurationTag {
        key: string;
        value: string;
    }
    /**
     * Recording Thumbnail Configuration.
     */
    interface RecordingConfigurationThumbnailConfiguration {
        /**
         * Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
         */
        recordingMode: enums.ivs.RecordingConfigurationThumbnailConfigurationRecordingMode;
        /**
         * Thumbnail recording Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
         */
        targetIntervalSeconds?: number;
    }
    interface StreamKeyTag {
        key: string;
        value: string;
    }
}
export declare namespace kafkaconnect {
    /**
     * Details of how to connect to an Apache Kafka cluster.
     */
    interface ConnectorApacheKafkaCluster {
        /**
         * The bootstrap servers string of the Apache Kafka cluster.
         */
        bootstrapServers: string;
        vpc: outputs.kafkaconnect.ConnectorVpc;
    }
    /**
     * Details about auto scaling of a connector.
     */
    interface ConnectorAutoScaling {
        /**
         * The maximum number of workers for a connector.
         */
        maxWorkerCount: number;
        /**
         * Specifies how many MSK Connect Units (MCU) as the minimum scaling unit.
         */
        mcuCount: number;
        /**
         * The minimum number of workers for a connector.
         */
        minWorkerCount: number;
        scaleInPolicy: outputs.kafkaconnect.ConnectorScaleInPolicy;
        scaleOutPolicy: outputs.kafkaconnect.ConnectorScaleOutPolicy;
    }
    /**
     * Information about the capacity allocated to the connector.
     */
    interface ConnectorCapacity {
        autoScaling?: outputs.kafkaconnect.ConnectorAutoScaling;
        provisionedCapacity?: outputs.kafkaconnect.ConnectorProvisionedCapacity;
    }
    /**
     * Details about delivering logs to Amazon CloudWatch Logs.
     */
    interface ConnectorCloudWatchLogsLogDelivery {
        /**
         * Specifies whether the logs get sent to the specified CloudWatch Logs destination.
         */
        enabled: boolean;
        /**
         * The CloudWatch log group that is the destination for log delivery.
         */
        logGroup?: string;
    }
    /**
     * Details about a custom plugin.
     */
    interface ConnectorCustomPlugin {
        /**
         * The Amazon Resource Name (ARN) of the custom plugin to use.
         */
        customPluginArn: string;
        /**
         * The revision of the custom plugin to use.
         */
        revision: number;
    }
    /**
     * Details about delivering logs to Amazon Kinesis Data Firehose.
     */
    interface ConnectorFirehoseLogDelivery {
        /**
         * The Kinesis Data Firehose delivery stream that is the destination for log delivery.
         */
        deliveryStream?: string;
        /**
         * Specifies whether the logs get sent to the specified Kinesis Data Firehose delivery stream.
         */
        enabled: boolean;
    }
    /**
     * Details of how to connect to the Kafka cluster.
     */
    interface ConnectorKafkaCluster {
        apacheKafkaCluster: outputs.kafkaconnect.ConnectorApacheKafkaCluster;
    }
    /**
     * Details of the client authentication used by the Kafka cluster.
     */
    interface ConnectorKafkaClusterClientAuthentication {
        authenticationType: enums.kafkaconnect.ConnectorKafkaClusterClientAuthenticationType;
    }
    /**
     * Details of encryption in transit to the Kafka cluster.
     */
    interface ConnectorKafkaClusterEncryptionInTransit {
        encryptionType: enums.kafkaconnect.ConnectorKafkaClusterEncryptionInTransitType;
    }
    /**
     * Details of what logs are delivered and where they are delivered.
     */
    interface ConnectorLogDelivery {
        workerLogDelivery: outputs.kafkaconnect.ConnectorWorkerLogDelivery;
    }
    /**
     * Details about a Kafka Connect plugin which will be used with the connector.
     */
    interface ConnectorPlugin {
        customPlugin: outputs.kafkaconnect.ConnectorCustomPlugin;
    }
    /**
     * Details about a fixed capacity allocated to a connector.
     */
    interface ConnectorProvisionedCapacity {
        /**
         * Specifies how many MSK Connect Units (MCU) are allocated to the connector.
         */
        mcuCount?: number;
        /**
         * Number of workers for a connector.
         */
        workerCount: number;
    }
    /**
     * Details about delivering logs to Amazon S3.
     */
    interface ConnectorS3LogDelivery {
        /**
         * The name of the S3 bucket that is the destination for log delivery.
         */
        bucket?: string;
        /**
         * Specifies whether the logs get sent to the specified Amazon S3 destination.
         */
        enabled: boolean;
        /**
         * The S3 prefix that is the destination for log delivery.
         */
        prefix?: string;
    }
    /**
     * Information about the scale in policy of the connector.
     */
    interface ConnectorScaleInPolicy {
        /**
         * Specifies the CPU utilization percentage threshold at which connector scale in should trigger.
         */
        cpuUtilizationPercentage: number;
    }
    /**
     * Information about the scale out policy of the connector.
     */
    interface ConnectorScaleOutPolicy {
        /**
         * Specifies the CPU utilization percentage threshold at which connector scale out should trigger.
         */
        cpuUtilizationPercentage: number;
    }
    /**
     * Information about a VPC used with the connector.
     */
    interface ConnectorVpc {
        /**
         * The AWS security groups to associate with the elastic network interfaces in order to specify what the connector has access to.
         */
        securityGroups: string[];
        /**
         * The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets.
         */
        subnets: string[];
    }
    /**
     * Specifies the worker configuration to use with the connector.
     */
    interface ConnectorWorkerConfiguration {
        /**
         * The revision of the worker configuration to use.
         */
        revision: number;
        /**
         * The Amazon Resource Name (ARN) of the worker configuration to use.
         */
        workerConfigurationArn: string;
    }
    /**
     * Specifies where worker logs are delivered.
     */
    interface ConnectorWorkerLogDelivery {
        cloudWatchLogs?: outputs.kafkaconnect.ConnectorCloudWatchLogsLogDelivery;
        firehose?: outputs.kafkaconnect.ConnectorFirehoseLogDelivery;
        s3?: outputs.kafkaconnect.ConnectorS3LogDelivery;
    }
}
export declare namespace kendra {
    interface DataSourceAccessControlListConfiguration {
        keyPath?: string;
    }
    interface DataSourceAclConfiguration {
        allowedGroupsColumnName: string;
    }
    interface DataSourceColumnConfiguration {
        changeDetectingColumns: string[];
        documentDataColumnName: string;
        documentIdColumnName: string;
        documentTitleColumnName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
    }
    interface DataSourceConfiguration {
        confluenceConfiguration?: outputs.kendra.DataSourceConfluenceConfiguration;
        databaseConfiguration?: outputs.kendra.DataSourceDatabaseConfiguration;
        googleDriveConfiguration?: outputs.kendra.DataSourceGoogleDriveConfiguration;
        oneDriveConfiguration?: outputs.kendra.DataSourceOneDriveConfiguration;
        s3Configuration?: outputs.kendra.DataSourceS3DataSourceConfiguration;
        salesforceConfiguration?: outputs.kendra.DataSourceSalesforceConfiguration;
        serviceNowConfiguration?: outputs.kendra.DataSourceServiceNowConfiguration;
        sharePointConfiguration?: outputs.kendra.DataSourceSharePointConfiguration;
        webCrawlerConfiguration?: outputs.kendra.DataSourceWebCrawlerConfiguration;
        workDocsConfiguration?: outputs.kendra.DataSourceWorkDocsConfiguration;
    }
    interface DataSourceConfluenceAttachmentConfiguration {
        attachmentFieldMappings?: outputs.kendra.DataSourceConfluenceAttachmentToIndexFieldMapping[];
        crawlAttachments?: boolean;
    }
    interface DataSourceConfluenceAttachmentToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluenceAttachmentFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }
    interface DataSourceConfluenceBlogConfiguration {
        blogFieldMappings?: outputs.kendra.DataSourceConfluenceBlogToIndexFieldMapping[];
    }
    interface DataSourceConfluenceBlogToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluenceBlogFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }
    interface DataSourceConfluenceConfiguration {
        attachmentConfiguration?: outputs.kendra.DataSourceConfluenceAttachmentConfiguration;
        blogConfiguration?: outputs.kendra.DataSourceConfluenceBlogConfiguration;
        exclusionPatterns?: string[];
        inclusionPatterns?: string[];
        pageConfiguration?: outputs.kendra.DataSourceConfluencePageConfiguration;
        secretArn: string;
        serverUrl: string;
        spaceConfiguration?: outputs.kendra.DataSourceConfluenceSpaceConfiguration;
        version: enums.kendra.DataSourceConfluenceVersion;
        vpcConfiguration?: outputs.kendra.DataSourceVpcConfiguration;
    }
    interface DataSourceConfluencePageConfiguration {
        pageFieldMappings?: outputs.kendra.DataSourceConfluencePageToIndexFieldMapping[];
    }
    interface DataSourceConfluencePageToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluencePageFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }
    interface DataSourceConfluenceSpaceConfiguration {
        crawlArchivedSpaces?: boolean;
        crawlPersonalSpaces?: boolean;
        excludeSpaces?: string[];
        includeSpaces?: string[];
        spaceFieldMappings?: outputs.kendra.DataSourceConfluenceSpaceToIndexFieldMapping[];
    }
    interface DataSourceConfluenceSpaceToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluenceSpaceFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }
    interface DataSourceConnectionConfiguration {
        databaseHost: string;
        databaseName: string;
        databasePort: number;
        secretArn: string;
        tableName: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfiguration {
        inlineConfigurations?: outputs.kendra.DataSourceInlineCustomDocumentEnrichmentConfiguration[];
        postExtractionHookConfiguration?: outputs.kendra.DataSourceHookConfiguration;
        preExtractionHookConfiguration?: outputs.kendra.DataSourceHookConfiguration;
        roleArn?: string;
    }
    interface DataSourceDatabaseConfiguration {
        aclConfiguration?: outputs.kendra.DataSourceAclConfiguration;
        columnConfiguration: outputs.kendra.DataSourceColumnConfiguration;
        connectionConfiguration: outputs.kendra.DataSourceConnectionConfiguration;
        databaseEngineType: enums.kendra.DataSourceDatabaseEngineType;
        sqlConfiguration?: outputs.kendra.DataSourceSqlConfiguration;
        vpcConfiguration?: outputs.kendra.DataSourceVpcConfiguration;
    }
    interface DataSourceDocumentAttributeCondition {
        conditionDocumentAttributeKey: string;
        conditionOnValue?: outputs.kendra.DataSourceDocumentAttributeValue;
        operator: enums.kendra.DataSourceConditionOperator;
    }
    interface DataSourceDocumentAttributeTarget {
        targetDocumentAttributeKey: string;
        targetDocumentAttributeValue?: outputs.kendra.DataSourceDocumentAttributeValue;
        targetDocumentAttributeValueDeletion?: boolean;
    }
    interface DataSourceDocumentAttributeValue {
        dateValue?: string;
        longValue?: number;
        stringListValue?: string[];
        stringValue?: string;
    }
    interface DataSourceDocumentsMetadataConfiguration {
        s3Prefix?: string;
    }
    interface DataSourceGoogleDriveConfiguration {
        excludeMimeTypes?: string[];
        excludeSharedDrives?: string[];
        excludeUserAccounts?: string[];
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        secretArn: string;
    }
    interface DataSourceHookConfiguration {
        invocationCondition?: outputs.kendra.DataSourceDocumentAttributeCondition;
        lambdaArn: string;
        s3Bucket: string;
    }
    interface DataSourceInlineCustomDocumentEnrichmentConfiguration {
        condition?: outputs.kendra.DataSourceDocumentAttributeCondition;
        documentContentDeletion?: boolean;
        target?: outputs.kendra.DataSourceDocumentAttributeTarget;
    }
    interface DataSourceOneDriveConfiguration {
        disableLocalGroups?: boolean;
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        oneDriveUsers: outputs.kendra.DataSourceOneDriveUsers;
        secretArn: string;
        tenantDomain: string;
    }
    interface DataSourceOneDriveUsers {
        oneDriveUserList?: string[];
        oneDriveUserS3Path?: outputs.kendra.DataSourceS3Path;
    }
    interface DataSourceProxyConfiguration {
        credentials?: string;
        host: string;
        port: number;
    }
    /**
     * S3 data source configuration
     */
    interface DataSourceS3DataSourceConfiguration {
        accessControlListConfiguration?: outputs.kendra.DataSourceAccessControlListConfiguration;
        bucketName: string;
        documentsMetadataConfiguration?: outputs.kendra.DataSourceDocumentsMetadataConfiguration;
        exclusionPatterns?: string[];
        inclusionPatterns?: string[];
        inclusionPrefixes?: string[];
    }
    interface DataSourceS3Path {
        bucket: string;
        key: string;
    }
    interface DataSourceSalesforceChatterFeedConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        includeFilterTypes?: enums.kendra.DataSourceSalesforceChatterFeedIncludeFilterType[];
    }
    interface DataSourceSalesforceConfiguration {
        chatterFeedConfiguration?: outputs.kendra.DataSourceSalesforceChatterFeedConfiguration;
        crawlAttachments?: boolean;
        excludeAttachmentFilePatterns?: string[];
        includeAttachmentFilePatterns?: string[];
        knowledgeArticleConfiguration?: outputs.kendra.DataSourceSalesforceKnowledgeArticleConfiguration;
        secretArn: string;
        serverUrl: string;
        standardObjectAttachmentConfiguration?: outputs.kendra.DataSourceSalesforceStandardObjectAttachmentConfiguration;
        standardObjectConfigurations?: outputs.kendra.DataSourceSalesforceStandardObjectConfiguration[];
    }
    interface DataSourceSalesforceCustomKnowledgeArticleTypeConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        name: string;
    }
    interface DataSourceSalesforceKnowledgeArticleConfiguration {
        customKnowledgeArticleTypeConfigurations?: outputs.kendra.DataSourceSalesforceCustomKnowledgeArticleTypeConfiguration[];
        includedStates: enums.kendra.DataSourceSalesforceKnowledgeArticleState[];
        standardKnowledgeArticleTypeConfiguration?: outputs.kendra.DataSourceSalesforceStandardKnowledgeArticleTypeConfiguration;
    }
    interface DataSourceSalesforceStandardKnowledgeArticleTypeConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
    }
    interface DataSourceSalesforceStandardObjectAttachmentConfiguration {
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
    }
    interface DataSourceSalesforceStandardObjectConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        name: enums.kendra.DataSourceSalesforceStandardObjectName;
    }
    interface DataSourceServiceNowConfiguration {
        authenticationType?: enums.kendra.DataSourceServiceNowAuthenticationType;
        hostUrl: string;
        knowledgeArticleConfiguration?: outputs.kendra.DataSourceServiceNowKnowledgeArticleConfiguration;
        secretArn: string;
        serviceCatalogConfiguration?: outputs.kendra.DataSourceServiceNowServiceCatalogConfiguration;
        serviceNowBuildVersion: enums.kendra.DataSourceServiceNowBuildVersionType;
    }
    interface DataSourceServiceNowKnowledgeArticleConfiguration {
        crawlAttachments?: boolean;
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        excludeAttachmentFilePatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        filterQuery?: string;
        includeAttachmentFilePatterns?: string[];
    }
    interface DataSourceServiceNowServiceCatalogConfiguration {
        crawlAttachments?: boolean;
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        excludeAttachmentFilePatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        includeAttachmentFilePatterns?: string[];
    }
    /**
     * SharePoint configuration
     */
    interface DataSourceSharePointConfiguration {
        crawlAttachments?: boolean;
        disableLocalGroups?: boolean;
        documentTitleFieldName?: string;
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        secretArn: string;
        sharePointVersion: enums.kendra.DataSourceSharePointConfigurationSharePointVersion;
        sslCertificateS3Path?: outputs.kendra.DataSourceS3Path;
        urls: string[];
        useChangeLog?: boolean;
        vpcConfiguration?: outputs.kendra.DataSourceVpcConfiguration;
    }
    interface DataSourceSqlConfiguration {
        queryIdentifiersEnclosingOption?: enums.kendra.DataSourceQueryIdentifiersEnclosingOption;
    }
    /**
     * A label for tagging Kendra resources
     */
    interface DataSourceTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface DataSourceToIndexFieldMapping {
        dataSourceFieldName: string;
        dateFieldFormat?: string;
        indexFieldName: string;
    }
    interface DataSourceVpcConfiguration {
        securityGroupIds: string[];
        subnetIds: string[];
    }
    interface DataSourceWebCrawlerAuthenticationConfiguration {
        basicAuthentication?: outputs.kendra.DataSourceWebCrawlerBasicAuthentication[];
    }
    interface DataSourceWebCrawlerBasicAuthentication {
        credentials: string;
        host: string;
        port: number;
    }
    interface DataSourceWebCrawlerConfiguration {
        authenticationConfiguration?: outputs.kendra.DataSourceWebCrawlerAuthenticationConfiguration;
        crawlDepth?: number;
        maxContentSizePerPageInMegaBytes?: number;
        maxLinksPerPage?: number;
        maxUrlsPerMinuteCrawlRate?: number;
        proxyConfiguration?: outputs.kendra.DataSourceProxyConfiguration;
        urlExclusionPatterns?: string[];
        urlInclusionPatterns?: string[];
        urls: outputs.kendra.DataSourceWebCrawlerUrls;
    }
    interface DataSourceWebCrawlerSeedUrlConfiguration {
        seedUrls: string[];
        webCrawlerMode?: enums.kendra.DataSourceWebCrawlerSeedUrlConfigurationWebCrawlerMode;
    }
    interface DataSourceWebCrawlerSiteMapsConfiguration {
        siteMaps: string[];
    }
    interface DataSourceWebCrawlerUrls {
        seedUrlConfiguration?: outputs.kendra.DataSourceWebCrawlerSeedUrlConfiguration;
        siteMapsConfiguration?: outputs.kendra.DataSourceWebCrawlerSiteMapsConfiguration;
    }
    interface DataSourceWorkDocsConfiguration {
        crawlComments?: boolean;
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        organizationId: string;
        useChangeLog?: boolean;
    }
    interface FaqS3Path {
        bucket: string;
        key: string;
    }
    /**
     * A label for tagging Kendra resources
     */
    interface FaqTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface IndexCapacityUnitsConfiguration {
        queryCapacityUnits: number;
        storageCapacityUnits: number;
    }
    interface IndexDocumentMetadataConfiguration {
        name: string;
        relevance?: outputs.kendra.IndexRelevance;
        search?: outputs.kendra.IndexSearch;
        type: enums.kendra.IndexDocumentAttributeValueType;
    }
    interface IndexJsonTokenTypeConfiguration {
        groupAttributeField: string;
        userNameAttributeField: string;
    }
    interface IndexJwtTokenTypeConfiguration {
        claimRegex?: string;
        groupAttributeField?: string;
        issuer?: string;
        keyLocation: enums.kendra.IndexKeyLocation;
        secretManagerArn?: string;
        uRL?: string;
        userNameAttributeField?: string;
    }
    interface IndexRelevance {
        duration?: string;
        freshness?: boolean;
        importance?: number;
        rankOrder?: enums.kendra.IndexOrder;
        valueImportanceItems?: outputs.kendra.IndexValueImportanceItem[];
    }
    interface IndexSearch {
        displayable?: boolean;
        facetable?: boolean;
        searchable?: boolean;
        sortable?: boolean;
    }
    interface IndexServerSideEncryptionConfiguration {
        kmsKeyId?: string;
    }
    /**
     * A label for tagging Kendra resources
     */
    interface IndexTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface IndexUserTokenConfiguration {
        jsonTokenTypeConfiguration?: outputs.kendra.IndexJsonTokenTypeConfiguration;
        jwtTokenTypeConfiguration?: outputs.kendra.IndexJwtTokenTypeConfiguration;
    }
    interface IndexValueImportanceItem {
        key?: string;
        value?: number;
    }
}
export declare namespace kinesis {
    /**
     * When specified, enables or updates server-side encryption using an AWS KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption.
     */
    interface StreamEncryption {
        /**
         * The encryption type to use. The only valid value is KMS.
         */
        encryptionType: enums.kinesis.StreamEncryptionEncryptionType;
        /**
         * The GUID for the customer-managed AWS KMS key to use for encryption. This value can be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either an alias or a key, or an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data Streams by specifying the alias aws/kinesis.
         */
        keyId: string;
    }
    /**
     * When specified, enables or updates the mode of stream. Default is PROVISIONED.
     */
    interface StreamModeDetails {
        /**
         * The mode of the stream
         */
        streamMode: enums.kinesis.StreamModeDetailsStreamMode;
    }
    /**
     * An arbitrary set of tags (key-value pairs) to associate with the Kinesis stream.
     */
    interface StreamTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace kinesisanalytics {
    interface ApplicationCSVMappingParameters {
        recordColumnDelimiter: string;
        recordRowDelimiter: string;
    }
    interface ApplicationInput {
        inputParallelism?: outputs.kinesisanalytics.ApplicationInputParallelism;
        inputProcessingConfiguration?: outputs.kinesisanalytics.ApplicationInputProcessingConfiguration;
        inputSchema: outputs.kinesisanalytics.ApplicationInputSchema;
        kinesisFirehoseInput?: outputs.kinesisanalytics.ApplicationKinesisFirehoseInput;
        kinesisStreamsInput?: outputs.kinesisanalytics.ApplicationKinesisStreamsInput;
        namePrefix: string;
    }
    interface ApplicationInputLambdaProcessor {
        resourceARN: string;
        roleARN: string;
    }
    interface ApplicationInputParallelism {
        count?: number;
    }
    interface ApplicationInputProcessingConfiguration {
        inputLambdaProcessor?: outputs.kinesisanalytics.ApplicationInputLambdaProcessor;
    }
    interface ApplicationInputSchema {
        recordColumns: outputs.kinesisanalytics.ApplicationRecordColumn[];
        recordEncoding?: string;
        recordFormat: outputs.kinesisanalytics.ApplicationRecordFormat;
    }
    interface ApplicationJSONMappingParameters {
        recordRowPath: string;
    }
    interface ApplicationKinesisFirehoseInput {
        resourceARN: string;
        roleARN: string;
    }
    interface ApplicationKinesisStreamsInput {
        resourceARN: string;
        roleARN: string;
    }
    interface ApplicationMappingParameters {
        cSVMappingParameters?: outputs.kinesisanalytics.ApplicationCSVMappingParameters;
        jSONMappingParameters?: outputs.kinesisanalytics.ApplicationJSONMappingParameters;
    }
    interface ApplicationOutputResourceDestinationSchema {
        recordFormatType?: string;
    }
    interface ApplicationOutputResourceKinesisFirehoseOutput {
        resourceARN: string;
        roleARN: string;
    }
    interface ApplicationOutputResourceKinesisStreamsOutput {
        resourceARN: string;
        roleARN: string;
    }
    interface ApplicationOutputResourceLambdaOutput {
        resourceARN: string;
        roleARN: string;
    }
    interface ApplicationOutputResourceOutput {
        destinationSchema: outputs.kinesisanalytics.ApplicationOutputResourceDestinationSchema;
        kinesisFirehoseOutput?: outputs.kinesisanalytics.ApplicationOutputResourceKinesisFirehoseOutput;
        kinesisStreamsOutput?: outputs.kinesisanalytics.ApplicationOutputResourceKinesisStreamsOutput;
        lambdaOutput?: outputs.kinesisanalytics.ApplicationOutputResourceLambdaOutput;
        name?: string;
    }
    interface ApplicationRecordColumn {
        mapping?: string;
        name: string;
        sqlType: string;
    }
    interface ApplicationRecordFormat {
        mappingParameters?: outputs.kinesisanalytics.ApplicationMappingParameters;
        recordFormatType: string;
    }
    interface ApplicationReferenceDataSourceCSVMappingParameters {
        recordColumnDelimiter: string;
        recordRowDelimiter: string;
    }
    interface ApplicationReferenceDataSourceJSONMappingParameters {
        recordRowPath: string;
    }
    interface ApplicationReferenceDataSourceMappingParameters {
        cSVMappingParameters?: outputs.kinesisanalytics.ApplicationReferenceDataSourceCSVMappingParameters;
        jSONMappingParameters?: outputs.kinesisanalytics.ApplicationReferenceDataSourceJSONMappingParameters;
    }
    interface ApplicationReferenceDataSourceRecordColumn {
        mapping?: string;
        name: string;
        sqlType: string;
    }
    interface ApplicationReferenceDataSourceRecordFormat {
        mappingParameters?: outputs.kinesisanalytics.ApplicationReferenceDataSourceMappingParameters;
        recordFormatType: string;
    }
    interface ApplicationReferenceDataSourceReferenceDataSource {
        referenceSchema: outputs.kinesisanalytics.ApplicationReferenceDataSourceReferenceSchema;
        s3ReferenceDataSource?: outputs.kinesisanalytics.ApplicationReferenceDataSourceS3ReferenceDataSource;
        tableName?: string;
    }
    interface ApplicationReferenceDataSourceReferenceSchema {
        recordColumns: outputs.kinesisanalytics.ApplicationReferenceDataSourceRecordColumn[];
        recordEncoding?: string;
        recordFormat: outputs.kinesisanalytics.ApplicationReferenceDataSourceRecordFormat;
    }
    interface ApplicationReferenceDataSourceS3ReferenceDataSource {
        bucketARN: string;
        fileKey: string;
        referenceRoleARN: string;
    }
}
export declare namespace kinesisanalyticsv2 {
    /**
     * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV. For example, the following sample records use CSV format, where the records use the '\n' as the row delimiter and a comma (",") as the column delimiter:
     * `"name1", "address1"`
     * `"name2", "address2"`
     */
    interface ApplicationCSVMappingParameters {
        /**
         * The column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
         */
        recordRowDelimiter: string;
    }
    /**
     * The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
     */
    interface ApplicationCatalogConfiguration {
        /**
         * The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
         */
        glueDataCatalogConfiguration?: outputs.kinesisanalyticsv2.ApplicationGlueDataCatalogConfiguration;
    }
    /**
     * Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see Checkpoints for Fault Tolerance in the Apache Flink Documentation.
     */
    interface ApplicationCheckpointConfiguration {
        /**
         * Describes the interval in milliseconds between checkpoint operations.
         */
        checkpointInterval?: number;
        /**
         * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
         */
        checkpointingEnabled?: boolean;
        /**
         * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. You must set this property to `CUSTOM` in order to set the `CheckpointingEnabled`, `CheckpointInterval`, or `MinPauseBetweenCheckpoints` parameters.
         */
        configurationType: enums.kinesisanalyticsv2.ApplicationCheckpointConfigurationConfigurationType;
        /**
         * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If a checkpoint operation takes longer than the CheckpointInterval, the application otherwise performs continual checkpoint operations. For more information, see Tuning Checkpointing in the Apache Flink Documentation.
         */
        minPauseBetweenCheckpoints?: number;
    }
    interface ApplicationCloudWatchLoggingOptionCloudWatchLoggingOption {
        logStreamARN: string;
    }
    /**
     * Describes code configuration for an application.
     */
    interface ApplicationCodeConfiguration {
        /**
         * The location and type of the application code.
         */
        codeContent: outputs.kinesisanalyticsv2.ApplicationCodeContent;
        /**
         * Specifies whether the code content is in text or zip format.
         */
        codeContentType: enums.kinesisanalyticsv2.ApplicationCodeConfigurationCodeContentType;
    }
    /**
     * Specifies either the application code, or the location of the application code, for a Flink-based Kinesis Data Analytics application.
     */
    interface ApplicationCodeContent {
        /**
         * Information about the Amazon S3 bucket that contains the application code.
         */
        s3ContentLocation?: outputs.kinesisanalyticsv2.ApplicationS3ContentLocation;
        /**
         * The text-format code for a Flink-based Kinesis Data Analytics application.
         */
        textContent?: string;
        /**
         * The zip-format code for a Flink-based Kinesis Data Analytics application.
         */
        zipFileContent?: string;
    }
    /**
     * Specifies the creation parameters for a Kinesis Data Analytics application.
     */
    interface ApplicationConfiguration {
        /**
         * The code location and type parameters for a Flink-based Kinesis Data Analytics application.
         */
        applicationCodeConfiguration?: outputs.kinesisanalyticsv2.ApplicationCodeConfiguration;
        /**
         * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
         */
        applicationSnapshotConfiguration?: outputs.kinesisanalyticsv2.ApplicationSnapshotConfiguration;
        /**
         * Describes execution properties for a Flink-based Kinesis Data Analytics application.
         */
        environmentProperties?: outputs.kinesisanalyticsv2.ApplicationEnvironmentProperties;
        /**
         * The creation and update parameters for a Flink-based Kinesis Data Analytics application.
         */
        flinkApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationFlinkApplicationConfiguration;
        /**
         * The creation and update parameters for a SQL-based Kinesis Data Analytics application.
         */
        sqlApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationSqlApplicationConfiguration;
        /**
         * The array of descriptions of VPC configurations available to the application.
         */
        vpcConfigurations?: outputs.kinesisanalyticsv2.ApplicationVpcConfiguration[];
        /**
         * The configuration parameters for a Kinesis Data Analytics Studio notebook.
         */
        zeppelinApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationZeppelinApplicationConfiguration;
    }
    /**
     * The configuration of connectors and user-defined functions.
     */
    interface ApplicationCustomArtifactConfiguration {
        /**
         * Set this to either `UDF` or `DEPENDENCY_JAR`. `UDF` stands for user-defined functions. This type of artifact must be in an S3 bucket. A `DEPENDENCY_JAR` can be in either Maven or an S3 bucket.
         */
        artifactType: enums.kinesisanalyticsv2.ApplicationCustomArtifactConfigurationArtifactType;
        /**
         * The parameters required to fully specify a Maven reference.
         */
        mavenReference?: outputs.kinesisanalyticsv2.ApplicationMavenReference;
        /**
         * The location of the custom artifacts.
         */
        s3ContentLocation?: outputs.kinesisanalyticsv2.ApplicationS3ContentLocation;
    }
    /**
     * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
     */
    interface ApplicationDeployAsApplicationConfiguration {
        /**
         * The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
         */
        s3ContentLocation: outputs.kinesisanalyticsv2.ApplicationS3ContentBaseLocation;
    }
    /**
     * Describes execution properties for a Flink-based Kinesis Data Analytics application.
     */
    interface ApplicationEnvironmentProperties {
        /**
         * Describes the execution property groups.
         */
        propertyGroups?: outputs.kinesisanalyticsv2.ApplicationPropertyGroup[];
    }
    /**
     * Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.
     */
    interface ApplicationFlinkApplicationConfiguration {
        /**
         * Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see Checkpoints for Fault Tolerance in the Apache Flink Documentation.
         */
        checkpointConfiguration?: outputs.kinesisanalyticsv2.ApplicationCheckpointConfiguration;
        /**
         * Describes configuration parameters for Amazon CloudWatch logging for an application.
         */
        monitoringConfiguration?: outputs.kinesisanalyticsv2.ApplicationMonitoringConfiguration;
        /**
         * Describes parameters for how an application executes multiple tasks simultaneously.
         */
        parallelismConfiguration?: outputs.kinesisanalyticsv2.ApplicationParallelismConfiguration;
    }
    /**
     * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
     */
    interface ApplicationFlinkRunConfiguration {
        /**
         * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Defaults to false. If you update your application without specifying this parameter, AllowNonRestoredState will be set to false, even if it was previously set to true.
         */
        allowNonRestoredState?: boolean;
    }
    /**
     * The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
     */
    interface ApplicationGlueDataCatalogConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the database.
         */
        databaseARN?: string;
    }
    /**
     * When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream name that is created, and the mapping between the two.
     */
    interface ApplicationInput {
        /**
         * Describes the number of in-application streams to create.
         */
        inputParallelism?: outputs.kinesisanalyticsv2.ApplicationInputParallelism;
        /**
         * The InputProcessingConfiguration for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is InputLambdaProcessor.
         */
        inputProcessingConfiguration?: outputs.kinesisanalyticsv2.ApplicationInputProcessingConfiguration;
        /**
         * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
         */
        inputSchema: outputs.kinesisanalyticsv2.ApplicationInputSchema;
        /**
         * If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
         */
        kinesisFirehoseInput?: outputs.kinesisanalyticsv2.ApplicationKinesisFirehoseInput;
        /**
         * If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
         */
        kinesisStreamsInput?: outputs.kinesisanalyticsv2.ApplicationKinesisStreamsInput;
        /**
         * The name prefix to use when creating an in-application stream. Suppose that you specify a prefix `"MyInApplicationStream"`. Kinesis Data Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with the names `"MyInApplicationStream_001"`, `"MyInApplicationStream_002"`, and so on.
         */
        namePrefix: string;
    }
    /**
     * An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application.
     */
    interface ApplicationInputLambdaProcessor {
        /**
         * The ARN of the Amazon Lambda function that operates on records in the stream.
         */
        resourceARN: string;
    }
    /**
     * For a SQL-based Kinesis Data Analytics application, describes the number of in-application streams to create for a given streaming source.
     */
    interface ApplicationInputParallelism {
        /**
         * The number of in-application streams to create.
         */
        count?: number;
    }
    /**
     * For an SQL-based Amazon Kinesis Data Analytics application, describes a processor that is used to preprocess the records in the stream before being processed by your application code. Currently, the only input processor available is Amazon Lambda.
     */
    interface ApplicationInputProcessingConfiguration {
        /**
         * The InputLambdaProcessor that is used to preprocess the records in the stream before being processed by your application code.
         */
        inputLambdaProcessor?: outputs.kinesisanalyticsv2.ApplicationInputLambdaProcessor;
    }
    /**
     * For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
     */
    interface ApplicationInputSchema {
        /**
         * A list of `RecordColumn` objects.
         */
        recordColumns: outputs.kinesisanalyticsv2.ApplicationRecordColumn[];
        /**
         * Specifies the encoding of the records in the streaming source. For example, UTF-8.
         */
        recordEncoding?: enums.kinesisanalyticsv2.ApplicationInputSchemaRecordEncoding;
        /**
         * Specifies the format of the records on the streaming source.
         */
        recordFormat: outputs.kinesisanalyticsv2.ApplicationRecordFormat;
    }
    /**
     * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
     */
    interface ApplicationJSONMappingParameters {
        /**
         * The path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }
    /**
     * For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon Resource Name (ARN).
     */
    interface ApplicationKinesisFirehoseInput {
        /**
         * The Amazon Resource Name (ARN) of the delivery stream.
         */
        resourceARN: string;
    }
    /**
     * Identifies a Kinesis data stream as the streaming source. You provide the stream's Amazon Resource Name (ARN).
     */
    interface ApplicationKinesisStreamsInput {
        /**
         * The ARN of the input Kinesis data stream to read.
         */
        resourceARN: string;
    }
    /**
     * Describes the maintenance configuration for the application.
     */
    interface ApplicationMaintenanceConfiguration {
        /**
         * The start time for the maintenance window.
         */
        applicationMaintenanceWindowStartTime: string;
    }
    /**
     * When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
     */
    interface ApplicationMappingParameters {
        /**
         * Provides additional mapping information when the record format uses delimiters (for example, CSV).
         */
        cSVMappingParameters?: outputs.kinesisanalyticsv2.ApplicationCSVMappingParameters;
        /**
         * Provides additional mapping information when JSON is the record format on the streaming source.
         */
        jSONMappingParameters?: outputs.kinesisanalyticsv2.ApplicationJSONMappingParameters;
    }
    /**
     * The information required to specify a Maven reference. You can use Maven references to specify dependency JAR files.
     */
    interface ApplicationMavenReference {
        /**
         * The artifact ID of the Maven reference.
         */
        artifactId: string;
        /**
         * The group ID of the Maven reference.
         */
        groupId: string;
        /**
         * The version of the Maven reference.
         */
        version: string;
    }
    /**
     * Describes configuration parameters for Amazon CloudWatch logging for a Java-based Kinesis Data Analytics application. For more information about CloudWatch logging, see Monitoring.
     */
    interface ApplicationMonitoringConfiguration {
        /**
         * Describes whether to use the default CloudWatch logging configuration for an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
         */
        configurationType: enums.kinesisanalyticsv2.ApplicationMonitoringConfigurationConfigurationType;
        /**
         * Describes the verbosity of the CloudWatch Logs for an application.
         */
        logLevel?: enums.kinesisanalyticsv2.ApplicationMonitoringConfigurationLogLevel;
        /**
         * Describes the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
         */
        metricsLevel?: enums.kinesisanalyticsv2.ApplicationMonitoringConfigurationMetricsLevel;
    }
    interface ApplicationOutputResourceDestinationSchema {
        recordFormatType?: string;
    }
    interface ApplicationOutputResourceKinesisFirehoseOutput {
        resourceARN: string;
    }
    interface ApplicationOutputResourceKinesisStreamsOutput {
        resourceARN: string;
    }
    interface ApplicationOutputResourceLambdaOutput {
        resourceARN: string;
    }
    interface ApplicationOutputResourceOutput {
        destinationSchema: outputs.kinesisanalyticsv2.ApplicationOutputResourceDestinationSchema;
        kinesisFirehoseOutput?: outputs.kinesisanalyticsv2.ApplicationOutputResourceKinesisFirehoseOutput;
        kinesisStreamsOutput?: outputs.kinesisanalyticsv2.ApplicationOutputResourceKinesisStreamsOutput;
        lambdaOutput?: outputs.kinesisanalyticsv2.ApplicationOutputResourceLambdaOutput;
        name?: string;
    }
    /**
     * Describes parameters for how a Flink-based Kinesis Data Analytics application executes multiple tasks simultaneously. For more information about parallelism, see Parallel Execution in the Apache Flink Documentation
     */
    interface ApplicationParallelismConfiguration {
        /**
         * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
         */
        autoScalingEnabled?: boolean;
        /**
         * Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to `CUSTOM` in order to change your application's `AutoScalingEnabled`, `Parallelism`, or `ParallelismPerKPU` properties.
         */
        configurationType: enums.kinesisanalyticsv2.ApplicationParallelismConfigurationConfigurationType;
        /**
         * Describes the initial number of parallel tasks that a Java-based Kinesis Data Analytics application can perform. The Kinesis Data Analytics service can increase this number automatically if ParallelismConfiguration:AutoScalingEnabled is set to true.
         */
        parallelism?: number;
        /**
         * Describes the number of parallel tasks that a Java-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application. For more information about KPUs, see Amazon Kinesis Data Analytics Pricing.
         */
        parallelismPerKPU?: number;
    }
    /**
     * Property key-value pairs passed into an application.
     */
    interface ApplicationPropertyGroup {
        /**
         * Describes the key of an application execution property key-value pair.
         */
        propertyGroupId?: string;
        /**
         * Describes the value of an application execution property key-value pair.
         */
        propertyMap?: any;
    }
    /**
     * For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
     * Also used to describe the format of the reference data source.
     */
    interface ApplicationRecordColumn {
        /**
         * A reference to the data element in the streaming input or the reference data source.
         */
        mapping?: string;
        /**
         * The name of the column that is created in the in-application input stream or reference table.
         */
        name: string;
        /**
         * The type of column created in the in-application input stream or reference table.
         */
        sqlType: string;
    }
    /**
     * For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
     */
    interface ApplicationRecordFormat {
        /**
         * When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
         */
        mappingParameters?: outputs.kinesisanalyticsv2.ApplicationMappingParameters;
        /**
         * The type of record format.
         */
        recordFormatType: enums.kinesisanalyticsv2.ApplicationRecordFormatRecordFormatType;
    }
    interface ApplicationReferenceDataSourceCSVMappingParameters {
        recordColumnDelimiter: string;
        recordRowDelimiter: string;
    }
    interface ApplicationReferenceDataSourceJSONMappingParameters {
        recordRowPath: string;
    }
    interface ApplicationReferenceDataSourceMappingParameters {
        cSVMappingParameters?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceCSVMappingParameters;
        jSONMappingParameters?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceJSONMappingParameters;
    }
    interface ApplicationReferenceDataSourceRecordColumn {
        mapping?: string;
        name: string;
        sqlType: string;
    }
    interface ApplicationReferenceDataSourceRecordFormat {
        mappingParameters?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceMappingParameters;
        recordFormatType: string;
    }
    interface ApplicationReferenceDataSourceReferenceDataSource {
        referenceSchema: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceReferenceSchema;
        s3ReferenceDataSource?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceS3ReferenceDataSource;
        tableName?: string;
    }
    interface ApplicationReferenceDataSourceReferenceSchema {
        recordColumns: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceRecordColumn[];
        recordEncoding?: string;
        recordFormat: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceRecordFormat;
    }
    interface ApplicationReferenceDataSourceS3ReferenceDataSource {
        bucketARN: string;
        fileKey: string;
    }
    /**
     * Describes the restore behavior of a restarting application.
     */
    interface ApplicationRestoreConfiguration {
        /**
         * Specifies how the application should be restored.
         */
        applicationRestoreType: enums.kinesisanalyticsv2.ApplicationRestoreConfigurationApplicationRestoreType;
        /**
         * The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for the ApplicationRestoreType.
         */
        snapshotName?: string;
    }
    /**
     * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application. This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
     */
    interface ApplicationRunConfiguration {
        /**
         * Describes the restore behavior of a restarting application.
         */
        applicationRestoreConfiguration?: outputs.kinesisanalyticsv2.ApplicationRestoreConfiguration;
        /**
         * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
         */
        flinkRunConfiguration?: outputs.kinesisanalyticsv2.ApplicationFlinkRunConfiguration;
    }
    /**
     * The base location of the Amazon Data Analytics application.
     */
    interface ApplicationS3ContentBaseLocation {
        /**
         * The base path for the S3 bucket.
         */
        basePath?: string;
        /**
         * The Amazon Resource Name (ARN) of the S3 bucket.
         */
        bucketARN: string;
    }
    /**
     * The location of an application or a custom artifact.
     */
    interface ApplicationS3ContentLocation {
        /**
         * The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
         */
        bucketARN: string;
        /**
         * The file key for the object containing the application code.
         */
        fileKey: string;
        /**
         * The version of the object containing the application code.
         */
        objectVersion?: string;
    }
    /**
     * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
     */
    interface ApplicationSnapshotConfiguration {
        /**
         * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
         */
        snapshotsEnabled: boolean;
    }
    /**
     * Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
     */
    interface ApplicationSqlApplicationConfiguration {
        /**
         * The array of Input objects describing the input streams used by the application.
         */
        inputs?: outputs.kinesisanalyticsv2.ApplicationInput[];
    }
    /**
     * A key-value pair that identifies an application.
     */
    interface ApplicationTag {
        /**
         * The key name of the tag. You can specify a value that's 1 to 128 Unicode characters in length and can't be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that's 0 to 256 characters in length.
         */
        value: string;
    }
    /**
     * Describes the parameters of a VPC used by the application.
     */
    interface ApplicationVpcConfiguration {
        /**
         * The array of SecurityGroup IDs used by the VPC configuration.
         */
        securityGroupIds: string[];
        /**
         * The array of Subnet IDs used by the VPC configuration.
         */
        subnetIds: string[];
    }
    /**
     * The configuration of a Kinesis Data Analytics Studio notebook.
     */
    interface ApplicationZeppelinApplicationConfiguration {
        /**
         * The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.
         */
        catalogConfiguration?: outputs.kinesisanalyticsv2.ApplicationCatalogConfiguration;
        /**
         * A list of CustomArtifactConfiguration objects.
         */
        customArtifactsConfiguration?: outputs.kinesisanalyticsv2.ApplicationCustomArtifactConfiguration[];
        /**
         * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
         */
        deployAsApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationDeployAsApplicationConfiguration;
        /**
         * The monitoring configuration of a Kinesis Data Analytics Studio notebook.
         */
        monitoringConfiguration?: outputs.kinesisanalyticsv2.ApplicationZeppelinMonitoringConfiguration;
    }
    /**
     * Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook. For more information about CloudWatch logging, see Monitoring.
     */
    interface ApplicationZeppelinMonitoringConfiguration {
        /**
         * The verbosity of the CloudWatch Logs for an application. You can set it to `INFO`, `WARN`, `ERROR`, or `DEBUG`.
         */
        logLevel?: enums.kinesisanalyticsv2.ApplicationZeppelinMonitoringConfigurationLogLevel;
    }
}
export declare namespace kinesisfirehose {
    interface DeliveryStreamAmazonopensearchserviceBufferingHints {
        intervalInSeconds?: number;
        sizeInMBs?: number;
    }
    interface DeliveryStreamAmazonopensearchserviceDestinationConfiguration {
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamAmazonopensearchserviceBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        clusterEndpoint?: string;
        domainARN?: string;
        indexName: string;
        indexRotationPeriod?: enums.kinesisfirehose.DeliveryStreamAmazonopensearchserviceDestinationConfigurationIndexRotationPeriod;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamAmazonopensearchserviceRetryOptions;
        roleARN: string;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamAmazonopensearchserviceDestinationConfigurationS3BackupMode;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        typeName?: string;
        vpcConfiguration?: outputs.kinesisfirehose.DeliveryStreamVpcConfiguration;
    }
    interface DeliveryStreamAmazonopensearchserviceRetryOptions {
        durationInSeconds?: number;
    }
    interface DeliveryStreamBufferingHints {
        intervalInSeconds?: number;
        sizeInMBs?: number;
    }
    interface DeliveryStreamCloudWatchLoggingOptions {
        enabled?: boolean;
        logGroupName?: string;
        logStreamName?: string;
    }
    interface DeliveryStreamCopyCommand {
        copyOptions?: string;
        dataTableColumns?: string;
        dataTableName: string;
    }
    interface DeliveryStreamDataFormatConversionConfiguration {
        enabled?: boolean;
        inputFormatConfiguration?: outputs.kinesisfirehose.DeliveryStreamInputFormatConfiguration;
        outputFormatConfiguration?: outputs.kinesisfirehose.DeliveryStreamOutputFormatConfiguration;
        schemaConfiguration?: outputs.kinesisfirehose.DeliveryStreamSchemaConfiguration;
    }
    interface DeliveryStreamDeserializer {
        hiveJsonSerDe?: outputs.kinesisfirehose.DeliveryStreamHiveJsonSerDe;
        openXJsonSerDe?: outputs.kinesisfirehose.DeliveryStreamOpenXJsonSerDe;
    }
    interface DeliveryStreamDynamicPartitioningConfiguration {
        enabled?: boolean;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamRetryOptions;
    }
    interface DeliveryStreamElasticsearchBufferingHints {
        intervalInSeconds?: number;
        sizeInMBs?: number;
    }
    interface DeliveryStreamElasticsearchDestinationConfiguration {
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamElasticsearchBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        clusterEndpoint?: string;
        domainARN?: string;
        indexName: string;
        indexRotationPeriod?: enums.kinesisfirehose.DeliveryStreamElasticsearchDestinationConfigurationIndexRotationPeriod;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamElasticsearchRetryOptions;
        roleARN: string;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamElasticsearchDestinationConfigurationS3BackupMode;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        typeName?: string;
        vpcConfiguration?: outputs.kinesisfirehose.DeliveryStreamVpcConfiguration;
    }
    interface DeliveryStreamElasticsearchRetryOptions {
        durationInSeconds?: number;
    }
    interface DeliveryStreamEncryptionConfiguration {
        kMSEncryptionConfig?: outputs.kinesisfirehose.DeliveryStreamKMSEncryptionConfig;
        noEncryptionConfig?: enums.kinesisfirehose.DeliveryStreamEncryptionConfigurationNoEncryptionConfig;
    }
    interface DeliveryStreamEncryptionConfigurationInput {
        keyARN?: string;
        keyType: enums.kinesisfirehose.DeliveryStreamEncryptionConfigurationInputKeyType;
    }
    interface DeliveryStreamExtendedS3DestinationConfiguration {
        bucketARN: string;
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        compressionFormat?: enums.kinesisfirehose.DeliveryStreamExtendedS3DestinationConfigurationCompressionFormat;
        dataFormatConversionConfiguration?: outputs.kinesisfirehose.DeliveryStreamDataFormatConversionConfiguration;
        dynamicPartitioningConfiguration?: outputs.kinesisfirehose.DeliveryStreamDynamicPartitioningConfiguration;
        encryptionConfiguration?: outputs.kinesisfirehose.DeliveryStreamEncryptionConfiguration;
        errorOutputPrefix?: string;
        prefix?: string;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        roleARN: string;
        s3BackupConfiguration?: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamExtendedS3DestinationConfigurationS3BackupMode;
    }
    interface DeliveryStreamHiveJsonSerDe {
        timestampFormats?: string[];
    }
    interface DeliveryStreamHttpEndpointCommonAttribute {
        attributeName: string;
        attributeValue: string;
    }
    interface DeliveryStreamHttpEndpointConfiguration {
        accessKey?: string;
        name?: string;
        url: string;
    }
    interface DeliveryStreamHttpEndpointDestinationConfiguration {
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        endpointConfiguration: outputs.kinesisfirehose.DeliveryStreamHttpEndpointConfiguration;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        requestConfiguration?: outputs.kinesisfirehose.DeliveryStreamHttpEndpointRequestConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamRetryOptions;
        roleARN?: string;
        s3BackupMode?: string;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
    }
    interface DeliveryStreamHttpEndpointRequestConfiguration {
        commonAttributes?: outputs.kinesisfirehose.DeliveryStreamHttpEndpointCommonAttribute[];
        contentEncoding?: enums.kinesisfirehose.DeliveryStreamHttpEndpointRequestConfigurationContentEncoding;
    }
    interface DeliveryStreamInputFormatConfiguration {
        deserializer?: outputs.kinesisfirehose.DeliveryStreamDeserializer;
    }
    interface DeliveryStreamKMSEncryptionConfig {
        aWSKMSKeyARN: string;
    }
    interface DeliveryStreamKinesisStreamSourceConfiguration {
        kinesisStreamARN: string;
        roleARN: string;
    }
    interface DeliveryStreamOpenXJsonSerDe {
        caseInsensitive?: boolean;
        columnToJsonKeyMappings?: any;
        convertDotsInJsonKeysToUnderscores?: boolean;
    }
    interface DeliveryStreamOrcSerDe {
        blockSizeBytes?: number;
        bloomFilterColumns?: string[];
        bloomFilterFalsePositiveProbability?: number;
        compression?: string;
        dictionaryKeyThreshold?: number;
        enablePadding?: boolean;
        formatVersion?: string;
        paddingTolerance?: number;
        rowIndexStride?: number;
        stripeSizeBytes?: number;
    }
    interface DeliveryStreamOutputFormatConfiguration {
        serializer?: outputs.kinesisfirehose.DeliveryStreamSerializer;
    }
    interface DeliveryStreamParquetSerDe {
        blockSizeBytes?: number;
        compression?: string;
        enableDictionaryCompression?: boolean;
        maxPaddingBytes?: number;
        pageSizeBytes?: number;
        writerVersion?: string;
    }
    interface DeliveryStreamProcessingConfiguration {
        enabled?: boolean;
        processors?: outputs.kinesisfirehose.DeliveryStreamProcessor[];
    }
    interface DeliveryStreamProcessor {
        parameters?: outputs.kinesisfirehose.DeliveryStreamProcessorParameter[];
        type: enums.kinesisfirehose.DeliveryStreamProcessorType;
    }
    interface DeliveryStreamProcessorParameter {
        parameterName: string;
        parameterValue: string;
    }
    interface DeliveryStreamRedshiftDestinationConfiguration {
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        clusterJDBCURL: string;
        copyCommand: outputs.kinesisfirehose.DeliveryStreamCopyCommand;
        password: string;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamRedshiftRetryOptions;
        roleARN: string;
        s3BackupConfiguration?: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamRedshiftDestinationConfigurationS3BackupMode;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        username: string;
    }
    interface DeliveryStreamRedshiftRetryOptions {
        durationInSeconds?: number;
    }
    interface DeliveryStreamRetryOptions {
        durationInSeconds?: number;
    }
    interface DeliveryStreamS3DestinationConfiguration {
        bucketARN: string;
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        compressionFormat?: enums.kinesisfirehose.DeliveryStreamS3DestinationConfigurationCompressionFormat;
        encryptionConfiguration?: outputs.kinesisfirehose.DeliveryStreamEncryptionConfiguration;
        errorOutputPrefix?: string;
        prefix?: string;
        roleARN: string;
    }
    interface DeliveryStreamSchemaConfiguration {
        catalogId?: string;
        databaseName?: string;
        region?: string;
        roleARN?: string;
        tableName?: string;
        versionId?: string;
    }
    interface DeliveryStreamSerializer {
        orcSerDe?: outputs.kinesisfirehose.DeliveryStreamOrcSerDe;
        parquetSerDe?: outputs.kinesisfirehose.DeliveryStreamParquetSerDe;
    }
    interface DeliveryStreamSplunkDestinationConfiguration {
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        hECAcknowledgmentTimeoutInSeconds?: number;
        hECEndpoint: string;
        hECEndpointType: enums.kinesisfirehose.DeliveryStreamSplunkDestinationConfigurationHECEndpointType;
        hECToken: string;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamSplunkRetryOptions;
        s3BackupMode?: string;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
    }
    interface DeliveryStreamSplunkRetryOptions {
        durationInSeconds?: number;
    }
    interface DeliveryStreamTag {
        key: string;
        value?: string;
    }
    interface DeliveryStreamVpcConfiguration {
        roleARN: string;
        securityGroupIds: string[];
        subnetIds: string[];
    }
}
export declare namespace kinesisvideo {
    /**
     * A key-value pair to associate with a resource.
     */
    interface SignalingChannelTag {
        /**
         * The key name of the tag. Specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. The following characters can be used: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. Specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:.  The following characters can be used: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associated with the Kinesis Video Stream.
     */
    interface StreamTag {
        /**
         * The key name of the tag. Specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. The following characters can be used: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. Specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. The following characters can be used: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace kms {
    /**
     * A key-value pair to associate with a resource.
     */
    interface KeyTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ReplicaKeyTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace lakeformation {
    /**
     * An object representing the Data Cells Filter's Columns. Either Column Names or a Wildcard is required.
     */
    interface DataCellsFilterColumnWildcard {
        /**
         * A list of column names to be excluded from the Data Cells Filter.
         */
        excludedColumnNames?: string[];
    }
    /**
     * An object representing the Data Cells Filter's Row Filter. Either a Filter Expression or a Wildcard is required.
     */
    interface DataCellsFilterRowFilter {
        /**
         * An empty object representing a row wildcard.
         */
        allRowsWildcard?: any;
        /**
         * A PartiQL predicate.
         */
        filterExpression?: string;
    }
    interface DataLakeSettingsAdmins {
    }
    interface PermissionsColumnWildcard {
        excludedColumnNames?: string[];
    }
    interface PermissionsDataLakePrincipal {
        dataLakePrincipalIdentifier?: string;
    }
    interface PermissionsDataLocationResource {
        catalogId?: string;
        s3Resource?: string;
    }
    interface PermissionsDatabaseResource {
        catalogId?: string;
        name?: string;
    }
    interface PermissionsResource {
        dataLocationResource?: outputs.lakeformation.PermissionsDataLocationResource;
        databaseResource?: outputs.lakeformation.PermissionsDatabaseResource;
        tableResource?: outputs.lakeformation.PermissionsTableResource;
        tableWithColumnsResource?: outputs.lakeformation.PermissionsTableWithColumnsResource;
    }
    interface PermissionsTableResource {
        catalogId?: string;
        databaseName?: string;
        name?: string;
        tableWildcard?: outputs.lakeformation.PermissionsTableWildcard;
    }
    interface PermissionsTableWildcard {
    }
    interface PermissionsTableWithColumnsResource {
        catalogId?: string;
        columnNames?: string[];
        columnWildcard?: outputs.lakeformation.PermissionsColumnWildcard;
        databaseName?: string;
        name?: string;
    }
    interface PrincipalPermissionsCatalogResource {
    }
    interface PrincipalPermissionsColumnWildcard {
        excludedColumnNames?: string[];
    }
    interface PrincipalPermissionsDataCellsFilterResource {
        databaseName: string;
        name: string;
        tableCatalogId: string;
        tableName: string;
    }
    interface PrincipalPermissionsDataLakePrincipal {
        dataLakePrincipalIdentifier?: string;
    }
    interface PrincipalPermissionsDataLocationResource {
        catalogId: string;
        resourceArn: string;
    }
    interface PrincipalPermissionsDatabaseResource {
        catalogId: string;
        name: string;
    }
    interface PrincipalPermissionsLFTag {
        tagKey?: string;
        tagValues?: string[];
    }
    interface PrincipalPermissionsLFTagKeyResource {
        catalogId: string;
        tagKey: string;
        tagValues: string[];
    }
    interface PrincipalPermissionsLFTagPolicyResource {
        catalogId: string;
        expression: outputs.lakeformation.PrincipalPermissionsLFTag[];
        resourceType: enums.lakeformation.PrincipalPermissionsResourceType;
    }
    interface PrincipalPermissionsResource {
        catalog?: outputs.lakeformation.PrincipalPermissionsCatalogResource;
        dataCellsFilter?: outputs.lakeformation.PrincipalPermissionsDataCellsFilterResource;
        dataLocation?: outputs.lakeformation.PrincipalPermissionsDataLocationResource;
        database?: outputs.lakeformation.PrincipalPermissionsDatabaseResource;
        lFTag?: outputs.lakeformation.PrincipalPermissionsLFTagKeyResource;
        lFTagPolicy?: outputs.lakeformation.PrincipalPermissionsLFTagPolicyResource;
        table?: outputs.lakeformation.PrincipalPermissionsTableResource;
        tableWithColumns?: outputs.lakeformation.PrincipalPermissionsTableWithColumnsResource;
    }
    interface PrincipalPermissionsTableResource {
        catalogId: string;
        databaseName: string;
        name?: string;
        tableWildcard?: outputs.lakeformation.PrincipalPermissionsTableWildcard;
    }
    interface PrincipalPermissionsTableWildcard {
    }
    interface PrincipalPermissionsTableWithColumnsResource {
        catalogId: string;
        columnNames?: string[];
        columnWildcard?: outputs.lakeformation.PrincipalPermissionsColumnWildcard;
        databaseName: string;
        name: string;
    }
    interface TagAssociationCatalogResource {
    }
    interface TagAssociationDatabaseResource {
        catalogId: string;
        name: string;
    }
    interface TagAssociationLFTagPair {
        catalogId: string;
        tagKey: string;
        tagValues: string[];
    }
    interface TagAssociationResource {
        catalog?: outputs.lakeformation.TagAssociationCatalogResource;
        database?: outputs.lakeformation.TagAssociationDatabaseResource;
        table?: outputs.lakeformation.TagAssociationTableResource;
        tableWithColumns?: outputs.lakeformation.TagAssociationTableWithColumnsResource;
    }
    interface TagAssociationTableResource {
        catalogId: string;
        databaseName: string;
        name?: string;
        tableWildcard?: outputs.lakeformation.TagAssociationTableWildcard;
    }
    interface TagAssociationTableWildcard {
    }
    interface TagAssociationTableWithColumnsResource {
        catalogId: string;
        columnNames: string[];
        databaseName: string;
        name: string;
    }
}
export declare namespace lambda {
    interface AliasProvisionedConcurrencyConfiguration {
        provisionedConcurrentExecutions: number;
    }
    interface AliasRoutingConfiguration {
        additionalVersionWeights: outputs.lambda.AliasVersionWeight[];
    }
    interface AliasVersionWeight {
        functionVersion: string;
        functionWeight: number;
    }
    /**
     * When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
     */
    interface CodeSigningConfigAllowedPublishers {
        /**
         * List of Signing profile version Arns
         */
        signingProfileVersionArns: string[];
    }
    /**
     * Policies to control how to act if a signature is invalid
     */
    interface CodeSigningConfigCodeSigningPolicies {
        /**
         * Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
         */
        untrustedArtifactOnDeployment: enums.lambda.CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment;
    }
    interface EventInvokeConfigDestinationConfig {
        onFailure?: outputs.lambda.EventInvokeConfigOnFailure;
        onSuccess?: outputs.lambda.EventInvokeConfigOnSuccess;
    }
    interface EventInvokeConfigOnFailure {
        destination: string;
    }
    interface EventInvokeConfigOnSuccess {
        destination: string;
    }
    /**
     * Specific configuration settings for an MSK event source.
     */
    interface EventSourceMappingAmazonManagedKafkaEventSourceConfig {
        /**
         * The identifier for the Kafka Consumer Group to join.
         */
        consumerGroupId?: string;
    }
    /**
     * (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
     */
    interface EventSourceMappingDestinationConfig {
        /**
         * The destination configuration for failed invocations.
         */
        onFailure?: outputs.lambda.EventSourceMappingOnFailure;
    }
    /**
     * The endpoints used by AWS Lambda to access a self-managed event source.
     */
    interface EventSourceMappingEndpoints {
        /**
         * A list of Kafka server endpoints.
         */
        kafkaBootstrapServers?: string[];
    }
    /**
     * The filter object that defines parameters for ESM filtering.
     */
    interface EventSourceMappingFilter {
        /**
         * The filter pattern that defines which events should be passed for invocations.
         */
        pattern?: string;
    }
    /**
     * The filter criteria to control event filtering.
     */
    interface EventSourceMappingFilterCriteria {
        /**
         * List of filters of this FilterCriteria
         */
        filters?: outputs.lambda.EventSourceMappingFilter[];
    }
    /**
     * A destination for events that failed processing.
     */
    interface EventSourceMappingOnFailure {
        /**
         * The Amazon Resource Name (ARN) of the destination resource.
         */
        destination?: string;
    }
    /**
     * The configuration used by AWS Lambda to access a self-managed event source.
     */
    interface EventSourceMappingSelfManagedEventSource {
        /**
         * The endpoints for a self-managed event source.
         */
        endpoints?: outputs.lambda.EventSourceMappingEndpoints;
    }
    /**
     * Specific configuration settings for a Self-Managed Apache Kafka event source.
     */
    interface EventSourceMappingSelfManagedKafkaEventSourceConfig {
        /**
         * The identifier for the Kafka Consumer Group to join.
         */
        consumerGroupId?: string;
    }
    /**
     * The configuration used by AWS Lambda to access event source
     */
    interface EventSourceMappingSourceAccessConfiguration {
        /**
         * The type of source access configuration.
         */
        type?: enums.lambda.EventSourceMappingSourceAccessConfigurationType;
        /**
         * The URI for the source access configuration resource.
         */
        uRI?: string;
    }
    interface FunctionCode {
        /**
         * ImageUri.
         */
        imageUri?: string;
        /**
         * An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
         */
        s3Bucket?: string;
        /**
         * The Amazon S3 key of the deployment package.
         */
        s3Key?: string;
        /**
         * For versioned objects, the version of the deployment package object to use.
         */
        s3ObjectVersion?: string;
        /**
         * The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
         */
        zipFile?: string;
    }
    /**
     * The dead-letter queue for failed asynchronous invocations.
     */
    interface FunctionDeadLetterConfig {
        /**
         * The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
         */
        targetArn?: string;
    }
    /**
     * A function's environment variable settings.
     */
    interface FunctionEnvironment {
        /**
         * Environment variable key-value pairs.
         */
        variables?: any;
    }
    /**
     * A function's ephemeral storage settings.
     */
    interface FunctionEphemeralStorage {
        /**
         * The amount of ephemeral storage that your function has access to.
         */
        size: number;
    }
    interface FunctionFileSystemConfig {
        /**
         * The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
         */
        arn: string;
        /**
         * The path where the function can access the file system, starting with /mnt/.
         */
        localMountPath: string;
    }
    interface FunctionImageConfig {
        /**
         * Command.
         */
        command?: string[];
        /**
         * EntryPoint.
         */
        entryPoint?: string[];
        /**
         * WorkingDirectory.
         */
        workingDirectory?: string;
    }
    interface FunctionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set Mode to Active.
     */
    interface FunctionTracingConfig {
        /**
         * The tracing mode.
         */
        mode?: enums.lambda.FunctionTracingConfigMode;
    }
    /**
     * The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC.
     */
    interface FunctionVpcConfig {
        /**
         * A list of VPC security groups IDs.
         */
        securityGroupIds?: string[];
        /**
         * A list of VPC subnet IDs.
         */
        subnetIds?: string[];
    }
    interface LayerVersionContent {
        s3Bucket: string;
        s3Key: string;
        s3ObjectVersion?: string;
    }
    interface UrlCors {
        /**
         * Specifies whether credentials are included in the CORS request.
         */
        allowCredentials?: boolean;
        /**
         * Represents a collection of allowed headers.
         */
        allowHeaders?: string[];
        /**
         * Represents a collection of allowed HTTP methods.
         */
        allowMethods?: enums.lambda.UrlAllowMethodsItem[];
        /**
         * Represents a collection of allowed origins.
         */
        allowOrigins?: string[];
        /**
         * Represents a collection of exposed headers.
         */
        exposeHeaders?: string[];
        maxAge?: number;
    }
    interface VersionProvisionedConcurrencyConfiguration {
        provisionedConcurrentExecutions: number;
    }
}
export declare namespace lex {
    /**
     * Provides settings that enable advanced recognition settings for slot values.
     */
    interface BotAdvancedRecognitionSetting {
        audioRecognitionStrategy?: enums.lex.BotAudioRecognitionStrategy;
    }
    /**
     * The location of audio log files collected when conversation logging is enabled for a bot.
     */
    interface BotAliasAudioLogDestination {
        s3Bucket: outputs.lex.BotAliasS3BucketLogDestination;
    }
    /**
     * Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
     */
    interface BotAliasAudioLogSetting {
        destination: outputs.lex.BotAliasAudioLogDestination;
        enabled: boolean;
    }
    interface BotAliasCloudWatchLogGroupLogDestination {
        /**
         * A string used to identify the groupArn for the Cloudwatch Log Group
         */
        cloudWatchLogGroupArn: string;
        /**
         * A string containing the value for the Log Prefix
         */
        logPrefix: string;
    }
    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    interface BotAliasCodeHookSpecification {
        lambdaCodeHook: outputs.lex.BotAliasLambdaCodeHook;
    }
    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    interface BotAliasConversationLogSettings {
        audioLogSettings?: outputs.lex.BotAliasAudioLogSetting[];
        textLogSettings?: outputs.lex.BotAliasTextLogSetting[];
    }
    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    interface BotAliasLambdaCodeHook {
        /**
         * The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
         */
        codeHookInterfaceVersion: string;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function.
         */
        lambdaArn: string;
    }
    /**
     * You can use this parameter to specify a specific Lambda function to run different functions in different locales.
     */
    interface BotAliasLocaleSettings {
        codeHookSpecification?: outputs.lex.BotAliasCodeHookSpecification;
        /**
         * Whether the Lambda code hook is enabled
         */
        enabled: boolean;
    }
    /**
     * A locale setting in alias
     */
    interface BotAliasLocaleSettingsItem {
        botAliasLocaleSetting: outputs.lex.BotAliasLocaleSettings;
        /**
         * A string used to identify the locale
         */
        localeId: string;
    }
    /**
     * Specifies an Amazon S3 bucket for logging audio conversations
     */
    interface BotAliasS3BucketLogDestination {
        /**
         * The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
         */
        kmsKeyArn?: string;
        /**
         * The Amazon S3 key of the deployment package.
         */
        logPrefix: string;
        /**
         * The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
         */
        s3BucketArn: string;
    }
    /**
     * A label for tagging Lex resources
     */
    interface BotAliasTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    /**
     * Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
     */
    interface BotAliasTextLogDestination {
        cloudWatch: outputs.lex.BotAliasCloudWatchLogGroupLogDestination;
    }
    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    interface BotAliasTextLogSetting {
        destination: outputs.lex.BotAliasTextLogDestination;
        enabled: boolean;
    }
    /**
     * The location of audio log files collected when conversation logging is enabled for a bot.
     */
    interface BotAudioLogDestination {
        s3Bucket: outputs.lex.BotS3BucketLogDestination;
    }
    /**
     * Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
     */
    interface BotAudioLogSetting {
        destination: outputs.lex.BotAudioLogDestination;
        enabled: boolean;
    }
    /**
     * A button to use on a response card used to gather slot values from a user.
     */
    interface BotButton {
        /**
         * The text that appears on the button.
         */
        text: string;
        /**
         * The value returned to Amazon Lex when the user chooses this button.
         */
        value: string;
    }
    interface BotCloudWatchLogGroupLogDestination {
        /**
         * A string used to identify the groupArn for the Cloudwatch Log Group
         */
        cloudWatchLogGroupArn: string;
        /**
         * A string containing the value for the Log Prefix
         */
        logPrefix: string;
    }
    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    interface BotConversationLogSettings {
        audioLogSettings?: outputs.lex.BotAudioLogSetting[];
        textLogSettings?: outputs.lex.BotTextLogSetting[];
    }
    /**
     * A message in a custom format defined by the client application.
     */
    interface BotCustomPayload {
        /**
         * The string that is sent to your application.
         */
        value: string;
    }
    /**
     * A custom vocabulary is a list of specific phrases that you want Amazon Lex V2 to recognize in the audio input.
     */
    interface BotCustomVocabulary {
        customVocabularyItems: outputs.lex.BotCustomVocabularyItem[];
    }
    /**
     * A custom vocabulary item that contains the phrase to recognize and a weight to give the boost.
     */
    interface BotCustomVocabularyItem {
        /**
         * Phrase that should be recognized.
         */
        phrase: string;
        /**
         * The degree to which the phrase recognition is boosted.
         */
        weight?: number;
    }
    /**
     * Settings that determine the Lambda function that Amazon Lex uses for processing user responses.
     */
    interface BotDialogCodeHookSetting {
        enabled: boolean;
    }
    /**
     * Provides information about the external source of the slot type's definition.
     */
    interface BotExternalSourceSetting {
        grammarSlotTypeSetting?: outputs.lex.BotGrammarSlotTypeSetting;
    }
    /**
     * Settings that determine if a Lambda function should be invoked to fulfill a specific intent.
     */
    interface BotFulfillmentCodeHookSetting {
        enabled: boolean;
        fulfillmentUpdatesSpecification?: outputs.lex.BotFulfillmentUpdatesSpecification;
        postFulfillmentStatusSpecification?: outputs.lex.BotPostFulfillmentStatusSpecification;
    }
    /**
     * Provides settings for a message that is sent to the user when a fulfillment Lambda function starts running.
     */
    interface BotFulfillmentStartResponseSpecification {
        /**
         * Determines whether the user can interrupt the start message while it is playing.
         */
        allowInterrupt?: boolean;
        /**
         * The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
         */
        delayInSeconds: number;
        messageGroups: outputs.lex.BotMessageGroup[];
    }
    /**
     * Provides settings for a message that is sent periodically to the user while a fulfillment Lambda function is running.
     */
    interface BotFulfillmentUpdateResponseSpecification {
        /**
         * Determines whether the user can interrupt an update message while it is playing.
         */
        allowInterrupt?: boolean;
        /**
         * The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
         */
        frequencyInSeconds: number;
        messageGroups: outputs.lex.BotMessageGroup[];
    }
    /**
     * Provides information for updating the user on the progress of fulfilling an intent.
     */
    interface BotFulfillmentUpdatesSpecification {
        /**
         * Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent.
         */
        active: boolean;
        startResponse?: outputs.lex.BotFulfillmentStartResponseSpecification;
        /**
         * The length of time that the fulfillment Lambda function should run before it times out.
         */
        timeoutInSeconds?: number;
        updateResponse?: outputs.lex.BotFulfillmentUpdateResponseSpecification;
    }
    /**
     * Settings required for a slot type based on a grammar that you provide.
     */
    interface BotGrammarSlotTypeSetting {
        source?: outputs.lex.BotGrammarSlotTypeSource;
    }
    /**
     * Describes the Amazon S3 bucket name and location for the grammar that is the source for the slot type.
     */
    interface BotGrammarSlotTypeSource {
        /**
         * The Amazon KMS key required to decrypt the contents of the grammar, if any.
         */
        kmsKeyArn?: string;
        /**
         * The name of the S3 bucket that contains the grammar source.
         */
        s3BucketName: string;
        /**
         * The path to the grammar in the S3 bucket.
         */
        s3ObjectKey: string;
    }
    /**
     * A message that defines a response card that the client application can show to the user.
     */
    interface BotImageResponseCard {
        /**
         * A list of buttons that should be displayed on the response card.
         */
        buttons?: outputs.lex.BotButton[];
        /**
         * The URL of an image to display on the response card.
         */
        imageUrl?: string;
        /**
         * The subtitle to display on the response card.
         */
        subtitle?: string;
        /**
         * The title to display on the response card.
         */
        title: string;
    }
    /**
     * InputContext specified for the intent.
     */
    interface BotInputContext {
        /**
         * The name of the context.
         */
        name: string;
    }
    /**
     * An intent represents an action that the user wants to perform. You create a bot to support one or more related intents.
     */
    interface BotIntent {
        description?: string;
        dialogCodeHook?: outputs.lex.BotDialogCodeHookSetting;
        fulfillmentCodeHook?: outputs.lex.BotFulfillmentCodeHookSetting;
        inputContexts?: outputs.lex.BotInputContext[];
        intentClosingSetting?: outputs.lex.BotIntentClosingSetting;
        intentConfirmationSetting?: outputs.lex.BotIntentConfirmationSetting;
        kendraConfiguration?: outputs.lex.BotKendraConfiguration;
        name: string;
        outputContexts?: outputs.lex.BotOutputContext[];
        parentIntentSignature?: string;
        sampleUtterances?: outputs.lex.BotSampleUtterance[];
        slotPriorities?: outputs.lex.BotSlotPriority[];
        /**
         * List of slots
         */
        slots?: outputs.lex.BotSlot[];
    }
    /**
     * Response that Amazon Lex sends to the user when the intent is closed.
     */
    interface BotIntentClosingSetting {
        closingResponse: outputs.lex.BotResponseSpecification;
        isActive?: boolean;
    }
    /**
     * Prompts that Amazon Lex sends to the user to confirm the completion of an intent.
     */
    interface BotIntentConfirmationSetting {
        declinationResponse: outputs.lex.BotResponseSpecification;
        isActive?: boolean;
        promptSpecification: outputs.lex.BotPromptSpecification;
    }
    /**
     * Configuration for searching a Amazon Kendra index specified for the intent.
     */
    interface BotKendraConfiguration {
        kendraIndex: string;
        queryFilterString?: string;
        /**
         * Determines whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
         */
        queryFilterStringEnabled?: boolean;
    }
    /**
     * A locale in the bot, which contains the intents and slot types that the bot uses in conversations with users in the specified language and locale.
     */
    interface BotLocale {
        customVocabulary?: outputs.lex.BotCustomVocabulary;
        description?: string;
        /**
         * List of intents
         */
        intents?: outputs.lex.BotIntent[];
        localeId: string;
        nluConfidenceThreshold: number;
        /**
         * List of SlotTypes
         */
        slotTypes?: outputs.lex.BotSlotType[];
        voiceSettings?: outputs.lex.BotVoiceSettings;
    }
    /**
     * The primary message that Amazon Lex should send to the user.
     */
    interface BotMessage {
        customPayload?: outputs.lex.BotCustomPayload;
        imageResponseCard?: outputs.lex.BotImageResponseCard;
        plainTextMessage?: outputs.lex.BotPlainTextMessage;
        sSMLMessage?: outputs.lex.BotSSMLMessage;
    }
    /**
     * One or more messages that Amazon Lex can send to the user.
     */
    interface BotMessageGroup {
        message: outputs.lex.BotMessage;
        /**
         * Message variations to send to the user.
         */
        variations?: outputs.lex.BotMessage[];
    }
    /**
     * Indicates whether a slot can return multiple values.
     */
    interface BotMultipleValuesSetting {
        allowMultipleValues?: boolean;
    }
    /**
     * Determines whether Amazon Lex obscures slot values in conversation logs.
     */
    interface BotObfuscationSetting {
        /**
         * Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
         */
        obfuscationSettingType: enums.lex.BotObfuscationSettingObfuscationSettingType;
    }
    /**
     * A session context that is activated when an intent is fulfilled.
     */
    interface BotOutputContext {
        name: string;
        timeToLiveInSeconds: number;
        turnsToLive: number;
    }
    /**
     * A message in plain text format.
     */
    interface BotPlainTextMessage {
        /**
         * The message to send to the user.
         */
        value: string;
    }
    /**
     * Provides information for updating the user on the progress of fulfilling an intent.
     */
    interface BotPostFulfillmentStatusSpecification {
        failureResponse?: outputs.lex.BotResponseSpecification;
        successResponse?: outputs.lex.BotResponseSpecification;
        timeoutResponse?: outputs.lex.BotResponseSpecification;
    }
    /**
     * Prompts the user to confirm the intent.
     */
    interface BotPromptSpecification {
        /**
         * Indicates whether the user can interrupt a speech prompt from the bot.
         */
        allowInterrupt?: boolean;
        maxRetries: number;
        messageGroupsList: outputs.lex.BotMessageGroup[];
        messageSelectionStrategy?: enums.lex.BotMessageSelectionStrategy;
        /**
         * Specifies the advanced settings on each attempt of the prompt.
         */
        promptAttemptsSpecification?: any;
    }
    /**
     * A list of message groups that Amazon Lex uses to respond the user input.
     */
    interface BotResponseSpecification {
        /**
         * Indicates whether the user can interrupt a speech prompt from the bot.
         */
        allowInterrupt?: boolean;
        messageGroupsList: outputs.lex.BotMessageGroup[];
    }
    /**
     * Specifies an Amazon S3 bucket for logging audio conversations
     */
    interface BotS3BucketLogDestination {
        /**
         * The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
         */
        kmsKeyArn?: string;
        /**
         * The Amazon S3 key of the deployment package.
         */
        logPrefix: string;
        /**
         * The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
         */
        s3BucketArn: string;
    }
    /**
     * S3 location of bot definitions zip file, if it's not defined inline in CloudFormation.
     */
    interface BotS3Location {
        /**
         * An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
         */
        s3Bucket: string;
        /**
         * The Amazon S3 key of the deployment package.
         */
        s3ObjectKey: string;
        /**
         * For versioned objects, the version of the deployment package object to use. If not specified, the current object version will be used.
         */
        s3ObjectVersion?: string;
    }
    /**
     * A message in Speech Synthesis Markup Language (SSML).
     */
    interface BotSSMLMessage {
        /**
         * The SSML text that defines the prompt.
         */
        value: string;
    }
    /**
     * A sample utterance that invokes an intent or respond to a slot elicitation prompt.
     */
    interface BotSampleUtterance {
        utterance: string;
    }
    /**
     * Defines one of the values for a slot type.
     */
    interface BotSampleValue {
        /**
         * The value that can be used for a slot type.
         */
        value: string;
    }
    /**
     * A slot is a variable needed to fulfill an intent, where an intent can require zero or more slots.
     */
    interface BotSlot {
        description?: string;
        multipleValuesSetting?: outputs.lex.BotMultipleValuesSetting;
        name: string;
        obfuscationSetting?: outputs.lex.BotObfuscationSetting;
        slotTypeName: string;
        valueElicitationSetting: outputs.lex.BotSlotValueElicitationSetting;
    }
    /**
     * The default value to use when a user doesn't provide a value for a slot.
     */
    interface BotSlotDefaultValue {
        /**
         * The default value to use when a user doesn't provide a value for a slot.
         */
        defaultValue: string;
    }
    /**
     * A list of values that Amazon Lex should use as the default value for a slot.
     */
    interface BotSlotDefaultValueSpecification {
        /**
         * A list of slot default values
         */
        defaultValueList: outputs.lex.BotSlotDefaultValue[];
    }
    /**
     * The priority that Amazon Lex should use when eliciting slot values from a user.
     */
    interface BotSlotPriority {
        priority: number;
        /**
         * The name of the slot.
         */
        slotName: string;
    }
    /**
     * A custom, extended built-in or a grammar slot type.
     */
    interface BotSlotType {
        description?: string;
        externalSourceSetting?: outputs.lex.BotExternalSourceSetting;
        name: string;
        parentSlotTypeSignature?: string;
        slotTypeValues?: outputs.lex.BotSlotTypeValue[];
        valueSelectionSetting?: outputs.lex.BotSlotValueSelectionSetting;
    }
    /**
     * Value that the slot type can take.
     */
    interface BotSlotTypeValue {
        sampleValue: outputs.lex.BotSampleValue;
        synonyms?: outputs.lex.BotSampleValue[];
    }
    /**
     * Settings that you can use for eliciting a slot value.
     */
    interface BotSlotValueElicitationSetting {
        /**
         * A list of default values for a slot.
         */
        defaultValueSpecification?: outputs.lex.BotSlotDefaultValueSpecification;
        /**
         * The prompt that Amazon Lex uses to elicit the slot value from the user.
         */
        promptSpecification?: outputs.lex.BotPromptSpecification;
        /**
         * If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy.
         */
        sampleUtterances?: outputs.lex.BotSampleUtterance[];
        /**
         * Specifies whether the slot is required or optional.
         */
        slotConstraint: enums.lex.BotSlotConstraint;
        /**
         * Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
         */
        waitAndContinueSpecification?: outputs.lex.BotWaitAndContinueSpecification;
    }
    /**
     * A regular expression used to validate the value of a slot.
     */
    interface BotSlotValueRegexFilter {
        /**
         * Regex pattern
         */
        pattern: string;
    }
    /**
     * Contains settings used by Amazon Lex to select a slot value.
     */
    interface BotSlotValueSelectionSetting {
        advancedRecognitionSetting?: outputs.lex.BotAdvancedRecognitionSetting;
        regexFilter?: outputs.lex.BotSlotValueRegexFilter;
        resolutionStrategy: enums.lex.BotSlotValueResolutionStrategy;
    }
    /**
     * StillWaitingResponseSpecification.
     */
    interface BotStillWaitingResponseSpecification {
        /**
         * Indicates whether the user can interrupt a speech prompt from the bot.
         */
        allowInterrupt?: boolean;
        frequencyInSeconds: number;
        messageGroupsList: outputs.lex.BotMessageGroup[];
        timeoutInSeconds: number;
    }
    /**
     * A key-value pair for tagging Lex resources
     */
    interface BotTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Configuring the test bot alias settings for a given bot
     */
    interface BotTestBotAliasSettings {
        botAliasLocaleSettings?: outputs.lex.BotAliasLocaleSettingsItem[];
        conversationLogSettings?: outputs.lex.BotConversationLogSettings;
        description?: string;
        /**
         * Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
         */
        sentimentAnalysisSettings?: outputs.lex.BotTestBotAliasSettingsSentimentAnalysisSettingsProperties;
    }
    /**
     * Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
     */
    interface BotTestBotAliasSettingsSentimentAnalysisSettingsProperties {
        /**
         * Enable to call Amazon Comprehend for Sentiment natively within Lex
         */
        detectSentiment: boolean;
    }
    /**
     * Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
     */
    interface BotTextLogDestination {
        cloudWatch: outputs.lex.BotCloudWatchLogGroupLogDestination;
    }
    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    interface BotTextLogSetting {
        destination: outputs.lex.BotTextLogDestination;
        enabled: boolean;
    }
    /**
     * The version of a bot used for a bot locale.
     */
    interface BotVersionLocaleDetails {
        sourceBotVersion: string;
    }
    interface BotVersionLocaleSpecification {
        botVersionLocaleDetails: outputs.lex.BotVersionLocaleDetails;
        localeId: string;
    }
    /**
     * Settings for using an Amazon Polly voice to communicate with a user.
     */
    interface BotVoiceSettings {
        /**
         * Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the engine parameter of the SynthesizeSpeech operation in the Amazon Polly developer guide.
         */
        engine?: enums.lex.BotVoiceSettingsEngine;
        /**
         * The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
         */
        voiceId: string;
    }
    /**
     * The prompts that Amazon Lex uses while a bot is waiting for customer input.
     */
    interface BotWaitAndContinueSpecification {
        /**
         * The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
         */
        continueResponse: outputs.lex.BotResponseSpecification;
        /**
         * Specifies whether the bot will wait for a user to respond.
         */
        isActive?: boolean;
        /**
         * The response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
         */
        stillWaitingResponse?: outputs.lex.BotStillWaitingResponseSpecification;
        /**
         * The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
         */
        waitingResponse: outputs.lex.BotResponseSpecification;
    }
    /**
     * Data privacy setting of the Bot.
     */
    interface DataPrivacyProperties {
        childDirected: boolean;
    }
    /**
     * A resource policy to add to the resource. The policy is a JSON structure following the IAM syntax that contains one or more statements that define the policy.
     */
    interface ResourcePolicyPolicy {
    }
    /**
     * Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
     */
    interface SentimentAnalysisSettingsProperties {
        /**
         * Enable to call Amazon Comprehend for Sentiment natively within Lex
         */
        detectSentiment: boolean;
    }
}
export declare namespace licensemanager {
    interface LicenseBorrowConfiguration {
        allowEarlyCheckIn: boolean;
        maxTimeToLiveInMinutes: number;
    }
    interface LicenseConsumptionConfiguration {
        borrowConfiguration?: outputs.licensemanager.LicenseBorrowConfiguration;
        provisionalConfiguration?: outputs.licensemanager.LicenseProvisionalConfiguration;
        renewType?: string;
    }
    interface LicenseEntitlement {
        allowCheckIn?: boolean;
        maxCount?: number;
        name: string;
        overage?: boolean;
        unit: string;
        value?: string;
    }
    interface LicenseIssuerData {
        name: string;
        signKey?: string;
    }
    interface LicenseMetadata {
        name: string;
        value: string;
    }
    interface LicenseProvisionalConfiguration {
        maxTimeToLiveInMinutes: number;
    }
    interface LicenseValidityDateFormat {
        /**
         * Validity begin date for the license.
         */
        begin: string;
        /**
         * Validity begin date for the license.
         */
        end: string;
    }
}
export declare namespace lightsail {
    /**
     * An object that sets the public accessibility of objects in the specified bucket.
     */
    interface BucketAccessRules {
        /**
         * A Boolean value that indicates whether the access control list (ACL) permissions that are applied to individual objects override the getObject option that is currently specified.
         */
        allowPublicOverrides?: boolean;
        /**
         * Specifies the anonymous access to all objects in a bucket.
         */
        getObject?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface BucketTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface CertificateTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * Describes the settings of a container that will be launched, or that is launched, to an Amazon Lightsail container service.
     */
    interface Container {
        /**
         * The launch command for the container.
         */
        command?: string[];
        /**
         * The name of the container.
         */
        containerName?: string;
        /**
         * The environment variables of the container.
         */
        environment?: outputs.lightsail.ContainerEnvironmentVariable[];
        /**
         * The name of the image used for the container.
         */
        image?: string;
        /**
         * The open firewall ports of the container.
         */
        ports?: outputs.lightsail.ContainerPortInfo[];
    }
    interface ContainerEnvironmentVariable {
        value?: string;
        variable?: string;
    }
    /**
     * Describes the health check configuration of an Amazon Lightsail container service.
     */
    interface ContainerHealthCheckConfig {
        /**
         * The number of consecutive health checks successes required before moving the container to the Healthy state. The default value is 2.
         */
        healthyThreshold?: number;
        /**
         * The approximate interval, in seconds, between health checks of an individual container. You can specify between 5 and 300 seconds. The default value is 5.
         */
        intervalSeconds?: number;
        /**
         * The path on the container on which to perform the health check. The default value is /.
         */
        path?: string;
        /**
         * The HTTP codes to use when checking for a successful response from a container. You can specify values between 200 and 499. You can specify multiple values (for example, 200,202) or a range of values (for example, 200-299).
         */
        successCodes?: string;
        /**
         * The amount of time, in seconds, during which no response means a failed health check. You can specify between 2 and 60 seconds. The default value is 2.
         */
        timeoutSeconds?: number;
        /**
         * The number of consecutive health check failures required before moving the container to the Unhealthy state. The default value is 2.
         */
        unhealthyThreshold?: number;
    }
    interface ContainerPortInfo {
        port?: string;
        protocol?: string;
    }
    /**
     * The public domain name to use with the container service, such as example.com and www.example.com.
     */
    interface ContainerPublicDomainName {
        certificateName?: string;
        /**
         * An object that describes the configuration for the containers of the deployment.
         */
        domainNames?: string[];
    }
    /**
     * Describes the settings of a public endpoint for an Amazon Lightsail container service.
     */
    interface ContainerPublicEndpoint {
        /**
         * The name of the container for the endpoint.
         */
        containerName?: string;
        /**
         * The port of the container to which traffic is forwarded to.
         */
        containerPort?: number;
        /**
         * An object that describes the health check configuration of the container.
         */
        healthCheckConfig?: outputs.lightsail.ContainerHealthCheckConfig;
    }
    /**
     * Describes a container deployment configuration of an Amazon Lightsail container service.
     */
    interface ContainerServiceDeployment {
        /**
         * An object that describes the configuration for the containers of the deployment.
         */
        containers?: outputs.lightsail.Container[];
        /**
         * An object that describes the endpoint of the deployment.
         */
        publicEndpoint?: outputs.lightsail.ContainerPublicEndpoint;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ContainerTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * Describes the parameters of the database.
     */
    interface DatabaseRelationalDatabaseParameter {
        /**
         * Specifies the valid range of values for the parameter.
         */
        allowedValues?: string;
        /**
         * Indicates when parameter updates are applied. Can be immediate or pending-reboot.
         */
        applyMethod?: string;
        /**
         * Specifies the engine-specific parameter type.
         */
        applyType?: string;
        /**
         * Specifies the valid data type for the parameter.
         */
        dataType?: string;
        /**
         * Provides a description of the parameter.
         */
        description?: string;
        /**
         * A Boolean value indicating whether the parameter can be modified.
         */
        isModifiable?: boolean;
        /**
         * Specifies the name of the parameter.
         */
        parameterName?: string;
        /**
         * Specifies the value of the parameter.
         */
        parameterValue?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DatabaseTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * A addon associate with a resource.
     */
    interface DiskAddOn {
        /**
         * The add-on type
         */
        addOnType: string;
        autoSnapshotAddOnRequest?: outputs.lightsail.DiskAutoSnapshotAddOn;
        /**
         * Status of the Addon
         */
        status?: enums.lightsail.DiskAddOnStatus;
    }
    /**
     * An object that represents additional parameters when enabling or modifying the automatic snapshot add-on
     */
    interface DiskAutoSnapshotAddOn {
        /**
         * The daily time when an automatic snapshot will be created.
         */
        snapshotTimeOfDay?: string;
    }
    /**
     * Location of a resource.
     */
    interface DiskLocation {
        /**
         * The Availability Zone in which to create your disk. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
         */
        availabilityZone?: string;
        /**
         * The Region Name in which to create your disk.
         */
        regionName?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DiskTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * Describes the default cache behavior of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    interface DistributionCacheBehavior {
        /**
         * The cache behavior of the distribution.
         */
        behavior?: string;
    }
    /**
     * Describes the per-path cache behavior of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    interface DistributionCacheBehaviorPerPath {
        /**
         * The cache behavior for the specified path.
         */
        behavior?: string;
        /**
         * The path to a directory or file to cached, or not cache. Use an asterisk symbol to specify wildcard directories (path/to/assets/*), and file types (*.html, *jpg, *js). Directories and file paths are case-sensitive.
         */
        path?: string;
    }
    /**
     * Describes the cache settings of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    interface DistributionCacheSettings {
        /**
         * The HTTP methods that are processed and forwarded to the distribution's origin.
         */
        allowedHTTPMethods?: string;
        /**
         * The HTTP method responses that are cached by your distribution.
         */
        cachedHTTPMethods?: string;
        /**
         * The default amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the content has been updated.
         */
        defaultTTL?: number;
        /**
         * An object that describes the cookies that are forwarded to the origin. Your content is cached based on the cookies that are forwarded.
         */
        forwardedCookies?: outputs.lightsail.DistributionCookieObject;
        /**
         * An object that describes the headers that are forwarded to the origin. Your content is cached based on the headers that are forwarded.
         */
        forwardedHeaders?: outputs.lightsail.DistributionHeaderObject;
        /**
         * An object that describes the query strings that are forwarded to the origin. Your content is cached based on the query strings that are forwarded.
         */
        forwardedQueryStrings?: outputs.lightsail.DistributionQueryStringObject;
        /**
         * The maximum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        maximumTTL?: number;
        /**
         * The minimum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        minimumTTL?: number;
    }
    /**
     * Describes whether an Amazon Lightsail content delivery network (CDN) distribution forwards cookies to the origin and, if so, which ones.
     */
    interface DistributionCookieObject {
        /**
         * The specific cookies to forward to your distribution's origin.
         */
        cookiesAllowList?: string[];
        /**
         * Specifies which cookies to forward to the distribution's origin for a cache behavior: all, none, or allow-list to forward only the cookies specified in the cookiesAllowList parameter.
         */
        option?: string;
    }
    /**
     * Describes the request headers that a Lightsail distribution bases caching on.
     */
    interface DistributionHeaderObject {
        /**
         * The specific headers to forward to your distribution's origin.
         */
        headersAllowList?: string[];
        /**
         * The headers that you want your distribution to forward to your origin and base caching on.
         */
        option?: string;
    }
    /**
     * Describes the origin resource of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    interface DistributionInputOrigin {
        /**
         * The name of the origin resource.
         */
        name?: string;
        /**
         * The protocol that your Amazon Lightsail distribution uses when establishing a connection with your origin to pull content.
         */
        protocolPolicy?: string;
        /**
         * The AWS Region name of the origin resource.
         */
        regionName?: string;
    }
    /**
     * Describes the query string parameters that an Amazon Lightsail content delivery network (CDN) distribution to bases caching on.
     */
    interface DistributionQueryStringObject {
        /**
         * Indicates whether the distribution forwards and caches based on query strings.
         */
        option?: boolean;
        /**
         * The specific query strings that the distribution forwards to the origin.
         */
        queryStringsAllowList?: string[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DistributionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * A addon associate with a resource.
     */
    interface InstanceAddOn {
        /**
         * The add-on type
         */
        addOnType: string;
        autoSnapshotAddOnRequest?: outputs.lightsail.InstanceAutoSnapshotAddOn;
        /**
         * Status of the Addon
         */
        status?: enums.lightsail.InstanceAddOnStatus;
    }
    /**
     * An object that represents additional parameters when enabling or modifying the automatic snapshot add-on
     */
    interface InstanceAutoSnapshotAddOn {
        /**
         * The daily time when an automatic snapshot will be created.
         */
        snapshotTimeOfDay?: string;
    }
    /**
     * Disk associated with the Instance.
     */
    interface InstanceDisk {
        /**
         * Instance attached to the disk.
         */
        attachedTo?: string;
        /**
         * Attachment state of the disk.
         */
        attachmentState?: string;
        /**
         * The names to use for your new Lightsail disk.
         */
        diskName: string;
        /**
         * IOPS of disk.
         */
        iOPS?: number;
        /**
         * Is the Attached disk is the system disk of the Instance.
         */
        isSystemDisk?: boolean;
        /**
         * Path of the disk attached to the instance.
         */
        path: string;
        /**
         * Size of the disk attached to the Instance.
         */
        sizeInGb?: string;
    }
    /**
     * Hardware of the Instance.
     */
    interface InstanceHardware {
        /**
         * CPU count of the Instance.
         */
        cpuCount?: number;
        /**
         * Disks attached to the Instance.
         */
        disks?: outputs.lightsail.InstanceDisk[];
        /**
         * RAM Size of the Instance.
         */
        ramSizeInGb?: number;
    }
    /**
     * Location of a resource.
     */
    interface InstanceLocation {
        /**
         * The Availability Zone in which to create your instance. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
         */
        availabilityZone?: string;
        /**
         * The Region Name in which to create your instance.
         */
        regionName?: string;
    }
    /**
     * Monthly Transfer of the Instance.
     */
    interface InstanceMonthlyTransfer {
        /**
         * GbPerMonthAllocated of the Instance.
         */
        gbPerMonthAllocated?: string;
    }
    /**
     * Networking of the Instance.
     */
    interface InstanceNetworking {
        monthlyTransfer?: outputs.lightsail.InstanceMonthlyTransfer;
        /**
         * Ports to the Instance.
         */
        ports: outputs.lightsail.InstancePort[];
    }
    /**
     * Port of the Instance.
     */
    interface InstancePort {
        /**
         * Access Direction for Protocol of the Instance(inbound/outbound).
         */
        accessDirection?: string;
        /**
         * Access From Protocol of the Instance.
         */
        accessFrom?: string;
        /**
         * Access Type Protocol of the Instance.
         */
        accessType?: string;
        cidrListAliases?: string[];
        cidrs?: string[];
        /**
         * CommonName for Protocol of the Instance.
         */
        commonName?: string;
        /**
         * From Port of the Instance.
         */
        fromPort?: number;
        ipv6Cidrs?: string[];
        /**
         * Port Protocol of the Instance.
         */
        protocol?: string;
        /**
         * To Port of the Instance.
         */
        toPort?: number;
    }
    /**
     * Current State of the Instance.
     */
    interface InstanceState {
        /**
         * Status code of the Instance.
         */
        code?: number;
        /**
         * Status code of the Instance.
         */
        name?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface InstanceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LoadBalancerTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
}
export declare namespace location {
    interface MapConfiguration {
        style: string;
    }
    interface PlaceIndexDataSourceConfiguration {
        intendedUse?: enums.location.PlaceIndexIntendedUse;
    }
}
export declare namespace logs {
    /**
     * A key-value pair to associate with a resource.
     */
    interface LogGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., :, /, =, +, - and @.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., :, /, =, +, - and @.
         */
        value: string;
    }
    /**
     * the key-value pairs that further define a metric.
     */
    interface MetricFilterDimension {
        /**
         * The key of the dimension. Maximum length of 255.
         */
        key: string;
        /**
         * The value of the dimension. Maximum length of 255.
         */
        value: string;
    }
    interface MetricFilterMetricTransformation {
        /**
         * The value to emit when a filter pattern does not match a log event. This value can be null.
         */
        defaultValue?: number;
        /**
         * Dimensions are the key-value pairs that further define a metric
         */
        dimensions?: outputs.logs.MetricFilterDimension[];
        /**
         * The name of the CloudWatch metric. Metric name must be in ASCII format.
         */
        metricName: string;
        /**
         * The namespace of the CloudWatch metric.
         */
        metricNamespace: string;
        /**
         * The value to publish to the CloudWatch metric when a filter pattern matches a log event.
         */
        metricValue: string;
        /**
         * The unit to assign to the metric. If you omit this, the unit is set as None.
         */
        unit?: enums.logs.MetricFilterMetricTransformationUnit;
    }
}
export declare namespace lookoutequipment {
    /**
     * Specifies configuration information for the input data for the inference scheduler, including delimiter, format, and dataset location.
     */
    interface DataInputConfigurationProperties {
        inferenceInputNameConfiguration?: outputs.lookoutequipment.InferenceSchedulerInputNameConfiguration;
        /**
         * Indicates the difference between your time zone and Greenwich Mean Time (GMT).
         */
        inputTimeZoneOffset?: string;
        s3InputConfiguration: outputs.lookoutequipment.InferenceSchedulerS3InputConfiguration;
    }
    /**
     * Specifies configuration information for the output results for the inference scheduler, including the S3 location for the output.
     */
    interface DataOutputConfigurationProperties {
        /**
         * The ID number for the AWS KMS key used to encrypt the inference output.
         */
        kmsKeyId?: string;
        s3OutputConfiguration: outputs.lookoutequipment.InferenceSchedulerS3OutputConfiguration;
    }
    /**
     * Specifies configuration information for the input data for the inference, including timestamp format and delimiter.
     */
    interface InferenceSchedulerInputNameConfiguration {
        /**
         * Indicates the delimiter character used between items in the data.
         */
        componentTimestampDelimiter?: string;
        /**
         * The format of the timestamp, whether Epoch time, or standard, with or without hyphens (-).
         */
        timestampFormat?: string;
    }
    /**
     * Specifies configuration information for the input data for the inference, including input data S3 location.
     */
    interface InferenceSchedulerS3InputConfiguration {
        bucket: string;
        prefix?: string;
    }
    /**
     * Specifies configuration information for the output results from the inference, including output S3 location.
     */
    interface InferenceSchedulerS3OutputConfiguration {
        bucket: string;
        prefix?: string;
    }
    /**
     * A tag is a key-value pair that can be added to a resource as metadata.
     */
    interface InferenceSchedulerTag {
        /**
         * The key for the specified tag.
         */
        key: string;
        /**
         * The value for the specified tag.
         */
        value: string;
    }
}
export declare namespace lookoutmetrics {
    interface AlertAction {
        lambdaConfiguration?: outputs.lookoutmetrics.AlertLambdaConfiguration;
        sNSConfiguration?: outputs.lookoutmetrics.AlertSNSConfiguration;
    }
    /**
     * Configuration options for a Lambda alert action.
     */
    interface AlertLambdaConfiguration {
        /**
         * ARN of a Lambda to send alert notifications to.
         */
        lambdaArn: string;
        /**
         * ARN of an IAM role that LookoutMetrics should assume to access the Lambda function.
         */
        roleArn: string;
    }
    /**
     * Configuration options for an SNS alert action.
     */
    interface AlertSNSConfiguration {
        /**
         * ARN of an IAM role that LookoutMetrics should assume to access the SNS topic.
         */
        roleArn: string;
        /**
         * ARN of an SNS topic to send alert notifications to.
         */
        snsTopicArn: string;
    }
    interface AnomalyDetectorAppFlowConfig {
        flowName: string;
        roleArn: string;
    }
    interface AnomalyDetectorCloudwatchConfig {
        roleArn: string;
    }
    interface AnomalyDetectorConfig {
        /**
         * Frequency of anomaly detection
         */
        anomalyDetectorFrequency: enums.lookoutmetrics.AnomalyDetectorFrequency;
    }
    interface AnomalyDetectorCsvFormatDescriptor {
        charset?: string;
        containsHeader?: boolean;
        delimiter?: string;
        fileCompression?: enums.lookoutmetrics.AnomalyDetectorCsvFormatDescriptorFileCompression;
        headerList?: string[];
        quoteSymbol?: string;
    }
    interface AnomalyDetectorFileFormatDescriptor {
        csvFormatDescriptor?: outputs.lookoutmetrics.AnomalyDetectorCsvFormatDescriptor;
        jsonFormatDescriptor?: outputs.lookoutmetrics.AnomalyDetectorJsonFormatDescriptor;
    }
    interface AnomalyDetectorJsonFormatDescriptor {
        charset?: string;
        fileCompression?: enums.lookoutmetrics.AnomalyDetectorJsonFormatDescriptorFileCompression;
    }
    interface AnomalyDetectorMetric {
        /**
         * Operator used to aggregate metric values
         */
        aggregationFunction: enums.lookoutmetrics.AnomalyDetectorMetricAggregationFunction;
        metricName: string;
        namespace?: string;
    }
    interface AnomalyDetectorMetricSet {
        /**
         * Dimensions for this MetricSet.
         */
        dimensionList?: string[];
        /**
         * Metrics captured by this MetricSet.
         */
        metricList: outputs.lookoutmetrics.AnomalyDetectorMetric[];
        /**
         * A description for the MetricSet.
         */
        metricSetDescription?: string;
        /**
         * A frequency period to aggregate the data
         */
        metricSetFrequency?: enums.lookoutmetrics.AnomalyDetectorMetricSetMetricSetFrequency;
        /**
         * The name of the MetricSet.
         */
        metricSetName: string;
        metricSource: outputs.lookoutmetrics.AnomalyDetectorMetricSource;
        /**
         * Offset, in seconds, between the frequency interval and the time at which the metrics are available.
         */
        offset?: number;
        timestampColumn?: outputs.lookoutmetrics.AnomalyDetectorTimestampColumn;
        timezone?: string;
    }
    interface AnomalyDetectorMetricSource {
        appFlowConfig?: outputs.lookoutmetrics.AnomalyDetectorAppFlowConfig;
        cloudwatchConfig?: outputs.lookoutmetrics.AnomalyDetectorCloudwatchConfig;
        rDSSourceConfig?: outputs.lookoutmetrics.AnomalyDetectorRDSSourceConfig;
        redshiftSourceConfig?: outputs.lookoutmetrics.AnomalyDetectorRedshiftSourceConfig;
        s3SourceConfig?: outputs.lookoutmetrics.AnomalyDetectorS3SourceConfig;
    }
    interface AnomalyDetectorRDSSourceConfig {
        dBInstanceIdentifier: string;
        databaseHost: string;
        databaseName: string;
        databasePort: number;
        roleArn: string;
        secretManagerArn: string;
        tableName: string;
        vpcConfiguration: outputs.lookoutmetrics.AnomalyDetectorVpcConfiguration;
    }
    interface AnomalyDetectorRedshiftSourceConfig {
        clusterIdentifier: string;
        databaseHost: string;
        databaseName: string;
        databasePort: number;
        roleArn: string;
        secretManagerArn: string;
        tableName: string;
        vpcConfiguration: outputs.lookoutmetrics.AnomalyDetectorVpcConfiguration;
    }
    interface AnomalyDetectorS3SourceConfig {
        fileFormatDescriptor: outputs.lookoutmetrics.AnomalyDetectorFileFormatDescriptor;
        historicalDataPathList?: string[];
        roleArn: string;
        templatedPathList?: string[];
    }
    interface AnomalyDetectorTimestampColumn {
        /**
         * A timestamp format for the timestamps in the dataset
         */
        columnFormat?: string;
        columnName?: string;
    }
    interface AnomalyDetectorVpcConfiguration {
        securityGroupIdList: string[];
        subnetIdList: string[];
    }
}
export declare namespace m2 {
    interface ApplicationDefinition {
    }
    interface ApplicationTagMap {
    }
    /**
     * Defines the details of a high availability configuration.
     */
    interface EnvironmentHighAvailabilityConfig {
        desiredCapacity: number;
    }
    /**
     * Defines the storage configuration for an environment.
     */
    interface EnvironmentStorageConfiguration {
    }
    /**
     * Defines tags associated to an environment.
     */
    interface EnvironmentTagMap {
    }
}
export declare namespace macie {
    /**
     * The regex or s3 object to use for the AllowList.
     */
    interface AllowListCriteria {
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface AllowListTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }
    /**
     * Map of filter criteria.
     */
    interface FindingsFilterCriterion {
    }
    interface FindingsFilterFindingCriteria {
        criterion?: outputs.macie.FindingsFilterCriterion;
    }
    /**
     * Returned by ListHandler representing filter name and ID.
     */
    interface FindingsFilterListItem {
        id?: string;
        name?: string;
    }
}
export declare namespace managedblockchain {
    interface MemberApprovalThresholdPolicy {
        proposalDurationInHours?: number;
        thresholdComparator?: string;
        thresholdPercentage?: number;
    }
    interface MemberConfiguration {
        description?: string;
        memberFrameworkConfiguration?: outputs.managedblockchain.MemberFrameworkConfiguration;
        name: string;
    }
    interface MemberFabricConfiguration {
        adminPassword: string;
        adminUsername: string;
    }
    interface MemberFrameworkConfiguration {
        memberFabricConfiguration?: outputs.managedblockchain.MemberFabricConfiguration;
    }
    interface MemberNetworkConfiguration {
        description?: string;
        framework: string;
        frameworkVersion: string;
        name: string;
        networkFrameworkConfiguration?: outputs.managedblockchain.MemberNetworkFrameworkConfiguration;
        votingPolicy: outputs.managedblockchain.MemberVotingPolicy;
    }
    interface MemberNetworkFabricConfiguration {
        edition: string;
    }
    interface MemberNetworkFrameworkConfiguration {
        networkFabricConfiguration?: outputs.managedblockchain.MemberNetworkFabricConfiguration;
    }
    interface MemberVotingPolicy {
        approvalThresholdPolicy?: outputs.managedblockchain.MemberApprovalThresholdPolicy;
    }
    interface NodeConfiguration {
        availabilityZone: string;
        instanceType: string;
    }
}
export declare namespace mediaconnect {
    /**
     * Information about the encryption of the flow.
     */
    interface FlowEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm?: enums.mediaconnect.FlowEncryptionAlgorithm;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: string;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: string;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowEncryptionKeyType;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: string;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: string;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: string;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: string;
    }
    /**
     * Information about the encryption of the flow.
     */
    interface FlowEntitlementEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm: enums.mediaconnect.FlowEntitlementEncryptionAlgorithm;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: string;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: string;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowEntitlementEncryptionKeyType;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: string;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: string;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: string;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: string;
    }
    /**
     * The settings for source failover
     */
    interface FlowFailoverConfig {
        /**
         * Search window time to look for dash-7 packets
         */
        recoveryWindow?: number;
        state?: enums.mediaconnect.FlowFailoverConfigState;
    }
    /**
     * Information about the encryption of the flow.
     */
    interface FlowOutputEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm?: enums.mediaconnect.FlowOutputEncryptionAlgorithm;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowOutputEncryptionKeyType;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn: string;
    }
    /**
     * The settings for attaching a VPC interface to an output.
     */
    interface FlowOutputVpcInterfaceAttachment {
        /**
         * The name of the VPC interface to use for this output.
         */
        vpcInterfaceName?: string;
    }
    /**
     * The settings for the source of the flow.
     */
    interface FlowSource {
        /**
         * The type of decryption that is used on the content ingested from this source.
         */
        decryption?: outputs.mediaconnect.FlowEncryption;
        /**
         * A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
         */
        description?: string;
        /**
         * The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
         */
        entitlementArn?: string;
        /**
         * The IP address that the flow will be listening on for incoming content.
         */
        ingestIp?: string;
        /**
         * The port that the flow will be listening on for incoming content.
         */
        ingestPort?: number;
        /**
         * The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
         */
        maxBitrate?: number;
        /**
         * The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
         */
        maxLatency?: number;
        /**
         * The minimum latency in milliseconds.
         */
        minLatency?: number;
        /**
         * The name of the source.
         */
        name?: string;
        /**
         * The protocol that is used by the source or output.
         */
        protocol?: enums.mediaconnect.FlowSourceProtocol;
        /**
         * The ARN of the source.
         */
        sourceArn?: string;
        /**
         * The port that the flow will be listening on for incoming content.(ReadOnly)
         */
        sourceIngestPort?: string;
        /**
         * The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
         */
        streamId?: string;
        /**
         * The name of the VPC Interface this Source is configured with.
         */
        vpcInterfaceName?: string;
        /**
         * The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
         */
        whitelistCidr?: string;
    }
    /**
     * Information about the encryption of the flow.
     */
    interface FlowSourceEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm: enums.mediaconnect.FlowSourceEncryptionAlgorithm;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: string;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: string;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowSourceEncryptionKeyType;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: string;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: string;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: string;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: string;
    }
}
export declare namespace mediaconvert {
    interface JobTemplateAccelerationSettings {
        mode: string;
    }
    interface JobTemplateHopDestination {
        priority?: number;
        queue?: string;
        waitMinutes?: number;
    }
}
export declare namespace medialive {
    interface ChannelAacSettings {
        bitrate?: number;
        codingMode?: string;
        inputType?: string;
        profile?: string;
        rateControlMode?: string;
        rawFormat?: string;
        sampleRate?: number;
        spec?: string;
        vbrQuality?: string;
    }
    interface ChannelAc3Settings {
        bitrate?: number;
        bitstreamMode?: string;
        codingMode?: string;
        dialnorm?: number;
        drcProfile?: string;
        lfeFilter?: string;
        metadataControl?: string;
    }
    interface ChannelAncillarySourceSettings {
        sourceAncillaryChannelNumber?: number;
    }
    interface ChannelArchiveCdnSettings {
        archiveS3Settings?: outputs.medialive.ChannelArchiveS3Settings;
    }
    interface ChannelArchiveContainerSettings {
        m2tsSettings?: outputs.medialive.ChannelM2tsSettings;
        rawSettings?: outputs.medialive.ChannelRawSettings;
    }
    interface ChannelArchiveGroupSettings {
        archiveCdnSettings?: outputs.medialive.ChannelArchiveCdnSettings;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        rolloverInterval?: number;
    }
    interface ChannelArchiveOutputSettings {
        containerSettings?: outputs.medialive.ChannelArchiveContainerSettings;
        extension?: string;
        nameModifier?: string;
    }
    interface ChannelArchiveS3Settings {
        cannedAcl?: string;
    }
    interface ChannelAribDestinationSettings {
    }
    interface ChannelAribSourceSettings {
    }
    interface ChannelAudioChannelMapping {
        inputChannelLevels?: outputs.medialive.ChannelInputChannelLevel[];
        outputChannel?: number;
    }
    interface ChannelAudioCodecSettings {
        aacSettings?: outputs.medialive.ChannelAacSettings;
        ac3Settings?: outputs.medialive.ChannelAc3Settings;
        eac3Settings?: outputs.medialive.ChannelEac3Settings;
        mp2Settings?: outputs.medialive.ChannelMp2Settings;
        passThroughSettings?: outputs.medialive.ChannelPassThroughSettings;
        wavSettings?: outputs.medialive.ChannelWavSettings;
    }
    interface ChannelAudioDescription {
        audioNormalizationSettings?: outputs.medialive.ChannelAudioNormalizationSettings;
        audioSelectorName?: string;
        audioType?: string;
        audioTypeControl?: string;
        audioWatermarkingSettings?: outputs.medialive.ChannelAudioWatermarkSettings;
        codecSettings?: outputs.medialive.ChannelAudioCodecSettings;
        languageCode?: string;
        languageCodeControl?: string;
        name?: string;
        remixSettings?: outputs.medialive.ChannelRemixSettings;
        streamName?: string;
    }
    interface ChannelAudioHlsRenditionSelection {
        groupId?: string;
        name?: string;
    }
    interface ChannelAudioLanguageSelection {
        languageCode?: string;
        languageSelectionPolicy?: string;
    }
    interface ChannelAudioNormalizationSettings {
        algorithm?: string;
        algorithmControl?: string;
        targetLkfs?: number;
    }
    interface ChannelAudioOnlyHlsSettings {
        audioGroupId?: string;
        audioOnlyImage?: outputs.medialive.ChannelInputLocation;
        audioTrackType?: string;
        segmentType?: string;
    }
    interface ChannelAudioPidSelection {
        pid?: number;
    }
    interface ChannelAudioSelector {
        name?: string;
        selectorSettings?: outputs.medialive.ChannelAudioSelectorSettings;
    }
    interface ChannelAudioSelectorSettings {
        audioHlsRenditionSelection?: outputs.medialive.ChannelAudioHlsRenditionSelection;
        audioLanguageSelection?: outputs.medialive.ChannelAudioLanguageSelection;
        audioPidSelection?: outputs.medialive.ChannelAudioPidSelection;
        audioTrackSelection?: outputs.medialive.ChannelAudioTrackSelection;
    }
    interface ChannelAudioSilenceFailoverSettings {
        audioSelectorName?: string;
        audioSilenceThresholdMsec?: number;
    }
    interface ChannelAudioTrack {
        track?: number;
    }
    interface ChannelAudioTrackSelection {
        tracks?: outputs.medialive.ChannelAudioTrack[];
    }
    interface ChannelAudioWatermarkSettings {
        nielsenWatermarksSettings?: outputs.medialive.ChannelNielsenWatermarksSettings;
    }
    interface ChannelAutomaticInputFailoverSettings {
        errorClearTimeMsec?: number;
        failoverConditions?: outputs.medialive.ChannelFailoverCondition[];
        inputPreference?: string;
        secondaryInputId?: string;
    }
    interface ChannelAvailBlanking {
        availBlankingImage?: outputs.medialive.ChannelInputLocation;
        state?: string;
    }
    interface ChannelAvailConfiguration {
        availSettings?: outputs.medialive.ChannelAvailSettings;
    }
    interface ChannelAvailSettings {
        scte35SpliceInsert?: outputs.medialive.ChannelScte35SpliceInsert;
        scte35TimeSignalApos?: outputs.medialive.ChannelScte35TimeSignalApos;
    }
    interface ChannelBlackoutSlate {
        blackoutSlateImage?: outputs.medialive.ChannelInputLocation;
        networkEndBlackout?: string;
        networkEndBlackoutImage?: outputs.medialive.ChannelInputLocation;
        networkId?: string;
        state?: string;
    }
    interface ChannelBurnInDestinationSettings {
        alignment?: string;
        backgroundColor?: string;
        backgroundOpacity?: number;
        font?: outputs.medialive.ChannelInputLocation;
        fontColor?: string;
        fontOpacity?: number;
        fontResolution?: number;
        fontSize?: string;
        outlineColor?: string;
        outlineSize?: number;
        shadowColor?: string;
        shadowOpacity?: number;
        shadowXOffset?: number;
        shadowYOffset?: number;
        teletextGridControl?: string;
        xPosition?: number;
        yPosition?: number;
    }
    interface ChannelCaptionDescription {
        captionSelectorName?: string;
        destinationSettings?: outputs.medialive.ChannelCaptionDestinationSettings;
        languageCode?: string;
        languageDescription?: string;
        name?: string;
    }
    interface ChannelCaptionDestinationSettings {
        aribDestinationSettings?: outputs.medialive.ChannelAribDestinationSettings;
        burnInDestinationSettings?: outputs.medialive.ChannelBurnInDestinationSettings;
        dvbSubDestinationSettings?: outputs.medialive.ChannelDvbSubDestinationSettings;
        ebuTtDDestinationSettings?: outputs.medialive.ChannelEbuTtDDestinationSettings;
        embeddedDestinationSettings?: outputs.medialive.ChannelEmbeddedDestinationSettings;
        embeddedPlusScte20DestinationSettings?: outputs.medialive.ChannelEmbeddedPlusScte20DestinationSettings;
        rtmpCaptionInfoDestinationSettings?: outputs.medialive.ChannelRtmpCaptionInfoDestinationSettings;
        scte20PlusEmbeddedDestinationSettings?: outputs.medialive.ChannelScte20PlusEmbeddedDestinationSettings;
        scte27DestinationSettings?: outputs.medialive.ChannelScte27DestinationSettings;
        smpteTtDestinationSettings?: outputs.medialive.ChannelSmpteTtDestinationSettings;
        teletextDestinationSettings?: outputs.medialive.ChannelTeletextDestinationSettings;
        ttmlDestinationSettings?: outputs.medialive.ChannelTtmlDestinationSettings;
        webvttDestinationSettings?: outputs.medialive.ChannelWebvttDestinationSettings;
    }
    interface ChannelCaptionLanguageMapping {
        captionChannel?: number;
        languageCode?: string;
        languageDescription?: string;
    }
    interface ChannelCaptionRectangle {
        height?: number;
        leftOffset?: number;
        topOffset?: number;
        width?: number;
    }
    interface ChannelCaptionSelector {
        languageCode?: string;
        name?: string;
        selectorSettings?: outputs.medialive.ChannelCaptionSelectorSettings;
    }
    interface ChannelCaptionSelectorSettings {
        ancillarySourceSettings?: outputs.medialive.ChannelAncillarySourceSettings;
        aribSourceSettings?: outputs.medialive.ChannelAribSourceSettings;
        dvbSubSourceSettings?: outputs.medialive.ChannelDvbSubSourceSettings;
        embeddedSourceSettings?: outputs.medialive.ChannelEmbeddedSourceSettings;
        scte20SourceSettings?: outputs.medialive.ChannelScte20SourceSettings;
        scte27SourceSettings?: outputs.medialive.ChannelScte27SourceSettings;
        teletextSourceSettings?: outputs.medialive.ChannelTeletextSourceSettings;
    }
    interface ChannelCdiInputSpecification {
        resolution?: string;
    }
    interface ChannelColorSpacePassthroughSettings {
    }
    interface ChannelDvbNitSettings {
        networkId?: number;
        networkName?: string;
        repInterval?: number;
    }
    interface ChannelDvbSdtSettings {
        outputSdt?: string;
        repInterval?: number;
        serviceName?: string;
        serviceProviderName?: string;
    }
    interface ChannelDvbSubDestinationSettings {
        alignment?: string;
        backgroundColor?: string;
        backgroundOpacity?: number;
        font?: outputs.medialive.ChannelInputLocation;
        fontColor?: string;
        fontOpacity?: number;
        fontResolution?: number;
        fontSize?: string;
        outlineColor?: string;
        outlineSize?: number;
        shadowColor?: string;
        shadowOpacity?: number;
        shadowXOffset?: number;
        shadowYOffset?: number;
        teletextGridControl?: string;
        xPosition?: number;
        yPosition?: number;
    }
    interface ChannelDvbSubSourceSettings {
        ocrLanguage?: string;
        pid?: number;
    }
    interface ChannelDvbTdtSettings {
        repInterval?: number;
    }
    interface ChannelEac3Settings {
        attenuationControl?: string;
        bitrate?: number;
        bitstreamMode?: string;
        codingMode?: string;
        dcFilter?: string;
        dialnorm?: number;
        drcLine?: string;
        drcRf?: string;
        lfeControl?: string;
        lfeFilter?: string;
        loRoCenterMixLevel?: number;
        loRoSurroundMixLevel?: number;
        ltRtCenterMixLevel?: number;
        ltRtSurroundMixLevel?: number;
        metadataControl?: string;
        passthroughControl?: string;
        phaseControl?: string;
        stereoDownmix?: string;
        surroundExMode?: string;
        surroundMode?: string;
    }
    interface ChannelEbuTtDDestinationSettings {
        copyrightHolder?: string;
        fillLineGap?: string;
        fontFamily?: string;
        styleControl?: string;
    }
    interface ChannelEmbeddedDestinationSettings {
    }
    interface ChannelEmbeddedPlusScte20DestinationSettings {
    }
    interface ChannelEmbeddedSourceSettings {
        convert608To708?: string;
        scte20Detection?: string;
        source608ChannelNumber?: number;
        source608TrackNumber?: number;
    }
    interface ChannelEncoderSettings {
        audioDescriptions?: outputs.medialive.ChannelAudioDescription[];
        availBlanking?: outputs.medialive.ChannelAvailBlanking;
        availConfiguration?: outputs.medialive.ChannelAvailConfiguration;
        blackoutSlate?: outputs.medialive.ChannelBlackoutSlate;
        captionDescriptions?: outputs.medialive.ChannelCaptionDescription[];
        featureActivations?: outputs.medialive.ChannelFeatureActivations;
        globalConfiguration?: outputs.medialive.ChannelGlobalConfiguration;
        motionGraphicsConfiguration?: outputs.medialive.ChannelMotionGraphicsConfiguration;
        nielsenConfiguration?: outputs.medialive.ChannelNielsenConfiguration;
        outputGroups?: outputs.medialive.ChannelOutputGroup[];
        timecodeConfig?: outputs.medialive.ChannelTimecodeConfig;
        videoDescriptions?: outputs.medialive.ChannelVideoDescription[];
    }
    interface ChannelFailoverCondition {
        failoverConditionSettings?: outputs.medialive.ChannelFailoverConditionSettings;
    }
    interface ChannelFailoverConditionSettings {
        audioSilenceSettings?: outputs.medialive.ChannelAudioSilenceFailoverSettings;
        inputLossSettings?: outputs.medialive.ChannelInputLossFailoverSettings;
        videoBlackSettings?: outputs.medialive.ChannelVideoBlackFailoverSettings;
    }
    interface ChannelFeatureActivations {
        inputPrepareScheduleActions?: string;
    }
    interface ChannelFecOutputSettings {
        columnDepth?: number;
        includeFec?: string;
        rowLength?: number;
    }
    interface ChannelFmp4HlsSettings {
        audioRenditionSets?: string;
        nielsenId3Behavior?: string;
        timedMetadataBehavior?: string;
    }
    interface ChannelFrameCaptureCdnSettings {
        frameCaptureS3Settings?: outputs.medialive.ChannelFrameCaptureS3Settings;
    }
    interface ChannelFrameCaptureGroupSettings {
        destination?: outputs.medialive.ChannelOutputLocationRef;
        frameCaptureCdnSettings?: outputs.medialive.ChannelFrameCaptureCdnSettings;
    }
    interface ChannelFrameCaptureHlsSettings {
    }
    interface ChannelFrameCaptureOutputSettings {
        nameModifier?: string;
    }
    interface ChannelFrameCaptureS3Settings {
        cannedAcl?: string;
    }
    interface ChannelFrameCaptureSettings {
        captureInterval?: number;
        captureIntervalUnits?: string;
    }
    interface ChannelGlobalConfiguration {
        initialAudioGain?: number;
        inputEndAction?: string;
        inputLossBehavior?: outputs.medialive.ChannelInputLossBehavior;
        outputLockingMode?: string;
        outputTimingSource?: string;
        supportLowFramerateInputs?: string;
    }
    interface ChannelH264ColorSpaceSettings {
        colorSpacePassthroughSettings?: outputs.medialive.ChannelColorSpacePassthroughSettings;
        rec601Settings?: outputs.medialive.ChannelRec601Settings;
        rec709Settings?: outputs.medialive.ChannelRec709Settings;
    }
    interface ChannelH264FilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelTemporalFilterSettings;
    }
    interface ChannelH264Settings {
        adaptiveQuantization?: string;
        afdSignaling?: string;
        bitrate?: number;
        bufFillPct?: number;
        bufSize?: number;
        colorMetadata?: string;
        colorSpaceSettings?: outputs.medialive.ChannelH264ColorSpaceSettings;
        entropyEncoding?: string;
        filterSettings?: outputs.medialive.ChannelH264FilterSettings;
        fixedAfd?: string;
        flickerAq?: string;
        forceFieldPictures?: string;
        framerateControl?: string;
        framerateDenominator?: number;
        framerateNumerator?: number;
        gopBReference?: string;
        gopClosedCadence?: number;
        gopNumBFrames?: number;
        gopSize?: number;
        gopSizeUnits?: string;
        level?: string;
        lookAheadRateControl?: string;
        maxBitrate?: number;
        minIInterval?: number;
        numRefFrames?: number;
        parControl?: string;
        parDenominator?: number;
        parNumerator?: number;
        profile?: string;
        qualityLevel?: string;
        qvbrQualityLevel?: number;
        rateControlMode?: string;
        scanType?: string;
        sceneChangeDetect?: string;
        slices?: number;
        softness?: number;
        spatialAq?: string;
        subgopLength?: string;
        syntax?: string;
        temporalAq?: string;
        timecodeInsertion?: string;
    }
    interface ChannelH265ColorSpaceSettings {
        colorSpacePassthroughSettings?: outputs.medialive.ChannelColorSpacePassthroughSettings;
        hdr10Settings?: outputs.medialive.ChannelHdr10Settings;
        rec601Settings?: outputs.medialive.ChannelRec601Settings;
        rec709Settings?: outputs.medialive.ChannelRec709Settings;
    }
    interface ChannelH265FilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelTemporalFilterSettings;
    }
    interface ChannelH265Settings {
        adaptiveQuantization?: string;
        afdSignaling?: string;
        alternativeTransferFunction?: string;
        bitrate?: number;
        bufSize?: number;
        colorMetadata?: string;
        colorSpaceSettings?: outputs.medialive.ChannelH265ColorSpaceSettings;
        filterSettings?: outputs.medialive.ChannelH265FilterSettings;
        fixedAfd?: string;
        flickerAq?: string;
        framerateDenominator?: number;
        framerateNumerator?: number;
        gopClosedCadence?: number;
        gopSize?: number;
        gopSizeUnits?: string;
        level?: string;
        lookAheadRateControl?: string;
        maxBitrate?: number;
        minIInterval?: number;
        parDenominator?: number;
        parNumerator?: number;
        profile?: string;
        qvbrQualityLevel?: number;
        rateControlMode?: string;
        scanType?: string;
        sceneChangeDetect?: string;
        slices?: number;
        tier?: string;
        timecodeInsertion?: string;
    }
    interface ChannelHdr10Settings {
        maxCll?: number;
        maxFall?: number;
    }
    interface ChannelHlsAkamaiSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode?: string;
        numRetries?: number;
        restartDelay?: number;
        salt?: string;
        token?: string;
    }
    interface ChannelHlsBasicPutSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        numRetries?: number;
        restartDelay?: number;
    }
    interface ChannelHlsCdnSettings {
        hlsAkamaiSettings?: outputs.medialive.ChannelHlsAkamaiSettings;
        hlsBasicPutSettings?: outputs.medialive.ChannelHlsBasicPutSettings;
        hlsMediaStoreSettings?: outputs.medialive.ChannelHlsMediaStoreSettings;
        hlsS3Settings?: outputs.medialive.ChannelHlsS3Settings;
        hlsWebdavSettings?: outputs.medialive.ChannelHlsWebdavSettings;
    }
    interface ChannelHlsGroupSettings {
        adMarkers?: string[];
        baseUrlContent?: string;
        baseUrlContent1?: string;
        baseUrlManifest?: string;
        baseUrlManifest1?: string;
        captionLanguageMappings?: outputs.medialive.ChannelCaptionLanguageMapping[];
        captionLanguageSetting?: string;
        clientCache?: string;
        codecSpecification?: string;
        constantIv?: string;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        directoryStructure?: string;
        discontinuityTags?: string;
        encryptionType?: string;
        hlsCdnSettings?: outputs.medialive.ChannelHlsCdnSettings;
        hlsId3SegmentTagging?: string;
        iFrameOnlyPlaylists?: string;
        incompleteSegmentBehavior?: string;
        indexNSegments?: number;
        inputLossAction?: string;
        ivInManifest?: string;
        ivSource?: string;
        keepSegments?: number;
        keyFormat?: string;
        keyFormatVersions?: string;
        keyProviderSettings?: outputs.medialive.ChannelKeyProviderSettings;
        manifestCompression?: string;
        manifestDurationFormat?: string;
        minSegmentLength?: number;
        mode?: string;
        outputSelection?: string;
        programDateTime?: string;
        programDateTimeClock?: string;
        programDateTimePeriod?: number;
        redundantManifest?: string;
        segmentLength?: number;
        segmentationMode?: string;
        segmentsPerSubdirectory?: number;
        streamInfResolution?: string;
        timedMetadataId3Frame?: string;
        timedMetadataId3Period?: number;
        timestampDeltaMilliseconds?: number;
        tsFileMode?: string;
    }
    interface ChannelHlsInputSettings {
        bandwidth?: number;
        bufferSegments?: number;
        retries?: number;
        retryInterval?: number;
        scte35Source?: string;
    }
    interface ChannelHlsMediaStoreSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        mediaStoreStorageClass?: string;
        numRetries?: number;
        restartDelay?: number;
    }
    interface ChannelHlsOutputSettings {
        h265PackagingType?: string;
        hlsSettings?: outputs.medialive.ChannelHlsSettings;
        nameModifier?: string;
        segmentModifier?: string;
    }
    interface ChannelHlsS3Settings {
        cannedAcl?: string;
    }
    interface ChannelHlsSettings {
        audioOnlyHlsSettings?: outputs.medialive.ChannelAudioOnlyHlsSettings;
        fmp4HlsSettings?: outputs.medialive.ChannelFmp4HlsSettings;
        frameCaptureHlsSettings?: outputs.medialive.ChannelFrameCaptureHlsSettings;
        standardHlsSettings?: outputs.medialive.ChannelStandardHlsSettings;
    }
    interface ChannelHlsWebdavSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode?: string;
        numRetries?: number;
        restartDelay?: number;
    }
    interface ChannelHtmlMotionGraphicsSettings {
    }
    interface ChannelInputAttachment {
        automaticInputFailoverSettings?: outputs.medialive.ChannelAutomaticInputFailoverSettings;
        inputAttachmentName?: string;
        inputId?: string;
        inputSettings?: outputs.medialive.ChannelInputSettings;
    }
    interface ChannelInputChannelLevel {
        gain?: number;
        inputChannel?: number;
    }
    interface ChannelInputLocation {
        passwordParam?: string;
        uri?: string;
        username?: string;
    }
    interface ChannelInputLossBehavior {
        blackFrameMsec?: number;
        inputLossImageColor?: string;
        inputLossImageSlate?: outputs.medialive.ChannelInputLocation;
        inputLossImageType?: string;
        repeatFrameMsec?: number;
    }
    interface ChannelInputLossFailoverSettings {
        inputLossThresholdMsec?: number;
    }
    interface ChannelInputSettings {
        audioSelectors?: outputs.medialive.ChannelAudioSelector[];
        captionSelectors?: outputs.medialive.ChannelCaptionSelector[];
        deblockFilter?: string;
        denoiseFilter?: string;
        filterStrength?: number;
        inputFilter?: string;
        networkInputSettings?: outputs.medialive.ChannelNetworkInputSettings;
        scte35Pid?: number;
        smpte2038DataPreference?: string;
        sourceEndBehavior?: string;
        videoSelector?: outputs.medialive.ChannelVideoSelector;
    }
    interface ChannelInputSpecification {
        codec?: string;
        maximumBitrate?: string;
        resolution?: string;
    }
    interface ChannelKeyProviderSettings {
        staticKeySettings?: outputs.medialive.ChannelStaticKeySettings;
    }
    interface ChannelM2tsSettings {
        absentInputAudioBehavior?: string;
        arib?: string;
        aribCaptionsPid?: string;
        aribCaptionsPidControl?: string;
        audioBufferModel?: string;
        audioFramesPerPes?: number;
        audioPids?: string;
        audioStreamType?: string;
        bitrate?: number;
        bufferModel?: string;
        ccDescriptor?: string;
        dvbNitSettings?: outputs.medialive.ChannelDvbNitSettings;
        dvbSdtSettings?: outputs.medialive.ChannelDvbSdtSettings;
        dvbSubPids?: string;
        dvbTdtSettings?: outputs.medialive.ChannelDvbTdtSettings;
        dvbTeletextPid?: string;
        ebif?: string;
        ebpAudioInterval?: string;
        ebpLookaheadMs?: number;
        ebpPlacement?: string;
        ecmPid?: string;
        esRateInPes?: string;
        etvPlatformPid?: string;
        etvSignalPid?: string;
        fragmentTime?: number;
        klv?: string;
        klvDataPids?: string;
        nielsenId3Behavior?: string;
        nullPacketBitrate?: number;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid?: string;
        programNum?: number;
        rateMode?: string;
        scte27Pids?: string;
        scte35Control?: string;
        scte35Pid?: string;
        segmentationMarkers?: string;
        segmentationStyle?: string;
        segmentationTime?: number;
        timedMetadataBehavior?: string;
        timedMetadataPid?: string;
        transportStreamId?: number;
        videoPid?: string;
    }
    interface ChannelM3u8Settings {
        audioFramesPerPes?: number;
        audioPids?: string;
        ecmPid?: string;
        nielsenId3Behavior?: string;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid?: string;
        programNum?: number;
        scte35Behavior?: string;
        scte35Pid?: string;
        timedMetadataBehavior?: string;
        timedMetadataPid?: string;
        transportStreamId?: number;
        videoPid?: string;
    }
    interface ChannelMediaPackageGroupSettings {
        destination?: outputs.medialive.ChannelOutputLocationRef;
    }
    interface ChannelMediaPackageOutputDestinationSettings {
        channelId?: string;
    }
    interface ChannelMediaPackageOutputSettings {
    }
    interface ChannelMotionGraphicsConfiguration {
        motionGraphicsInsertion?: string;
        motionGraphicsSettings?: outputs.medialive.ChannelMotionGraphicsSettings;
    }
    interface ChannelMotionGraphicsSettings {
        htmlMotionGraphicsSettings?: outputs.medialive.ChannelHtmlMotionGraphicsSettings;
    }
    interface ChannelMp2Settings {
        bitrate?: number;
        codingMode?: string;
        sampleRate?: number;
    }
    interface ChannelMpeg2FilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelTemporalFilterSettings;
    }
    interface ChannelMpeg2Settings {
        adaptiveQuantization?: string;
        afdSignaling?: string;
        colorMetadata?: string;
        colorSpace?: string;
        displayAspectRatio?: string;
        filterSettings?: outputs.medialive.ChannelMpeg2FilterSettings;
        fixedAfd?: string;
        framerateDenominator?: number;
        framerateNumerator?: number;
        gopClosedCadence?: number;
        gopNumBFrames?: number;
        gopSize?: number;
        gopSizeUnits?: string;
        scanType?: string;
        subgopLength?: string;
        timecodeInsertion?: string;
    }
    interface ChannelMsSmoothGroupSettings {
        acquisitionPointId?: string;
        audioOnlyTimecodeControl?: string;
        certificateMode?: string;
        connectionRetryInterval?: number;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        eventId?: string;
        eventIdMode?: string;
        eventStopBehavior?: string;
        filecacheDuration?: number;
        fragmentLength?: number;
        inputLossAction?: string;
        numRetries?: number;
        restartDelay?: number;
        segmentationMode?: string;
        sendDelayMs?: number;
        sparseTrackType?: string;
        streamManifestBehavior?: string;
        timestampOffset?: string;
        timestampOffsetMode?: string;
    }
    interface ChannelMsSmoothOutputSettings {
        h265PackagingType?: string;
        nameModifier?: string;
    }
    interface ChannelMultiplexGroupSettings {
    }
    interface ChannelMultiplexOutputSettings {
        destination?: outputs.medialive.ChannelOutputLocationRef;
    }
    interface ChannelMultiplexProgramChannelDestinationSettings {
        multiplexId?: string;
        programName?: string;
    }
    interface ChannelNetworkInputSettings {
        hlsInputSettings?: outputs.medialive.ChannelHlsInputSettings;
        serverValidation?: string;
    }
    interface ChannelNielsenCBET {
        cbetCheckDigitString?: string;
        cbetStepaside?: string;
        csid?: string;
    }
    interface ChannelNielsenConfiguration {
        distributorId?: string;
        nielsenPcmToId3Tagging?: string;
    }
    interface ChannelNielsenNaesIiNw {
        checkDigitString?: string;
        sid?: number;
    }
    interface ChannelNielsenWatermarksSettings {
        nielsenCbetSettings?: outputs.medialive.ChannelNielsenCBET;
        nielsenDistributionType?: string;
        nielsenNaesIiNwSettings?: outputs.medialive.ChannelNielsenNaesIiNw;
    }
    interface ChannelOutput {
        audioDescriptionNames?: string[];
        captionDescriptionNames?: string[];
        outputName?: string;
        outputSettings?: outputs.medialive.ChannelOutputSettings;
        videoDescriptionName?: string;
    }
    interface ChannelOutputDestination {
        id?: string;
        mediaPackageSettings?: outputs.medialive.ChannelMediaPackageOutputDestinationSettings[];
        multiplexSettings?: outputs.medialive.ChannelMultiplexProgramChannelDestinationSettings;
        settings?: outputs.medialive.ChannelOutputDestinationSettings[];
    }
    interface ChannelOutputDestinationSettings {
        passwordParam?: string;
        streamName?: string;
        url?: string;
        username?: string;
    }
    interface ChannelOutputGroup {
        name?: string;
        outputGroupSettings?: outputs.medialive.ChannelOutputGroupSettings;
        outputs?: outputs.medialive.ChannelOutput[];
    }
    interface ChannelOutputGroupSettings {
        archiveGroupSettings?: outputs.medialive.ChannelArchiveGroupSettings;
        frameCaptureGroupSettings?: outputs.medialive.ChannelFrameCaptureGroupSettings;
        hlsGroupSettings?: outputs.medialive.ChannelHlsGroupSettings;
        mediaPackageGroupSettings?: outputs.medialive.ChannelMediaPackageGroupSettings;
        msSmoothGroupSettings?: outputs.medialive.ChannelMsSmoothGroupSettings;
        multiplexGroupSettings?: outputs.medialive.ChannelMultiplexGroupSettings;
        rtmpGroupSettings?: outputs.medialive.ChannelRtmpGroupSettings;
        udpGroupSettings?: outputs.medialive.ChannelUdpGroupSettings;
    }
    interface ChannelOutputLocationRef {
        destinationRefId?: string;
    }
    interface ChannelOutputSettings {
        archiveOutputSettings?: outputs.medialive.ChannelArchiveOutputSettings;
        frameCaptureOutputSettings?: outputs.medialive.ChannelFrameCaptureOutputSettings;
        hlsOutputSettings?: outputs.medialive.ChannelHlsOutputSettings;
        mediaPackageOutputSettings?: outputs.medialive.ChannelMediaPackageOutputSettings;
        msSmoothOutputSettings?: outputs.medialive.ChannelMsSmoothOutputSettings;
        multiplexOutputSettings?: outputs.medialive.ChannelMultiplexOutputSettings;
        rtmpOutputSettings?: outputs.medialive.ChannelRtmpOutputSettings;
        udpOutputSettings?: outputs.medialive.ChannelUdpOutputSettings;
    }
    interface ChannelPassThroughSettings {
    }
    interface ChannelRawSettings {
    }
    interface ChannelRec601Settings {
    }
    interface ChannelRec709Settings {
    }
    interface ChannelRemixSettings {
        channelMappings?: outputs.medialive.ChannelAudioChannelMapping[];
        channelsIn?: number;
        channelsOut?: number;
    }
    interface ChannelRtmpCaptionInfoDestinationSettings {
    }
    interface ChannelRtmpGroupSettings {
        adMarkers?: string[];
        authenticationScheme?: string;
        cacheFullBehavior?: string;
        cacheLength?: number;
        captionData?: string;
        inputLossAction?: string;
        restartDelay?: number;
    }
    interface ChannelRtmpOutputSettings {
        certificateMode?: string;
        connectionRetryInterval?: number;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        numRetries?: number;
    }
    interface ChannelScte20PlusEmbeddedDestinationSettings {
    }
    interface ChannelScte20SourceSettings {
        convert608To708?: string;
        source608ChannelNumber?: number;
    }
    interface ChannelScte27DestinationSettings {
    }
    interface ChannelScte27SourceSettings {
        ocrLanguage?: string;
        pid?: number;
    }
    interface ChannelScte35SpliceInsert {
        adAvailOffset?: number;
        noRegionalBlackoutFlag?: string;
        webDeliveryAllowedFlag?: string;
    }
    interface ChannelScte35TimeSignalApos {
        adAvailOffset?: number;
        noRegionalBlackoutFlag?: string;
        webDeliveryAllowedFlag?: string;
    }
    interface ChannelSmpteTtDestinationSettings {
    }
    interface ChannelStandardHlsSettings {
        audioRenditionSets?: string;
        m3u8Settings?: outputs.medialive.ChannelM3u8Settings;
    }
    interface ChannelStaticKeySettings {
        keyProviderServer?: outputs.medialive.ChannelInputLocation;
        staticKeyValue?: string;
    }
    interface ChannelTeletextDestinationSettings {
    }
    interface ChannelTeletextSourceSettings {
        outputRectangle?: outputs.medialive.ChannelCaptionRectangle;
        pageNumber?: string;
    }
    interface ChannelTemporalFilterSettings {
        postFilterSharpening?: string;
        strength?: string;
    }
    interface ChannelTimecodeConfig {
        source?: string;
        syncThreshold?: number;
    }
    interface ChannelTtmlDestinationSettings {
        styleControl?: string;
    }
    interface ChannelUdpContainerSettings {
        m2tsSettings?: outputs.medialive.ChannelM2tsSettings;
    }
    interface ChannelUdpGroupSettings {
        inputLossAction?: string;
        timedMetadataId3Frame?: string;
        timedMetadataId3Period?: number;
    }
    interface ChannelUdpOutputSettings {
        bufferMsec?: number;
        containerSettings?: outputs.medialive.ChannelUdpContainerSettings;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        fecOutputSettings?: outputs.medialive.ChannelFecOutputSettings;
    }
    interface ChannelVideoBlackFailoverSettings {
        blackDetectThreshold?: number;
        videoBlackThresholdMsec?: number;
    }
    interface ChannelVideoCodecSettings {
        frameCaptureSettings?: outputs.medialive.ChannelFrameCaptureSettings;
        h264Settings?: outputs.medialive.ChannelH264Settings;
        h265Settings?: outputs.medialive.ChannelH265Settings;
        mpeg2Settings?: outputs.medialive.ChannelMpeg2Settings;
    }
    interface ChannelVideoDescription {
        codecSettings?: outputs.medialive.ChannelVideoCodecSettings;
        height?: number;
        name?: string;
        respondToAfd?: string;
        scalingBehavior?: string;
        sharpness?: number;
        width?: number;
    }
    interface ChannelVideoSelector {
        colorSpace?: string;
        colorSpaceSettings?: outputs.medialive.ChannelVideoSelectorColorSpaceSettings;
        colorSpaceUsage?: string;
        selectorSettings?: outputs.medialive.ChannelVideoSelectorSettings;
    }
    interface ChannelVideoSelectorColorSpaceSettings {
        hdr10Settings?: outputs.medialive.ChannelHdr10Settings;
    }
    interface ChannelVideoSelectorPid {
        pid?: number;
    }
    interface ChannelVideoSelectorProgramId {
        programId?: number;
    }
    interface ChannelVideoSelectorSettings {
        videoSelectorPid?: outputs.medialive.ChannelVideoSelectorPid;
        videoSelectorProgramId?: outputs.medialive.ChannelVideoSelectorProgramId;
    }
    interface ChannelVpcOutputSettings {
        publicAddressAllocationIds?: string[];
        securityGroupIds?: string[];
        subnetIds?: string[];
    }
    interface ChannelWavSettings {
        bitDepth?: number;
        codingMode?: string;
        sampleRate?: number;
    }
    interface ChannelWebvttDestinationSettings {
        styleControl?: string;
    }
    interface InputDestinationRequest {
        streamName?: string;
    }
    interface InputDeviceSettings {
        id?: string;
    }
    interface InputMediaConnectFlowRequest {
        flowArn?: string;
    }
    interface InputSecurityGroupInputWhitelistRuleCidr {
        cidr?: string;
    }
    interface InputSourceRequest {
        passwordParam?: string;
        url?: string;
        username?: string;
    }
    interface InputVpcRequest {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }
}
export declare namespace mediapackage {
    /**
     * The endpoint URL used to access an Asset using one PackagingConfiguration.
     */
    interface AssetEgressEndpoint {
        /**
         * The ID of the PackagingConfiguration being applied to the Asset.
         */
        packagingConfigurationId: string;
        /**
         * The URL of the parent manifest for the repackaged Asset.
         */
        url: string;
    }
    interface AssetTag {
        key: string;
        value: string;
    }
    /**
     * An HTTP Live Streaming (HLS) ingest resource configuration.
     */
    interface ChannelHlsIngest {
        /**
         * A list of endpoints to which the source stream should be sent.
         */
        ingestEndpoints?: outputs.mediapackage.ChannelIngestEndpoint[];
    }
    /**
     * An endpoint for ingesting source content for a Channel.
     */
    interface ChannelIngestEndpoint {
        /**
         * The system generated unique identifier for the IngestEndpoint
         */
        id?: string;
        /**
         * The system generated password for ingest authentication.
         */
        password?: string;
        /**
         * The ingest URL to which the source stream should be sent.
         */
        url?: string;
        /**
         * The system generated username for ingest authentication.
         */
        username?: string;
    }
    interface ChannelLogConfiguration {
        /**
         * Sets a custom AWS CloudWatch log group name for access logs. If a log group name isn't specified, the defaults are used: /aws/MediaPackage/EgressAccessLogs for egress access logs and /aws/MediaPackage/IngressAccessLogs for ingress access logs.
         */
        logGroupName?: string;
    }
    interface ChannelTag {
        key: string;
        value: string;
    }
    /**
     * CDN Authorization credentials
     */
    interface OriginEndpointAuthorization {
        /**
         * The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
         */
        cdnIdentifierSecret: string;
        /**
         * The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
         */
        secretsRoleArn: string;
    }
    /**
     * A Common Media Application Format (CMAF) encryption configuration.
     */
    interface OriginEndpointCmafEncryption {
        /**
         * An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
         */
        constantInitializationVector?: string;
        /**
         * The encryption method used
         */
        encryptionMethod?: enums.mediapackage.OriginEndpointCmafEncryptionEncryptionMethod;
        /**
         * Time (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: number;
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }
    /**
     * A Common Media Application Format (CMAF) packaging configuration.
     */
    interface OriginEndpointCmafPackage {
        encryption?: outputs.mediapackage.OriginEndpointCmafEncryption;
        /**
         * A list of HLS manifest configurations
         */
        hlsManifests?: outputs.mediapackage.OriginEndpointHlsManifest[];
        /**
         * Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
         */
        segmentDurationSeconds?: number;
        /**
         * An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
         */
        segmentPrefix?: string;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
    }
    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
     */
    interface OriginEndpointDashEncryption {
        /**
         * Time (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: number;
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }
    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
     */
    interface OriginEndpointDashPackage {
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: enums.mediapackage.OriginEndpointDashPackageAdTriggersItem[];
        adsOnDeliveryRestrictions?: enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions;
        encryption?: outputs.mediapackage.OriginEndpointDashEncryption;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: boolean;
        /**
         * Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
         */
        manifestLayout?: enums.mediapackage.OriginEndpointDashPackageManifestLayout;
        /**
         * Time window (in seconds) contained in each manifest.
         */
        manifestWindowSeconds?: number;
        /**
         * Minimum duration (in seconds) that a player will buffer media before starting the presentation.
         */
        minBufferTimeSeconds?: number;
        /**
         * Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
         */
        minUpdatePeriodSeconds?: number;
        /**
         * A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Channel source contains SCTE-35 ad markers.
         */
        periodTriggers?: enums.mediapackage.OriginEndpointDashPackagePeriodTriggersItem[];
        /**
         * The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
         */
        profile?: enums.mediapackage.OriginEndpointDashPackageProfile;
        /**
         * Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
         */
        segmentDurationSeconds?: number;
        /**
         * Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
         */
        segmentTemplateFormat?: enums.mediapackage.OriginEndpointDashPackageSegmentTemplateFormat;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
        /**
         * Duration (in seconds) to delay live content before presentation.
         */
        suggestedPresentationDelaySeconds?: number;
        /**
         * Determines the type of UTCTiming included in the Media Presentation Description (MPD)
         */
        utcTiming?: enums.mediapackage.OriginEndpointDashPackageUtcTiming;
        /**
         * Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO, HTTP-HEAD or HTTP-XSDATE
         */
        utcTimingUri?: string;
    }
    /**
     * The configuration to use for encrypting one or more content tracks separately for endpoints that use SPEKE 2.0.
     */
    interface OriginEndpointEncryptionContractConfiguration {
        /**
         * A collection of audio encryption presets.
         */
        presetSpeke20Audio: enums.mediapackage.OriginEndpointEncryptionContractConfigurationPresetSpeke20Audio;
        /**
         * A collection of video encryption presets.
         */
        presetSpeke20Video: enums.mediapackage.OriginEndpointEncryptionContractConfigurationPresetSpeke20Video;
    }
    /**
     * An HTTP Live Streaming (HLS) encryption configuration.
     */
    interface OriginEndpointHlsEncryption {
        /**
         * A constant initialization vector for encryption (optional). When not specified the initialization vector will be periodically rotated.
         */
        constantInitializationVector?: string;
        /**
         * The encryption method to use.
         */
        encryptionMethod?: enums.mediapackage.OriginEndpointHlsEncryptionEncryptionMethod;
        /**
         * Interval (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: number;
        /**
         * When enabled, the EXT-X-KEY tag will be repeated in output manifests.
         */
        repeatExtXKey?: boolean;
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }
    /**
     * A HTTP Live Streaming (HLS) manifest configuration.
     */
    interface OriginEndpointHlsManifest {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
         */
        adMarkers?: enums.mediapackage.OriginEndpointHlsManifestAdMarkers;
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: enums.mediapackage.OriginEndpointHlsManifestAdTriggersItem[];
        adsOnDeliveryRestrictions?: enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions;
        /**
         * The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
         */
        id: string;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: boolean;
        /**
         * An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
         */
        manifestName?: string;
        /**
         * The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
         */
        playlistType?: enums.mediapackage.OriginEndpointHlsManifestPlaylistType;
        /**
         * Time window (in seconds) contained in each parent manifest.
         */
        playlistWindowSeconds?: number;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: number;
        /**
         * The URL of the packaged OriginEndpoint for consumption.
         */
        url?: string;
    }
    /**
     * An HTTP Live Streaming (HLS) packaging configuration.
     */
    interface OriginEndpointHlsPackage {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
         */
        adMarkers?: enums.mediapackage.OriginEndpointHlsPackageAdMarkers;
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: enums.mediapackage.OriginEndpointHlsPackageAdTriggersItem[];
        adsOnDeliveryRestrictions?: enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions;
        encryption?: outputs.mediapackage.OriginEndpointHlsEncryption;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: boolean;
        /**
         * The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
         */
        playlistType?: enums.mediapackage.OriginEndpointHlsPackagePlaylistType;
        /**
         * Time window (in seconds) contained in each parent manifest.
         */
        playlistWindowSeconds?: number;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: number;
        /**
         * Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
         */
        segmentDurationSeconds?: number;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
        /**
         * When enabled, audio streams will be placed in rendition groups in the output.
         */
        useAudioRenditionGroup?: boolean;
    }
    /**
     * A Microsoft Smooth Streaming (MSS) encryption configuration.
     */
    interface OriginEndpointMssEncryption {
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }
    /**
     * A Microsoft Smooth Streaming (MSS) packaging configuration.
     */
    interface OriginEndpointMssPackage {
        encryption?: outputs.mediapackage.OriginEndpointMssEncryption;
        /**
         * The time window (in seconds) contained in each manifest.
         */
        manifestWindowSeconds?: number;
        /**
         * The duration (in seconds) of each segment.
         */
        segmentDurationSeconds?: number;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
    }
    /**
     * A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
     */
    interface OriginEndpointSpekeKeyProvider {
        /**
         * An Amazon Resource Name (ARN) of a Certificate Manager certificate that MediaPackage will use for enforcing secure end-to-end data transfer with the key provider service.
         */
        certificateArn?: string;
        encryptionContractConfiguration?: outputs.mediapackage.OriginEndpointEncryptionContractConfiguration;
        /**
         * The resource ID to include in key requests.
         */
        resourceId: string;
        /**
         * An Amazon Resource Name (ARN) of an IAM role that AWS Elemental MediaPackage will assume when accessing the key provider service.
         */
        roleArn: string;
        /**
         * The system IDs to include in key requests.
         */
        systemIds: string[];
        /**
         * The URL of the external key provider service.
         */
        url: string;
    }
    /**
     * A StreamSelection configuration.
     */
    interface OriginEndpointStreamSelection {
        /**
         * The maximum video bitrate (bps) to include in output.
         */
        maxVideoBitsPerSecond?: number;
        /**
         * The minimum video bitrate (bps) to include in output.
         */
        minVideoBitsPerSecond?: number;
        /**
         * A directive that determines the order of streams in the output.
         */
        streamOrder?: enums.mediapackage.OriginEndpointStreamSelectionStreamOrder;
    }
    interface OriginEndpointTag {
        key: string;
        value: string;
    }
    /**
     * A CMAF encryption configuration.
     */
    interface PackagingConfigurationCmafEncryption {
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }
    /**
     * A CMAF packaging configuration.
     */
    interface PackagingConfigurationCmafPackage {
        encryption?: outputs.mediapackage.PackagingConfigurationCmafEncryption;
        /**
         * A list of HLS manifest configurations.
         */
        hlsManifests: outputs.mediapackage.PackagingConfigurationHlsManifest[];
        /**
         * When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
         */
        includeEncoderConfigurationInSegments?: boolean;
        segmentDurationSeconds?: number;
    }
    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
     */
    interface PackagingConfigurationDashEncryption {
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }
    /**
     * A DASH manifest configuration.
     */
    interface PackagingConfigurationDashManifest {
        /**
         * Determines the position of some tags in the Media Presentation Description (MPD). When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation. When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
         */
        manifestLayout?: enums.mediapackage.PackagingConfigurationDashManifestManifestLayout;
        manifestName?: string;
        /**
         * Minimum duration (in seconds) that a player will buffer media before starting the presentation.
         */
        minBufferTimeSeconds?: number;
        /**
         * The Dynamic Adaptive Streaming over HTTP (DASH) profile type. When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
         */
        profile?: enums.mediapackage.PackagingConfigurationDashManifestProfile;
        /**
         * The source of scte markers used. When set to SEGMENTS, the scte markers are sourced from the segments of the ingested content. When set to MANIFEST, the scte markers are sourced from the manifest of the ingested content.
         */
        scteMarkersSource?: enums.mediapackage.PackagingConfigurationDashManifestScteMarkersSource;
        streamSelection?: outputs.mediapackage.PackagingConfigurationStreamSelection;
    }
    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
     */
    interface PackagingConfigurationDashPackage {
        /**
         * A list of DASH manifest configurations.
         */
        dashManifests: outputs.mediapackage.PackagingConfigurationDashManifest[];
        encryption?: outputs.mediapackage.PackagingConfigurationDashEncryption;
        /**
         * When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
         */
        includeEncoderConfigurationInSegments?: boolean;
        /**
         * A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Asset contains SCTE-35 ad markers.
         */
        periodTriggers?: enums.mediapackage.PackagingConfigurationDashPackagePeriodTriggersItem[];
        segmentDurationSeconds?: number;
        /**
         * Determines the type of SegmentTemplate included in the Media Presentation Description (MPD). When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs. When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
         */
        segmentTemplateFormat?: enums.mediapackage.PackagingConfigurationDashPackageSegmentTemplateFormat;
    }
    /**
     * An HTTP Live Streaming (HLS) encryption configuration.
     */
    interface PackagingConfigurationHlsEncryption {
        /**
         * An HTTP Live Streaming (HLS) encryption configuration.
         */
        constantInitializationVector?: string;
        /**
         * The encryption method to use.
         */
        encryptionMethod?: enums.mediapackage.PackagingConfigurationHlsEncryptionEncryptionMethod;
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }
    /**
     * An HTTP Live Streaming (HLS) manifest configuration.
     */
    interface PackagingConfigurationHlsManifest {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source.
         */
        adMarkers?: enums.mediapackage.PackagingConfigurationHlsManifestAdMarkers;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: boolean;
        manifestName?: string;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: number;
        /**
         * When enabled, the EXT-X-KEY tag will be repeated in output manifests.
         */
        repeatExtXKey?: boolean;
        streamSelection?: outputs.mediapackage.PackagingConfigurationStreamSelection;
    }
    /**
     * An HTTP Live Streaming (HLS) packaging configuration.
     */
    interface PackagingConfigurationHlsPackage {
        encryption?: outputs.mediapackage.PackagingConfigurationHlsEncryption;
        /**
         * A list of HLS manifest configurations.
         */
        hlsManifests: outputs.mediapackage.PackagingConfigurationHlsManifest[];
        segmentDurationSeconds?: number;
        /**
         * When enabled, audio streams will be placed in rendition groups in the output.
         */
        useAudioRenditionGroup?: boolean;
    }
    /**
     * A CMAF encryption configuration.
     */
    interface PackagingConfigurationMssEncryption {
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }
    /**
     * A Microsoft Smooth Streaming (MSS) manifest configuration.
     */
    interface PackagingConfigurationMssManifest {
        manifestName?: string;
        streamSelection?: outputs.mediapackage.PackagingConfigurationStreamSelection;
    }
    /**
     * A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
     */
    interface PackagingConfigurationMssPackage {
        encryption?: outputs.mediapackage.PackagingConfigurationMssEncryption;
        /**
         * A list of MSS manifest configurations.
         */
        mssManifests: outputs.mediapackage.PackagingConfigurationMssManifest[];
        segmentDurationSeconds?: number;
    }
    /**
     * A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
     */
    interface PackagingConfigurationSpekeKeyProvider {
        roleArn: string;
        /**
         * The system IDs to include in key requests.
         */
        systemIds: string[];
        /**
         * The URL of the external key provider service.
         */
        url: string;
    }
    /**
     * A StreamSelection configuration.
     */
    interface PackagingConfigurationStreamSelection {
        /**
         * The maximum video bitrate (bps) to include in output.
         */
        maxVideoBitsPerSecond?: number;
        /**
         * The minimum video bitrate (bps) to include in output.
         */
        minVideoBitsPerSecond?: number;
        /**
         * A directive that determines the order of streams in the output.
         */
        streamOrder?: enums.mediapackage.PackagingConfigurationStreamSelectionStreamOrder;
    }
    interface PackagingConfigurationTag {
        key: string;
        value: string;
    }
    interface PackagingGroupAuthorization {
        /**
         * The Amazon Resource Name (ARN) for the secret in AWS Secrets Manager that is used for CDN authorization.
         */
        cdnIdentifierSecret: string;
        /**
         * The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
         */
        secretsRoleArn: string;
    }
    interface PackagingGroupLogConfiguration {
        /**
         * Sets a custom AWS CloudWatch log group name for egress logs. If a log group name isn't specified, the default name is used: /aws/MediaPackage/VodEgressAccessLogs.
         */
        logGroupName?: string;
    }
    interface PackagingGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace mediastore {
    interface ContainerCorsRule {
        allowedHeaders?: string[];
        allowedMethods?: string[];
        allowedOrigins?: string[];
        exposeHeaders?: string[];
        maxAgeSeconds?: number;
    }
    interface ContainerMetricPolicy {
        containerLevelMetrics: string;
        metricPolicyRules?: outputs.mediastore.ContainerMetricPolicyRule[];
    }
    interface ContainerMetricPolicyRule {
        objectGroup: string;
        objectGroupName: string;
    }
    interface ContainerTag {
        key: string;
        value: string;
    }
}
export declare namespace mediatailor {
    /**
     * For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
     */
    interface PlaybackConfigurationAdMarkerPassthrough {
        /**
         * Enables ad marker passthrough for your configuration.
         */
        enabled?: boolean;
    }
    /**
     * The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see Ad Suppression (https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
     */
    interface PlaybackConfigurationAvailSuppression {
        /**
         * Sets the ad suppression mode. By default, ad suppression is set to OFF and all ad breaks are filled with ads or slate. When Mode is set to BEHIND_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.
         */
        mode?: enums.mediatailor.PlaybackConfigurationAvailSuppressionMode;
        /**
         * A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.
         */
        value?: string;
    }
    /**
     * The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see Bumpers (https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
     */
    interface PlaybackConfigurationBumper {
        /**
         * The URL for the end bumper asset.
         */
        endUrl?: string;
        /**
         * The URL for the start bumper asset.
         */
        startUrl?: string;
    }
    /**
     * The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
     */
    interface PlaybackConfigurationCdnConfiguration {
        /**
         * A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.&lt;region>.amazonaws.com. Then specify the rule's name in this AdSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.
         */
        adSegmentUrlPrefix?: string;
        /**
         * A content delivery network (CDN) to cache content segments, so that content requests don't always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this ContentSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.
         */
        contentSegmentUrlPrefix?: string;
    }
    /**
     * The predefined aliases for dynamic variables.
     */
    interface PlaybackConfigurationConfigurationAliases {
    }
    /**
     * The configuration for DASH PUT operations.
     */
    interface PlaybackConfigurationDashConfiguration {
        /**
         * The URL generated by MediaTailor to initiate a DASH playback session. The session uses server-side reporting.
         */
        manifestEndpointPrefix?: string;
        /**
         * The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
         */
        mpdLocation?: string;
        /**
         * The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
         */
        originManifestType?: enums.mediatailor.PlaybackConfigurationDashConfigurationOriginManifestType;
    }
    interface PlaybackConfigurationHlsConfiguration {
        /**
         * The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.
         */
        manifestEndpointPrefix?: string;
    }
    /**
     * The configuration for pre-roll ad insertion.
     */
    interface PlaybackConfigurationLivePreRollConfiguration {
        /**
         * The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
         */
        adDecisionServerUrl?: string;
        /**
         * The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.
         */
        maxDurationSeconds?: number;
    }
    /**
     * The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
     */
    interface PlaybackConfigurationManifestProcessingRules {
        /**
         * For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
         */
        adMarkerPassthrough?: outputs.mediatailor.PlaybackConfigurationAdMarkerPassthrough;
    }
    interface PlaybackConfigurationTag {
        key: string;
        value: string;
    }
}
export declare namespace memorydb {
    /**
     * A key-value pair to associate with a resource.
     */
    interface ACLTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws: or memorydb:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws: or memorydb:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface AuthenticationModeProperties {
        /**
         * Passwords used for this user account. You can create up to two passwords for each user.
         */
        passwords?: string[];
        /**
         * Type of authentication strategy for this user.
         */
        type?: enums.memorydb.UserAuthenticationModePropertiesType;
    }
    interface ClusterEndpoint {
        /**
         * The DNS address of the primary read-write node.
         */
        address?: string;
        /**
         * The port number that the engine is listening on.
         */
        port?: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ClusterTag {
        /**
         * The key for the tag. May not be null.
         */
        key: string;
        /**
         * The tag's value. May be null.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ParameterGroupTag {
        /**
         * The key for the tag. May not be null.
         */
        key: string;
        /**
         * The tag's value. May be null.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface SubnetGroupTag {
        /**
         * The key for the tag. May not be null.
         */
        key: string;
        /**
         * The tag's value. May be null.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface UserTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws: or memorydb:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws: or memorydb:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace msk {
    interface ClusterBrokerLogs {
        cloudWatchLogs?: outputs.msk.ClusterCloudWatchLogs;
        firehose?: outputs.msk.ClusterFirehose;
        s3?: outputs.msk.ClusterS3;
    }
    interface ClusterBrokerNodeGroupInfo {
        brokerAZDistribution?: string;
        clientSubnets: string[];
        connectivityInfo?: outputs.msk.ClusterConnectivityInfo;
        instanceType: string;
        securityGroups?: string[];
        storageInfo?: outputs.msk.ClusterStorageInfo;
    }
    interface ClusterClientAuthentication {
        sasl?: outputs.msk.ClusterSasl;
        tls?: outputs.msk.ClusterTls;
        unauthenticated?: outputs.msk.ClusterUnauthenticated;
    }
    interface ClusterCloudWatchLogs {
        enabled: boolean;
        logGroup?: string;
    }
    interface ClusterConfigurationInfo {
        arn: string;
        revision: number;
    }
    interface ClusterConnectivityInfo {
        publicAccess?: outputs.msk.ClusterPublicAccess;
    }
    interface ClusterEBSStorageInfo {
        provisionedThroughput?: outputs.msk.ClusterProvisionedThroughput;
        volumeSize?: number;
    }
    interface ClusterEncryptionAtRest {
        dataVolumeKMSKeyId: string;
    }
    interface ClusterEncryptionInTransit {
        clientBroker?: enums.msk.ClusterEncryptionInTransitClientBroker;
        inCluster?: boolean;
    }
    interface ClusterEncryptionInfo {
        encryptionAtRest?: outputs.msk.ClusterEncryptionAtRest;
        encryptionInTransit?: outputs.msk.ClusterEncryptionInTransit;
    }
    interface ClusterFirehose {
        deliveryStream?: string;
        enabled: boolean;
    }
    interface ClusterIam {
        enabled: boolean;
    }
    interface ClusterJmxExporter {
        enabledInBroker: boolean;
    }
    interface ClusterLoggingInfo {
        brokerLogs: outputs.msk.ClusterBrokerLogs;
    }
    interface ClusterNodeExporter {
        enabledInBroker: boolean;
    }
    interface ClusterOpenMonitoring {
        prometheus: outputs.msk.ClusterPrometheus;
    }
    interface ClusterPrometheus {
        jmxExporter?: outputs.msk.ClusterJmxExporter;
        nodeExporter?: outputs.msk.ClusterNodeExporter;
    }
    interface ClusterProvisionedThroughput {
        enabled?: boolean;
        volumeThroughput?: number;
    }
    interface ClusterPublicAccess {
        type?: string;
    }
    interface ClusterS3 {
        bucket?: string;
        enabled: boolean;
        prefix?: string;
    }
    interface ClusterSasl {
        iam?: outputs.msk.ClusterIam;
        scram?: outputs.msk.ClusterScram;
    }
    interface ClusterScram {
        enabled: boolean;
    }
    interface ClusterStorageInfo {
        eBSStorageInfo?: outputs.msk.ClusterEBSStorageInfo;
    }
    interface ClusterTls {
        certificateAuthorityArnList?: string[];
        enabled?: boolean;
    }
    interface ClusterUnauthenticated {
        enabled: boolean;
    }
    interface ServerlessClusterClientAuthentication {
        sasl: outputs.msk.ServerlessClusterSasl;
    }
    interface ServerlessClusterIam {
        enabled: boolean;
    }
    interface ServerlessClusterSasl {
        iam: outputs.msk.ServerlessClusterIam;
    }
    interface ServerlessClusterVpcConfig {
        securityGroups?: string[];
        subnetIds: string[];
    }
}
export declare namespace mwaa {
    /**
     * Logging configuration for the environment.
     */
    interface EnvironmentLoggingConfiguration {
        dagProcessingLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        schedulerLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        taskLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        webserverLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        workerLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
    }
    /**
     * Logging configuration for a specific airflow component.
     */
    interface EnvironmentModuleLoggingConfiguration {
        cloudWatchLogGroupArn?: string;
        enabled?: boolean;
        logLevel?: enums.mwaa.EnvironmentLoggingLevel;
    }
    /**
     * Configures the network resources of the environment.
     */
    interface EnvironmentNetworkConfiguration {
        /**
         * A list of security groups to use for the environment.
         */
        securityGroupIds?: string[];
        /**
         * A list of subnets to use for the environment. These must be private subnets, in the same VPC, in two different availability zones.
         */
        subnetIds?: string[];
    }
}
export declare namespace neptune {
    interface DBClusterParameterGroupTag {
        key: string;
        value: string;
    }
    interface DBClusterRole {
        featureName?: string;
        roleArn: string;
    }
    interface DBClusterTag {
        key: string;
        value: string;
    }
    interface DBInstanceTag {
        key: string;
        value: string;
    }
    interface DBParameterGroupTag {
        key: string;
        value: string;
    }
    interface DBSubnetGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace networkfirewall {
    interface FirewallPolicy {
        statefulDefaultActions?: string[];
        statefulEngineOptions?: outputs.networkfirewall.FirewallPolicyStatefulEngineOptions;
        statefulRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyStatefulRuleGroupReference[];
        statelessCustomActions?: outputs.networkfirewall.FirewallPolicyCustomAction[];
        statelessDefaultActions: string[];
        statelessFragmentDefaultActions: string[];
        statelessRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyStatelessRuleGroupReference[];
    }
    interface FirewallPolicyActionDefinition {
        publishMetricAction?: outputs.networkfirewall.FirewallPolicyPublishMetricAction;
    }
    interface FirewallPolicyCustomAction {
        actionDefinition: outputs.networkfirewall.FirewallPolicyActionDefinition;
        actionName: string;
    }
    interface FirewallPolicyDimension {
        value: string;
    }
    interface FirewallPolicyPublishMetricAction {
        dimensions: outputs.networkfirewall.FirewallPolicyDimension[];
    }
    interface FirewallPolicyStatefulEngineOptions {
        ruleOrder?: enums.networkfirewall.FirewallPolicyRuleOrder;
    }
    interface FirewallPolicyStatefulRuleGroupOverride {
        action?: enums.networkfirewall.FirewallPolicyOverrideAction;
    }
    interface FirewallPolicyStatefulRuleGroupReference {
        override?: outputs.networkfirewall.FirewallPolicyStatefulRuleGroupOverride;
        priority?: number;
        resourceArn: string;
    }
    interface FirewallPolicyStatelessRuleGroupReference {
        priority: number;
        resourceArn: string;
    }
    interface FirewallPolicyTag {
        key: string;
        value: string;
    }
    interface FirewallSubnetMapping {
        /**
         * A SubnetId.
         */
        subnetId: string;
    }
    interface FirewallTag {
        key: string;
        value: string;
    }
    interface LoggingConfiguration {
        logDestinationConfigs: outputs.networkfirewall.LoggingConfigurationLogDestinationConfig[];
    }
    interface LoggingConfigurationLogDestinationConfig {
        /**
         * A key-value pair to configure the logDestinations.
         */
        logDestination: any;
        logDestinationType: enums.networkfirewall.LoggingConfigurationLogDestinationConfigLogDestinationType;
        logType: enums.networkfirewall.LoggingConfigurationLogDestinationConfigLogType;
    }
    interface RuleGroup {
        ruleVariables?: outputs.networkfirewall.RuleGroupRuleVariables;
        rulesSource: outputs.networkfirewall.RuleGroupRulesSource;
        statefulRuleOptions?: outputs.networkfirewall.RuleGroupStatefulRuleOptions;
    }
    interface RuleGroupActionDefinition {
        publishMetricAction?: outputs.networkfirewall.RuleGroupPublishMetricAction;
    }
    interface RuleGroupAddress {
        addressDefinition: string;
    }
    interface RuleGroupCustomAction {
        actionDefinition: outputs.networkfirewall.RuleGroupActionDefinition;
        actionName: string;
    }
    interface RuleGroupDimension {
        value: string;
    }
    interface RuleGroupHeader {
        destination: string;
        destinationPort: string;
        direction: enums.networkfirewall.RuleGroupHeaderDirection;
        protocol: enums.networkfirewall.RuleGroupHeaderProtocol;
        source: string;
        sourcePort: string;
    }
    interface RuleGroupMatchAttributes {
        destinationPorts?: outputs.networkfirewall.RuleGroupPortRange[];
        destinations?: outputs.networkfirewall.RuleGroupAddress[];
        protocols?: number[];
        sourcePorts?: outputs.networkfirewall.RuleGroupPortRange[];
        sources?: outputs.networkfirewall.RuleGroupAddress[];
        tCPFlags?: outputs.networkfirewall.RuleGroupTCPFlagField[];
    }
    interface RuleGroupPortRange {
        fromPort: number;
        toPort: number;
    }
    interface RuleGroupPublishMetricAction {
        dimensions: outputs.networkfirewall.RuleGroupDimension[];
    }
    interface RuleGroupRuleDefinition {
        actions: string[];
        matchAttributes: outputs.networkfirewall.RuleGroupMatchAttributes;
    }
    interface RuleGroupRuleOption {
        keyword: string;
        settings?: string[];
    }
    interface RuleGroupRuleVariables {
        iPSets?: any;
        portSets?: any;
    }
    interface RuleGroupRulesSource {
        rulesSourceList?: outputs.networkfirewall.RuleGroupRulesSourceList;
        rulesString?: string;
        statefulRules?: outputs.networkfirewall.RuleGroupStatefulRule[];
        statelessRulesAndCustomActions?: outputs.networkfirewall.RuleGroupStatelessRulesAndCustomActions;
    }
    interface RuleGroupRulesSourceList {
        generatedRulesType: enums.networkfirewall.RuleGroupGeneratedRulesType;
        targetTypes: enums.networkfirewall.RuleGroupTargetType[];
        targets: string[];
    }
    interface RuleGroupStatefulRule {
        action: enums.networkfirewall.RuleGroupStatefulRuleAction;
        header: outputs.networkfirewall.RuleGroupHeader;
        ruleOptions: outputs.networkfirewall.RuleGroupRuleOption[];
    }
    interface RuleGroupStatefulRuleOptions {
        ruleOrder?: enums.networkfirewall.RuleGroupRuleOrder;
    }
    interface RuleGroupStatelessRule {
        priority: number;
        ruleDefinition: outputs.networkfirewall.RuleGroupRuleDefinition;
    }
    interface RuleGroupStatelessRulesAndCustomActions {
        customActions?: outputs.networkfirewall.RuleGroupCustomAction[];
        statelessRules: outputs.networkfirewall.RuleGroupStatelessRule[];
    }
    interface RuleGroupTCPFlagField {
        flags: enums.networkfirewall.RuleGroupTCPFlag[];
        masks?: enums.networkfirewall.RuleGroupTCPFlag[];
    }
    interface RuleGroupTag {
        key: string;
        value: string;
    }
}
export declare namespace networkmanager {
    /**
     * Connect attachment options for protocol
     */
    interface ConnectAttachmentOptions {
        /**
         * Tunnel protocol for connect attachment
         */
        protocol?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ConnectAttachmentProposedSegmentChange {
        /**
         * New policy rule number of the attachment
         */
        attachmentPolicyRuleNumber?: number;
        /**
         * Proposed segment name
         */
        segmentName?: string;
        /**
         * Proposed tags for the Segment.
         */
        tags?: outputs.networkmanager.ConnectAttachmentTag[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ConnectAttachmentTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Bgp configuration for connect peer
     */
    interface ConnectPeerBgpConfiguration {
        coreNetworkAddress?: string;
        coreNetworkAsn?: number;
        peerAddress?: string;
        peerAsn?: number;
    }
    /**
     * Bgp options
     */
    interface ConnectPeerBgpOptions {
        peerAsn?: number;
    }
    interface ConnectPeerConfiguration {
        bgpConfigurations?: outputs.networkmanager.ConnectPeerBgpConfiguration[];
        coreNetworkAddress?: string;
        insideCidrBlocks?: string[];
        peerAddress?: string;
        protocol?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ConnectPeerTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface CoreNetworkEdge {
        /**
         * The ASN of a core network edge.
         */
        asn?: number;
        /**
         * The Region where a core network edge is located.
         */
        edgeLocation?: string;
        insideCidrBlocks?: string[];
    }
    interface CoreNetworkSegment {
        edgeLocations?: string[];
        /**
         * Name of segment
         */
        name?: string;
        sharedSegments?: string[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface CoreNetworkTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The site location.
     */
    interface DeviceLocation {
        /**
         * The physical address.
         */
        address?: string;
        /**
         * The latitude.
         */
        latitude?: string;
        /**
         * The longitude.
         */
        longitude?: string;
    }
    /**
     * A key-value pair to associate with a device resource.
     */
    interface DeviceTag {
        key?: string;
        value?: string;
    }
    /**
     * A key-value pair to associate with a global network resource.
     */
    interface GlobalNetworkTag {
        key?: string;
        value?: string;
    }
    /**
     * The bandwidth for the link.
     */
    interface LinkBandwidth {
        /**
         * Download speed in Mbps.
         */
        downloadSpeed?: number;
        /**
         * Upload speed in Mbps.
         */
        uploadSpeed?: number;
    }
    /**
     * A key-value pair to associate with a link resource.
     */
    interface LinkTag {
        key?: string;
        value?: string;
    }
    /**
     * The location of the site
     */
    interface SiteLocation {
        /**
         * The physical address.
         */
        address?: string;
        /**
         * The latitude.
         */
        latitude?: string;
        /**
         * The longitude.
         */
        longitude?: string;
    }
    /**
     * A key-value pair to associate with a site resource.
     */
    interface SiteTag {
        key?: string;
        value?: string;
    }
    /**
     * The attachment to move from one segment to another.
     */
    interface SiteToSiteVpnAttachmentProposedSegmentChange {
        /**
         * The rule number in the policy document that applies to this change.
         */
        attachmentPolicyRuleNumber?: number;
        /**
         * The name of the segment to change.
         */
        segmentName?: string;
        /**
         * The key-value tags that changed for the segment.
         */
        tags?: outputs.networkmanager.SiteToSiteVpnAttachmentTag[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface SiteToSiteVpnAttachmentTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The attachment to move from one segment to another.
     */
    interface VpcAttachmentProposedSegmentChange {
        /**
         * The rule number in the policy document that applies to this change.
         */
        attachmentPolicyRuleNumber?: number;
        /**
         * The name of the segment to change.
         */
        segmentName?: string;
        /**
         * The key-value tags that changed for the segment.
         */
        tags?: outputs.networkmanager.VpcAttachmentTag[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface VpcAttachmentTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Vpc options of the attachment.
     */
    interface VpcAttachmentVpcOptions {
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        ipv6Support?: boolean;
    }
}
export declare namespace nimblestudio {
    /**
     * <p>A configuration for a streaming session.</p>
     */
    interface LaunchProfileStreamConfiguration {
        clipboardMode: enums.nimblestudio.LaunchProfileStreamingClipboardMode;
        /**
         * <p>The EC2 instance types that users can select from when launching a streaming session
         *             with this launch profile.</p>
         */
        ec2InstanceTypes: enums.nimblestudio.LaunchProfileStreamingInstanceType[];
        /**
         * <p>The length of time, in minutes, that a streaming session can be active before it is
         *             stopped or terminated. After this point, Nimble Studio automatically terminates or
         *             stops the session. The default length of time is 690 minutes, and the maximum length of
         *             time is 30 days.</p>
         */
        maxSessionLengthInMinutes?: number;
        /**
         * <p>Integer that determines if you can start and stop your sessions and how long a session
         *             can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
         *         <p>If the value is missing or set to 0, your sessions can’t be stopped. If you then call
         *                 <code>StopStreamingSession</code>, the session fails. If the time that a session
         *             stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the
         *             session will automatically be terminated (instead of stopped).</p>
         *         <p>If the value is set to a positive number, the session can be stopped. You can call
         *                 <code>StopStreamingSession</code> to stop sessions in the READY state. If the time
         *             that a session stays in the READY state exceeds the
         *                 <code>maxSessionLengthInMinutes</code> value, the session will automatically be
         *             stopped (instead of terminated).</p>
         */
        maxStoppedSessionLengthInMinutes?: number;
        sessionStorage?: outputs.nimblestudio.LaunchProfileStreamConfigurationSessionStorage;
        /**
         * <p>The streaming images that users can select from when launching a streaming session
         *             with this launch profile.</p>
         */
        streamingImageIds: string[];
    }
    /**
     * <p>The configuration for a streaming session’s upload storage.</p>
     */
    interface LaunchProfileStreamConfigurationSessionStorage {
        /**
         * <p>Allows artists to upload files to their workstations. The only valid option is
         *                 <code>UPLOAD</code>.</p>
         */
        mode: enums.nimblestudio.LaunchProfileStreamingSessionStorageMode[];
        root?: outputs.nimblestudio.LaunchProfileStreamingSessionStorageRoot;
    }
    /**
     * <p>The upload storage root location (folder) on streaming workstations where files are
     *             uploaded.</p>
     */
    interface LaunchProfileStreamingSessionStorageRoot {
        /**
         * <p>The folder path in Linux workstations where files are uploaded.</p>
         */
        linux?: string;
        /**
         * <p>The folder path in Windows workstations where files are uploaded.</p>
         */
        windows?: string;
    }
    interface LaunchProfileTags {
    }
    /**
     * <p>TODO</p>
     */
    interface StreamingImageEncryptionConfiguration {
        /**
         * <p>The ARN for a KMS key that is used to encrypt studio data.</p>
         */
        keyArn?: string;
        keyType: enums.nimblestudio.StreamingImageEncryptionConfigurationKeyType;
    }
    interface StreamingImageTags {
    }
    /**
     * <p>The configuration of the studio component, based on component type.</p>
     */
    interface StudioComponentConfiguration {
    }
    /**
     * <p>Initialization scripts for studio components.</p>
     */
    interface StudioComponentInitializationScript {
        /**
         * <p>The version number of the protocol that is used by the launch profile. The only valid
         *             version is "2021-03-31".</p>
         */
        launchProfileProtocolVersion?: string;
        platform?: enums.nimblestudio.StudioComponentLaunchProfilePlatform;
        runContext?: enums.nimblestudio.StudioComponentInitializationScriptRunContext;
        /**
         * <p>The initialization script.</p>
         */
        script?: string;
    }
    /**
     * <p>A parameter for a studio component script, in the form of a key:value pair.</p>
     */
    interface StudioComponentScriptParameterKeyValue {
        /**
         * <p>A script parameter key.</p>
         */
        key?: string;
        /**
         * <p>A script parameter value.</p>
         */
        value?: string;
    }
    interface StudioComponentTags {
    }
    /**
     * <p>Configuration of the encryption method that is used for the studio.</p>
     */
    interface StudioEncryptionConfiguration {
        /**
         * <p>The ARN for a KMS key that is used to encrypt studio data.</p>
         */
        keyArn?: string;
        keyType: enums.nimblestudio.StudioEncryptionConfigurationKeyType;
    }
    interface StudioTags {
    }
}
export declare namespace opensearchservice {
    interface DomainAdvancedSecurityOptionsInput {
        enabled?: boolean;
        internalUserDatabaseEnabled?: boolean;
        masterUserOptions?: outputs.opensearchservice.DomainMasterUserOptions;
    }
    interface DomainClusterConfig {
        dedicatedMasterCount?: number;
        dedicatedMasterEnabled?: boolean;
        dedicatedMasterType?: string;
        instanceCount?: number;
        instanceType?: string;
        warmCount?: number;
        warmEnabled?: boolean;
        warmType?: string;
        zoneAwarenessConfig?: outputs.opensearchservice.DomainZoneAwarenessConfig;
        zoneAwarenessEnabled?: boolean;
    }
    interface DomainCognitoOptions {
        enabled?: boolean;
        identityPoolId?: string;
        roleArn?: string;
        userPoolId?: string;
    }
    interface DomainEBSOptions {
        eBSEnabled?: boolean;
        iops?: number;
        throughput?: number;
        volumeSize?: number;
        volumeType?: string;
    }
    interface DomainEncryptionAtRestOptions {
        enabled?: boolean;
        kmsKeyId?: string;
    }
    interface DomainEndpointOptions {
        customEndpoint?: string;
        customEndpointCertificateArn?: string;
        customEndpointEnabled?: boolean;
        enforceHTTPS?: boolean;
        tLSSecurityPolicy?: string;
    }
    interface DomainMasterUserOptions {
        masterUserARN?: string;
        masterUserName?: string;
        masterUserPassword?: string;
    }
    interface DomainNodeToNodeEncryptionOptions {
        enabled?: boolean;
    }
    interface DomainServiceSoftwareOptions {
        automatedUpdateDate?: string;
        cancellable?: boolean;
        currentVersion?: string;
        description?: string;
        newVersion?: string;
        optionalDeployment?: boolean;
        updateAvailable?: boolean;
        updateStatus?: string;
    }
    interface DomainSnapshotOptions {
        automatedSnapshotStartHour?: number;
    }
    interface DomainTag {
        /**
         * The value of the tag.
         */
        key: string;
        /**
         * The key of the tag.
         */
        value: string;
    }
    interface DomainVPCOptions {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }
    interface DomainZoneAwarenessConfig {
        availabilityZoneCount?: number;
    }
}
export declare namespace opsworks {
    interface AppDataSource {
        arn?: string;
        databaseName?: string;
        type?: string;
    }
    interface AppEnvironmentVariable {
        key: string;
        secure?: boolean;
        value: string;
    }
    interface AppSource {
        password?: string;
        revision?: string;
        sshKey?: string;
        type?: string;
        url?: string;
        username?: string;
    }
    interface AppSslConfiguration {
        certificate?: string;
        chain?: string;
        privateKey?: string;
    }
    interface InstanceBlockDeviceMapping {
        deviceName?: string;
        ebs?: outputs.opsworks.InstanceEbsBlockDevice;
        noDevice?: string;
        virtualName?: string;
    }
    interface InstanceEbsBlockDevice {
        deleteOnTermination?: boolean;
        iops?: number;
        snapshotId?: string;
        volumeSize?: number;
        volumeType?: string;
    }
    interface InstanceTimeBasedAutoScaling {
        friday?: any;
        monday?: any;
        saturday?: any;
        sunday?: any;
        thursday?: any;
        tuesday?: any;
        wednesday?: any;
    }
    interface LayerAutoScalingThresholds {
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface LayerLifecycleEventConfiguration {
        shutdownEventConfiguration?: outputs.opsworks.LayerShutdownEventConfiguration;
    }
    interface LayerLoadBasedAutoScaling {
        downScaling?: outputs.opsworks.LayerAutoScalingThresholds;
        enable?: boolean;
        upScaling?: outputs.opsworks.LayerAutoScalingThresholds;
    }
    interface LayerRecipes {
        configure?: string[];
        deploy?: string[];
        setup?: string[];
        shutdown?: string[];
        undeploy?: string[];
    }
    interface LayerShutdownEventConfiguration {
        delayUntilElbConnectionsDrained?: boolean;
        executionTimeout?: number;
    }
    interface LayerTag {
        key: string;
        value: string;
    }
    interface LayerVolumeConfiguration {
        encrypted?: boolean;
        iops?: number;
        mountPoint?: string;
        numberOfDisks?: number;
        raidLevel?: number;
        size?: number;
        volumeType?: string;
    }
    interface StackChefConfiguration {
        berkshelfVersion?: string;
        manageBerkshelf?: boolean;
    }
    interface StackConfigurationManager {
        name?: string;
        version?: string;
    }
    interface StackElasticIp {
        ip: string;
        name?: string;
    }
    interface StackRdsDbInstance {
        dbPassword: string;
        dbUser: string;
        rdsDbInstanceArn: string;
    }
    interface StackSource {
        password?: string;
        revision?: string;
        sshKey?: string;
        type?: string;
        url?: string;
        username?: string;
    }
    interface StackTag {
        key: string;
        value: string;
    }
}
export declare namespace opsworkscm {
    interface ServerEngineAttribute {
        name?: string;
        value?: string;
    }
    interface ServerTag {
        key: string;
        value: string;
    }
}
export declare namespace panorama {
    interface ApplicationInstanceManifestOverridesPayload {
        payloadData?: string;
    }
    interface ApplicationInstanceManifestPayload {
        payloadData?: string;
    }
    interface ApplicationInstanceTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface PackageStorageLocation {
        binaryPrefixLocation?: string;
        bucket?: string;
        generatedPrefixLocation?: string;
        manifestPrefixLocation?: string;
        repoPrefixLocation?: string;
    }
    interface PackageTag {
        key: string;
        value: string;
    }
}
export declare namespace personalize {
    /**
     * Initial DatasetImportJob for the created dataset
     */
    interface DatasetImportJob {
        /**
         * The Amazon S3 bucket that contains the training data to import.
         */
        dataSource?: outputs.personalize.DatasetImportJobDataSourceProperties;
        /**
         * The ARN of the dataset that receives the imported data
         */
        datasetArn?: string;
        /**
         * The ARN of the dataset import job
         */
        datasetImportJobArn?: string;
        /**
         * The name for the dataset import job.
         */
        jobName?: string;
        /**
         * The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
         */
        roleArn?: string;
    }
    /**
     * The Amazon S3 bucket that contains the training data to import.
     */
    interface DatasetImportJobDataSourceProperties {
        /**
         * The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored.
         */
        dataLocation?: string;
    }
    /**
     * Provides the name and values of a Categorical hyperparameter.
     */
    interface SolutionCategoricalHyperParameterRange {
        /**
         * The name of the hyperparameter.
         */
        name?: string;
        /**
         * A list of the categories for the hyperparameter.
         */
        values?: string[];
    }
    /**
     * The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration.
     */
    interface SolutionConfig {
        /**
         * Lists the hyperparameter names and ranges.
         */
        algorithmHyperParameters?: any;
        /**
         * The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
         */
        autoMLConfig?: outputs.personalize.SolutionConfigAutoMLConfigProperties;
        /**
         * Only events with a value greater than or equal to this threshold are used for training a model.
         */
        eventValueThreshold?: string;
        /**
         * Lists the feature transformation parameters.
         */
        featureTransformationParameters?: any;
        /**
         * Describes the properties for hyperparameter optimization (HPO)
         */
        hpoConfig?: outputs.personalize.SolutionConfigHpoConfigProperties;
    }
    /**
     * The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
     */
    interface SolutionConfigAutoMLConfigProperties {
        /**
         * The metric to optimize.
         */
        metricName?: string;
        /**
         * The list of candidate recipes.
         */
        recipeList?: string[];
    }
    /**
     * Describes the properties for hyperparameter optimization (HPO)
     */
    interface SolutionConfigHpoConfigProperties {
        /**
         * The hyperparameters and their allowable ranges
         */
        algorithmHyperParameterRanges?: outputs.personalize.SolutionConfigHpoConfigPropertiesAlgorithmHyperParameterRangesProperties;
        /**
         * The metric to optimize during HPO.
         */
        hpoObjective?: outputs.personalize.SolutionConfigHpoConfigPropertiesHpoObjectiveProperties;
        /**
         * Describes the resource configuration for hyperparameter optimization (HPO).
         */
        hpoResourceConfig?: outputs.personalize.SolutionConfigHpoConfigPropertiesHpoResourceConfigProperties;
    }
    /**
     * The hyperparameters and their allowable ranges
     */
    interface SolutionConfigHpoConfigPropertiesAlgorithmHyperParameterRangesProperties {
        /**
         * The categorical hyperparameters and their ranges.
         */
        categoricalHyperParameterRanges?: outputs.personalize.SolutionCategoricalHyperParameterRange[];
        /**
         * The continuous hyperparameters and their ranges.
         */
        continuousHyperParameterRanges?: outputs.personalize.SolutionContinuousHyperParameterRange[];
        /**
         * The integer hyperparameters and their ranges.
         */
        integerHyperParameterRanges?: outputs.personalize.SolutionIntegerHyperParameterRange[];
    }
    /**
     * The metric to optimize during HPO.
     */
    interface SolutionConfigHpoConfigPropertiesHpoObjectiveProperties {
        /**
         * The name of the metric
         */
        metricName?: string;
        /**
         * A regular expression for finding the metric in the training job logs.
         */
        metricRegex?: string;
        /**
         * The type of the metric. Valid values are Maximize and Minimize.
         */
        type?: enums.personalize.SolutionConfigHpoConfigPropertiesHpoObjectivePropertiesType;
    }
    /**
     * Describes the resource configuration for hyperparameter optimization (HPO).
     */
    interface SolutionConfigHpoConfigPropertiesHpoResourceConfigProperties {
        /**
         * The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
         */
        maxNumberOfTrainingJobs?: string;
        /**
         * The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
         */
        maxParallelTrainingJobs?: string;
    }
    /**
     * Provides the name and range of a continuous hyperparameter.
     */
    interface SolutionContinuousHyperParameterRange {
        /**
         * The maximum allowable value for the hyperparameter.
         */
        maxValue?: number;
        /**
         * The minimum allowable value for the hyperparameter.
         */
        minValue?: number;
        /**
         * The name of the hyperparameter.
         */
        name?: string;
    }
    /**
     * Provides the name and range of an integer-valued hyperparameter.
     */
    interface SolutionIntegerHyperParameterRange {
        /**
         * The maximum allowable value for the hyperparameter.
         */
        maxValue?: number;
        /**
         * The minimum allowable value for the hyperparameter.
         */
        minValue?: number;
        /**
         * The name of the hyperparameter.
         */
        name?: string;
    }
}
export declare namespace pinpoint {
    interface ApplicationSettingsCampaignHook {
        lambdaFunctionName?: string;
        mode?: string;
        webUrl?: string;
    }
    interface ApplicationSettingsLimits {
        daily?: number;
        maximumDuration?: number;
        messagesPerSecond?: number;
        total?: number;
    }
    interface ApplicationSettingsQuietTime {
        end: string;
        start: string;
    }
    interface CampaignCustomDeliveryConfiguration {
        deliveryUri?: string;
        endpointTypes?: string[];
    }
    interface CampaignCustomMessage {
        data?: string;
    }
    interface CampaignDefaultButtonConfiguration {
        backgroundColor?: string;
        borderRadius?: number;
        buttonAction?: string;
        link?: string;
        text?: string;
        textColor?: string;
    }
    interface CampaignEmailMessage {
        body?: string;
        fromAddress?: string;
        htmlBody?: string;
        title?: string;
    }
    interface CampaignEventDimensions {
        attributes?: any;
        eventType?: outputs.pinpoint.CampaignSetDimension;
        metrics?: any;
    }
    interface CampaignEventFilter {
        dimensions?: outputs.pinpoint.CampaignEventDimensions;
        filterType?: string;
    }
    interface CampaignHook {
        lambdaFunctionName?: string;
        mode?: string;
        webUrl?: string;
    }
    interface CampaignInAppMessage {
        content?: outputs.pinpoint.CampaignInAppMessageContent[];
        customConfig?: any;
        layout?: string;
    }
    interface CampaignInAppMessageBodyConfig {
        alignment?: string;
        body?: string;
        textColor?: string;
    }
    interface CampaignInAppMessageButton {
        android?: outputs.pinpoint.CampaignOverrideButtonConfiguration;
        defaultConfig?: outputs.pinpoint.CampaignDefaultButtonConfiguration;
        iOS?: outputs.pinpoint.CampaignOverrideButtonConfiguration;
        web?: outputs.pinpoint.CampaignOverrideButtonConfiguration;
    }
    interface CampaignInAppMessageContent {
        backgroundColor?: string;
        bodyConfig?: outputs.pinpoint.CampaignInAppMessageBodyConfig;
        headerConfig?: outputs.pinpoint.CampaignInAppMessageHeaderConfig;
        imageUrl?: string;
        primaryBtn?: outputs.pinpoint.CampaignInAppMessageButton;
        secondaryBtn?: outputs.pinpoint.CampaignInAppMessageButton;
    }
    interface CampaignInAppMessageHeaderConfig {
        alignment?: string;
        header?: string;
        textColor?: string;
    }
    interface CampaignLimits {
        daily?: number;
        maximumDuration?: number;
        messagesPerSecond?: number;
        session?: number;
        total?: number;
    }
    interface CampaignMessage {
        action?: string;
        body?: string;
        imageIconUrl?: string;
        imageSmallIconUrl?: string;
        imageUrl?: string;
        jsonBody?: string;
        mediaUrl?: string;
        rawContent?: string;
        silentPush?: boolean;
        timeToLive?: number;
        title?: string;
        url?: string;
    }
    interface CampaignMessageConfiguration {
        aDMMessage?: outputs.pinpoint.CampaignMessage;
        aPNSMessage?: outputs.pinpoint.CampaignMessage;
        baiduMessage?: outputs.pinpoint.CampaignMessage;
        customMessage?: outputs.pinpoint.CampaignCustomMessage;
        defaultMessage?: outputs.pinpoint.CampaignMessage;
        emailMessage?: outputs.pinpoint.CampaignEmailMessage;
        gCMMessage?: outputs.pinpoint.CampaignMessage;
        inAppMessage?: outputs.pinpoint.CampaignInAppMessage;
        sMSMessage?: outputs.pinpoint.CampaignSmsMessage;
    }
    interface CampaignOverrideButtonConfiguration {
        buttonAction?: string;
        link?: string;
    }
    interface CampaignQuietTime {
        end: string;
        start: string;
    }
    interface CampaignSchedule {
        endTime?: string;
        eventFilter?: outputs.pinpoint.CampaignEventFilter;
        frequency?: string;
        isLocalTime?: boolean;
        quietTime?: outputs.pinpoint.CampaignQuietTime;
        startTime?: string;
        timeZone?: string;
    }
    interface CampaignSetDimension {
        dimensionType?: string;
        values?: string[];
    }
    interface CampaignSmsMessage {
        body?: string;
        entityId?: string;
        messageType?: string;
        originationNumber?: string;
        senderId?: string;
        templateId?: string;
    }
    interface CampaignTemplate {
        name?: string;
        version?: string;
    }
    interface CampaignTemplateConfiguration {
        emailTemplate?: outputs.pinpoint.CampaignTemplate;
        pushTemplate?: outputs.pinpoint.CampaignTemplate;
        sMSTemplate?: outputs.pinpoint.CampaignTemplate;
        voiceTemplate?: outputs.pinpoint.CampaignTemplate;
    }
    interface CampaignWriteTreatmentResource {
        customDeliveryConfiguration?: outputs.pinpoint.CampaignCustomDeliveryConfiguration;
        messageConfiguration?: outputs.pinpoint.CampaignMessageConfiguration;
        schedule?: outputs.pinpoint.CampaignSchedule;
        sizePercent?: number;
        templateConfiguration?: outputs.pinpoint.CampaignTemplateConfiguration;
        treatmentDescription?: string;
        treatmentName?: string;
    }
    interface InAppTemplateBodyConfig {
        alignment?: enums.pinpoint.InAppTemplateAlignment;
        body?: string;
        textColor?: string;
    }
    interface InAppTemplateButtonConfig {
        android?: outputs.pinpoint.InAppTemplateOverrideButtonConfiguration;
        defaultConfig?: outputs.pinpoint.InAppTemplateDefaultButtonConfiguration;
        iOS?: outputs.pinpoint.InAppTemplateOverrideButtonConfiguration;
        web?: outputs.pinpoint.InAppTemplateOverrideButtonConfiguration;
    }
    interface InAppTemplateDefaultButtonConfiguration {
        backgroundColor?: string;
        borderRadius?: number;
        buttonAction?: enums.pinpoint.InAppTemplateButtonAction;
        link?: string;
        text?: string;
        textColor?: string;
    }
    interface InAppTemplateHeaderConfig {
        alignment?: enums.pinpoint.InAppTemplateAlignment;
        header?: string;
        textColor?: string;
    }
    interface InAppTemplateInAppMessageContent {
        backgroundColor?: string;
        bodyConfig?: outputs.pinpoint.InAppTemplateBodyConfig;
        headerConfig?: outputs.pinpoint.InAppTemplateHeaderConfig;
        imageUrl?: string;
        primaryBtn?: outputs.pinpoint.InAppTemplateButtonConfig;
        secondaryBtn?: outputs.pinpoint.InAppTemplateButtonConfig;
    }
    interface InAppTemplateOverrideButtonConfiguration {
        buttonAction?: enums.pinpoint.InAppTemplateButtonAction;
        link?: string;
    }
    interface PushTemplateAPNSPushNotificationTemplate {
        action?: string;
        body?: string;
        mediaUrl?: string;
        sound?: string;
        title?: string;
        url?: string;
    }
    interface PushTemplateAndroidPushNotificationTemplate {
        action?: string;
        body?: string;
        imageIconUrl?: string;
        imageUrl?: string;
        smallImageIconUrl?: string;
        sound?: string;
        title?: string;
        url?: string;
    }
    interface PushTemplateDefaultPushNotificationTemplate {
        action?: string;
        body?: string;
        sound?: string;
        title?: string;
        url?: string;
    }
    interface SegmentBehavior {
        recency?: outputs.pinpoint.SegmentRecency;
    }
    interface SegmentCoordinates {
        latitude: number;
        longitude: number;
    }
    interface SegmentDemographic {
        appVersion?: outputs.pinpoint.SegmentSetDimension;
        channel?: outputs.pinpoint.SegmentSetDimension;
        deviceType?: outputs.pinpoint.SegmentSetDimension;
        make?: outputs.pinpoint.SegmentSetDimension;
        model?: outputs.pinpoint.SegmentSetDimension;
        platform?: outputs.pinpoint.SegmentSetDimension;
    }
    interface SegmentDimensions {
        attributes?: any;
        behavior?: outputs.pinpoint.SegmentBehavior;
        demographic?: outputs.pinpoint.SegmentDemographic;
        location?: outputs.pinpoint.SegmentLocation;
        metrics?: any;
        userAttributes?: any;
    }
    interface SegmentGPSPoint {
        coordinates: outputs.pinpoint.SegmentCoordinates;
        rangeInKilometers: number;
    }
    interface SegmentGroups {
        groups?: outputs.pinpoint.SegmentGroups[];
        include?: string;
    }
    interface SegmentLocation {
        country?: outputs.pinpoint.SegmentSetDimension;
        gPSPoint?: outputs.pinpoint.SegmentGPSPoint;
    }
    interface SegmentRecency {
        duration: string;
        recencyType: string;
    }
    interface SegmentSetDimension {
        dimensionType?: string;
        values?: string[];
    }
}
export declare namespace pinpointemail {
    interface ConfigurationSetDeliveryOptions {
        sendingPoolName?: string;
    }
    interface ConfigurationSetEventDestinationCloudWatchDestination {
        dimensionConfigurations?: outputs.pinpointemail.ConfigurationSetEventDestinationDimensionConfiguration[];
    }
    interface ConfigurationSetEventDestinationDimensionConfiguration {
        defaultDimensionValue: string;
        dimensionName: string;
        dimensionValueSource: string;
    }
    interface ConfigurationSetEventDestinationEventDestination {
        cloudWatchDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationCloudWatchDestination;
        enabled?: boolean;
        kinesisFirehoseDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationKinesisFirehoseDestination;
        matchingEventTypes: string[];
        pinpointDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationPinpointDestination;
        snsDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationSnsDestination;
    }
    interface ConfigurationSetEventDestinationKinesisFirehoseDestination {
        deliveryStreamArn: string;
        iamRoleArn: string;
    }
    interface ConfigurationSetEventDestinationPinpointDestination {
        applicationArn?: string;
    }
    interface ConfigurationSetEventDestinationSnsDestination {
        topicArn: string;
    }
    interface ConfigurationSetReputationOptions {
        reputationMetricsEnabled?: boolean;
    }
    interface ConfigurationSetSendingOptions {
        sendingEnabled?: boolean;
    }
    interface ConfigurationSetTags {
        key?: string;
        value?: string;
    }
    interface ConfigurationSetTrackingOptions {
        customRedirectDomain?: string;
    }
    interface DedicatedIpPoolTags {
        key?: string;
        value?: string;
    }
    interface IdentityMailFromAttributes {
        behaviorOnMxFailure?: string;
        mailFromDomain?: string;
    }
    interface IdentityTags {
        key?: string;
        value?: string;
    }
}
export declare namespace qldb {
    interface LedgerTag {
        key: string;
        value: string;
    }
    interface StreamKinesisConfiguration {
        aggregationEnabled?: boolean;
        streamArn?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface StreamTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace quicksight {
    /**
     * <p>Dataset reference.</p>
     */
    interface AnalysisDataSetReference {
        /**
         * <p>Dataset Amazon Resource Name (ARN).</p>
         */
        dataSetArn: string;
        /**
         * <p>Dataset placeholder.</p>
         */
        dataSetPlaceholder: string;
    }
    /**
     * <p>A date-time parameter.</p>
     */
    interface AnalysisDateTimeParameter {
        /**
         * <p>A display name for the date-time parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the date-time parameter.</p>
         */
        values: string[];
    }
    /**
     * <p>A decimal parameter.</p>
     */
    interface AnalysisDecimalParameter {
        /**
         * <p>A display name for the decimal parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the decimal parameter.</p>
         */
        values: number[];
    }
    /**
     * <p>A metadata error structure for an analysis.</p>
     */
    interface AnalysisError {
        /**
         * <p>The message associated with the analysis error.</p>
         */
        message?: string;
        type?: enums.quicksight.AnalysisErrorType;
    }
    /**
     * <p>An integer parameter.</p>
     */
    interface AnalysisIntegerParameter {
        /**
         * <p>The name of the integer parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the integer parameter.</p>
         */
        values: number[];
    }
    /**
     * <p>A list of QuickSight parameters and the list's override values.</p>
     */
    interface AnalysisParameters {
        /**
         * <p>Date-time parameters.</p>
         */
        dateTimeParameters?: outputs.quicksight.AnalysisDateTimeParameter[];
        /**
         * <p>Decimal parameters.</p>
         */
        decimalParameters?: outputs.quicksight.AnalysisDecimalParameter[];
        /**
         * <p>Integer parameters.</p>
         */
        integerParameters?: outputs.quicksight.AnalysisIntegerParameter[];
        /**
         * <p>String parameters.</p>
         */
        stringParameters?: outputs.quicksight.AnalysisStringParameter[];
    }
    /**
     * <p>Permission for the resource.</p>
     */
    interface AnalysisResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }
    /**
     * <p>A <i>sheet</i>, which is an object that contains a set of visuals that
     *             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
     *             contains at least one sheet. Each sheet contains at least one visualization widget, for
     *             example a chart, pivot table, or narrative insight. Sheets can be associated with other
     *             components, such as controls, filters, and so on.</p>
     */
    interface AnalysisSheet {
        /**
         * <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
         *             console.</p>
         */
        name?: string;
        /**
         * <p>The unique identifier associated with a sheet.</p>
         */
        sheetId?: string;
    }
    /**
     * <p>The source entity of an analysis.</p>
     */
    interface AnalysisSourceEntity {
        sourceTemplate?: outputs.quicksight.AnalysisSourceTemplate;
    }
    /**
     * <p>The source template of an analysis.</p>
     */
    interface AnalysisSourceTemplate {
        /**
         * <p>The Amazon Resource Name (ARN) of the source template of an analysis.</p>
         */
        arn: string;
        /**
         * <p>The dataset references of the source template of an analysis.</p>
         */
        dataSetReferences: outputs.quicksight.AnalysisDataSetReference[];
    }
    /**
     * <p>A string parameter.</p>
     */
    interface AnalysisStringParameter {
        /**
         * <p>A display name for a string parameter.</p>
         */
        name: string;
        /**
         * <p>The values of a string parameter.</p>
         */
        values: string[];
    }
    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    interface AnalysisTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }
    /**
     * <p>Ad hoc (one-time) filtering option.</p>
     */
    interface DashboardAdHocFilteringOption {
        availabilityStatus?: enums.quicksight.DashboardBehavior;
    }
    /**
     * <p>Dataset reference.</p>
     */
    interface DashboardDataSetReference {
        /**
         * <p>Dataset Amazon Resource Name (ARN).</p>
         */
        dataSetArn: string;
        /**
         * <p>Dataset placeholder.</p>
         */
        dataSetPlaceholder: string;
    }
    /**
     * <p>A date-time parameter.</p>
     */
    interface DashboardDateTimeParameter {
        /**
         * <p>A display name for the date-time parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the date-time parameter.</p>
         */
        values: string[];
    }
    /**
     * <p>A decimal parameter.</p>
     */
    interface DashboardDecimalParameter {
        /**
         * <p>A display name for the decimal parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the decimal parameter.</p>
         */
        values: number[];
    }
    /**
     * <p>Dashboard error.</p>
     */
    interface DashboardError {
        /**
         * <p>Message.</p>
         */
        message?: string;
        type?: enums.quicksight.DashboardErrorType;
    }
    /**
     * <p>Export to .csv option.</p>
     */
    interface DashboardExportToCSVOption {
        availabilityStatus?: enums.quicksight.DashboardBehavior;
    }
    /**
     * <p>An integer parameter.</p>
     */
    interface DashboardIntegerParameter {
        /**
         * <p>The name of the integer parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the integer parameter.</p>
         */
        values: number[];
    }
    /**
     * <p>A list of QuickSight parameters and the list's override values.</p>
     */
    interface DashboardParameters {
        /**
         * <p>Date-time parameters.</p>
         */
        dateTimeParameters?: outputs.quicksight.DashboardDateTimeParameter[];
        /**
         * <p>Decimal parameters.</p>
         */
        decimalParameters?: outputs.quicksight.DashboardDecimalParameter[];
        /**
         * <p>Integer parameters.</p>
         */
        integerParameters?: outputs.quicksight.DashboardIntegerParameter[];
        /**
         * <p>String parameters.</p>
         */
        stringParameters?: outputs.quicksight.DashboardStringParameter[];
    }
    /**
     * <p>Dashboard publish options.</p>
     */
    interface DashboardPublishOptions {
        adHocFilteringOption?: outputs.quicksight.DashboardAdHocFilteringOption;
        exportToCSVOption?: outputs.quicksight.DashboardExportToCSVOption;
        sheetControlsOption?: outputs.quicksight.DashboardSheetControlsOption;
    }
    /**
     * <p>Permission for the resource.</p>
     */
    interface DashboardResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }
    /**
     * <p>A <i>sheet</i>, which is an object that contains a set of visuals that
     *             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
     *             contains at least one sheet. Each sheet contains at least one visualization widget, for
     *             example a chart, pivot table, or narrative insight. Sheets can be associated with other
     *             components, such as controls, filters, and so on.</p>
     */
    interface DashboardSheet {
        /**
         * <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
         *             console.</p>
         */
        name?: string;
        /**
         * <p>The unique identifier associated with a sheet.</p>
         */
        sheetId?: string;
    }
    /**
     * <p>Sheet controls option.</p>
     */
    interface DashboardSheetControlsOption {
        visibilityState?: enums.quicksight.DashboardUIState;
    }
    /**
     * <p>Dashboard source entity.</p>
     */
    interface DashboardSourceEntity {
        sourceTemplate?: outputs.quicksight.DashboardSourceTemplate;
    }
    /**
     * <p>Dashboard source template.</p>
     */
    interface DashboardSourceTemplate {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn: string;
        /**
         * <p>Dataset references.</p>
         */
        dataSetReferences: outputs.quicksight.DashboardDataSetReference[];
    }
    /**
     * <p>A string parameter.</p>
     */
    interface DashboardStringParameter {
        /**
         * <p>A display name for a string parameter.</p>
         */
        name: string;
        /**
         * <p>The values of a string parameter.</p>
         */
        values: string[];
    }
    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    interface DashboardTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }
    /**
     * <p>Dashboard version.</p>
     */
    interface DashboardVersion {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn?: string;
        /**
         * <p>The time that this dashboard version was created.</p>
         */
        createdTime?: string;
        /**
         * <p>The Amazon Resource Numbers (ARNs) for the datasets that are associated with this
         *             version of the dashboard.</p>
         */
        dataSetArns?: string[];
        /**
         * <p>Description.</p>
         */
        description?: string;
        /**
         * <p>Errors associated with this dashboard version.</p>
         */
        errors?: outputs.quicksight.DashboardError[];
        /**
         * <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
         */
        sheets?: outputs.quicksight.DashboardSheet[];
        /**
         * <p>Source entity ARN.</p>
         */
        sourceEntityArn?: string;
        status?: enums.quicksight.DashboardResourceStatus;
        /**
         * <p>The ARN of the theme associated with a version of the dashboard.</p>
         */
        themeArn?: string;
        /**
         * <p>Version number for this version of the dashboard.</p>
         */
        versionNumber?: number;
    }
    /**
     * <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
     *             a variant type structure. For this structure to be valid, only one of the attributes can
     *             be non-null.</p>
     */
    interface DataSetColumnGroup {
        geoSpatialColumnGroup?: outputs.quicksight.DataSetGeoSpatialColumnGroup;
    }
    interface DataSetColumnLevelPermissionRule {
        columnNames?: string[];
        principals?: string[];
    }
    interface DataSetFieldFolderMap {
    }
    /**
     * <p>Geospatial column group that denotes a hierarchy.</p>
     */
    interface DataSetGeoSpatialColumnGroup {
        /**
         * <p>Columns in this hierarchy.</p>
         */
        columns: string[];
        countryCode?: enums.quicksight.DataSetGeoSpatialCountryCode;
        /**
         * <p>A display name for the hierarchy.</p>
         */
        name: string;
    }
    /**
     * <p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>
     */
    interface DataSetIngestionWaitPolicy {
        /**
         * <p>The maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.
         *  Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.</p>
         */
        ingestionWaitTimeInHours?: number;
        /**
         * <p>Wait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).
         *   Applicable only when DataSetImportMode mode is set to SPICE.</p>
         */
        waitForSpiceIngestion?: boolean;
    }
    interface DataSetLogicalTableMap {
    }
    /**
     * <p>Output column.</p>
     */
    interface DataSetOutputColumn {
        /**
         * <p>A description for a column.</p>
         */
        description?: string;
        /**
         * <p>A display name for the dataset.</p>
         */
        name?: string;
        type?: enums.quicksight.DataSetColumnDataType;
    }
    interface DataSetPhysicalTableMap {
    }
    /**
     * <p>Permission for the resource.</p>
     */
    interface DataSetResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }
    /**
     * <p>The row-level security configuration for the dataset.</p>
     */
    interface DataSetRowLevelPermissionDataSet {
        /**
         * <p>The Amazon Resource Name (ARN) of the permission dataset.</p>
         */
        arn: string;
        formatVersion?: enums.quicksight.DataSetRowLevelPermissionFormatVersion;
        /**
         * <p>The namespace associated with the row-level permissions dataset.</p>
         */
        namespace?: string;
        permissionPolicy: enums.quicksight.DataSetRowLevelPermissionPolicy;
    }
    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    interface DataSetTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }
    /**
     * <p>The dataset usage configuration for the dataset.</p>
     */
    interface DataSetUsageConfiguration {
        disableUseAsDirectQuerySource?: boolean;
        disableUseAsImportedSource?: boolean;
    }
    /**
     * <p>Amazon Elasticsearch Service parameters.</p>
     */
    interface DataSourceAmazonElasticsearchParameters {
        /**
         * <p>The Amazon Elasticsearch Service domain.</p>
         */
        domain: string;
    }
    /**
     * <p>Amazon OpenSearch Service parameters.</p>
     */
    interface DataSourceAmazonOpenSearchParameters {
        /**
         * <p>The Amazon OpenSearch Service domain.</p>
         */
        domain: string;
    }
    /**
     * <p>Amazon Athena parameters.</p>
     */
    interface DataSourceAthenaParameters {
        /**
         * <p>The workgroup that Amazon Athena uses.</p>
         */
        workGroup?: string;
    }
    /**
     * <p>Amazon Aurora parameters.</p>
     */
    interface DataSourceAuroraParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>Amazon Aurora with PostgreSQL compatibility parameters.</p>
     */
    interface DataSourceAuroraPostgreSqlParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>The combination of user name and password that are used as credentials.</p>
     */
    interface DataSourceCredentialPair {
        /**
         * <p>A set of alternate data source parameters that you want to share for these
         *             credentials. The credentials are applied in tandem with the data source parameters when
         *             you copy a data source by using a create or update request. The API operation compares
         *             the <code>DataSourceParameters</code> structure that's in the request with the
         *             structures in the <code>AlternateDataSourceParameters</code> allow list. If the
         *             structures are an exact match, the request is allowed to use the new data source with
         *             the existing credentials. If the <code>AlternateDataSourceParameters</code> list is
         *             null, the <code>DataSourceParameters</code> originally used with these
         *                 <code>Credentials</code> is automatically allowed.</p>
         */
        alternateDataSourceParameters?: outputs.quicksight.DataSourceParameters[];
        /**
         * <p>Password.</p>
         */
        password: string;
        /**
         * <p>User name.</p>
         */
        username: string;
    }
    /**
     * <p>Data source credentials. This is a variant type structure. For this structure to be
     *             valid, only one of the attributes can be non-null.</p>
     */
    interface DataSourceCredentials {
        /**
         * <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you
         *             want to use. When <code>CopySourceArn</code> is not null, the credential pair from the
         *             data source in the ARN is used as the credentials for the
         *             <code>DataSourceCredentials</code> structure.</p>
         */
        copySourceArn?: string;
        credentialPair?: outputs.quicksight.DataSourceCredentialPair;
        /**
         * <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
         */
        secretArn?: string;
    }
    /**
     * <p>Error information for the data source creation or update.</p>
     */
    interface DataSourceErrorInfo {
        /**
         * <p>Error message.</p>
         */
        message?: string;
        type?: enums.quicksight.DataSourceErrorInfoType;
    }
    /**
     * <p>Amazon S3 manifest file location.</p>
     */
    interface DataSourceManifestFileLocation {
        /**
         * <p>Amazon S3 bucket.</p>
         */
        bucket: string;
        /**
         * <p>Amazon S3 key that identifies an object.</p>
         */
        key: string;
    }
    /**
     * <p>MariaDB parameters.</p>
     */
    interface DataSourceMariaDbParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>MySQL parameters.</p>
     */
    interface DataSourceMySqlParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    interface DataSourceOracleParameters {
        database: string;
        host: string;
        port: number;
    }
    /**
     * <p>The parameters that Amazon QuickSight uses to connect to your underlying data source.
     *             This is a variant type structure. For this structure to be valid, only one of the
     *             attributes can be non-null.</p>
     */
    interface DataSourceParameters {
        amazonElasticsearchParameters?: outputs.quicksight.DataSourceAmazonElasticsearchParameters;
        amazonOpenSearchParameters?: outputs.quicksight.DataSourceAmazonOpenSearchParameters;
        athenaParameters?: outputs.quicksight.DataSourceAthenaParameters;
        auroraParameters?: outputs.quicksight.DataSourceAuroraParameters;
        auroraPostgreSqlParameters?: outputs.quicksight.DataSourceAuroraPostgreSqlParameters;
        mariaDbParameters?: outputs.quicksight.DataSourceMariaDbParameters;
        mySqlParameters?: outputs.quicksight.DataSourceMySqlParameters;
        oracleParameters?: outputs.quicksight.DataSourceOracleParameters;
        postgreSqlParameters?: outputs.quicksight.DataSourcePostgreSqlParameters;
        prestoParameters?: outputs.quicksight.DataSourcePrestoParameters;
        rdsParameters?: outputs.quicksight.DataSourceRdsParameters;
        redshiftParameters?: outputs.quicksight.DataSourceRedshiftParameters;
        s3Parameters?: outputs.quicksight.DataSourceS3Parameters;
        snowflakeParameters?: outputs.quicksight.DataSourceSnowflakeParameters;
        sparkParameters?: outputs.quicksight.DataSourceSparkParameters;
        sqlServerParameters?: outputs.quicksight.DataSourceSqlServerParameters;
        teradataParameters?: outputs.quicksight.DataSourceTeradataParameters;
    }
    /**
     * <p>PostgreSQL parameters.</p>
     */
    interface DataSourcePostgreSqlParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>Presto parameters.</p>
     */
    interface DataSourcePrestoParameters {
        /**
         * <p>Catalog.</p>
         */
        catalog: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>Amazon RDS parameters.</p>
     */
    interface DataSourceRdsParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Instance ID.</p>
         */
        instanceId: string;
    }
    /**
     * <p>Amazon Redshift parameters. The <code>ClusterId</code> field can be blank if
     *             <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and
     *             <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
     */
    interface DataSourceRedshiftParameters {
        /**
         * <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are
         *             provided.</p>
         */
        clusterId?: string;
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
         */
        host?: string;
        /**
         * <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
         */
        port?: number;
    }
    /**
     * <p>Permission for the resource.</p>
     */
    interface DataSourceResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }
    /**
     * <p>S3 parameters.</p>
     */
    interface DataSourceS3Parameters {
        manifestFileLocation: outputs.quicksight.DataSourceManifestFileLocation;
    }
    /**
     * <p>Snowflake parameters.</p>
     */
    interface DataSourceSnowflakeParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Warehouse.</p>
         */
        warehouse: string;
    }
    /**
     * <p>Spark parameters.</p>
     */
    interface DataSourceSparkParameters {
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>SQL Server parameters.</p>
     */
    interface DataSourceSqlServerParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
     *             underlying data source.</p>
     */
    interface DataSourceSslProperties {
        /**
         * <p>A Boolean option to control whether SSL should be disabled.</p>
         */
        disableSsl?: boolean;
    }
    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    interface DataSourceTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }
    /**
     * <p>Teradata parameters.</p>
     */
    interface DataSourceTeradataParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }
    /**
     * <p>VPC connection properties.</p>
     */
    interface DataSourceVpcConnectionProperties {
        /**
         * <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
         */
        vpcConnectionArn: string;
    }
    /**
     * <p>A structure describing the name, data type, and geographic role of the columns.</p>
     */
    interface TemplateColumnGroupColumnSchema {
        /**
         * <p>The name of the column group's column schema.</p>
         */
        name?: string;
    }
    /**
     * <p>The column group schema.</p>
     */
    interface TemplateColumnGroupSchema {
        /**
         * <p>A structure containing the list of schemas for column group columns.</p>
         */
        columnGroupColumnSchemaList?: outputs.quicksight.TemplateColumnGroupColumnSchema[];
        /**
         * <p>The name of the column group schema.</p>
         */
        name?: string;
    }
    /**
     * <p>The column schema.</p>
     */
    interface TemplateColumnSchema {
        /**
         * <p>The data type of the column schema.</p>
         */
        dataType?: string;
        /**
         * <p>The geographic role of the column schema.</p>
         */
        geographicRole?: string;
        /**
         * <p>The name of the column schema.</p>
         */
        name?: string;
    }
    /**
     * <p>Dataset configuration.</p>
     */
    interface TemplateDataSetConfiguration {
        /**
         * <p>A structure containing the list of column group schemas.</p>
         */
        columnGroupSchemaList?: outputs.quicksight.TemplateColumnGroupSchema[];
        dataSetSchema?: outputs.quicksight.TemplateDataSetSchema;
        /**
         * <p>Placeholder.</p>
         */
        placeholder?: string;
    }
    /**
     * <p>Dataset reference.</p>
     */
    interface TemplateDataSetReference {
        /**
         * <p>Dataset Amazon Resource Name (ARN).</p>
         */
        dataSetArn: string;
        /**
         * <p>Dataset placeholder.</p>
         */
        dataSetPlaceholder: string;
    }
    /**
     * <p>Dataset schema.</p>
     */
    interface TemplateDataSetSchema {
        /**
         * <p>A structure containing the list of column schemas.</p>
         */
        columnSchemaList?: outputs.quicksight.TemplateColumnSchema[];
    }
    /**
     * <p>List of errors that occurred when the template version creation failed.</p>
     */
    interface TemplateError {
        /**
         * <p>Description of the error type.</p>
         */
        message?: string;
        type?: enums.quicksight.TemplateErrorType;
    }
    /**
     * <p>Permission for the resource.</p>
     */
    interface TemplateResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }
    /**
     * <p>A <i>sheet</i>, which is an object that contains a set of visuals that
     *             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
     *             contains at least one sheet. Each sheet contains at least one visualization widget, for
     *             example a chart, pivot table, or narrative insight. Sheets can be associated with other
     *             components, such as controls, filters, and so on.</p>
     */
    interface TemplateSheet {
        /**
         * <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
         *             console.</p>
         */
        name?: string;
        /**
         * <p>The unique identifier associated with a sheet.</p>
         */
        sheetId?: string;
    }
    /**
     * <p>The source analysis of the template.</p>
     */
    interface TemplateSourceAnalysis {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn: string;
        /**
         * <p>A structure containing information about the dataset references used as placeholders
         *             in the template.</p>
         */
        dataSetReferences: outputs.quicksight.TemplateDataSetReference[];
    }
    /**
     * <p>The source entity of the template.</p>
     */
    interface TemplateSourceEntity {
        sourceAnalysis?: outputs.quicksight.TemplateSourceAnalysis;
        sourceTemplate?: outputs.quicksight.TemplateSourceTemplate;
    }
    /**
     * <p>The source template of the template.</p>
     */
    interface TemplateSourceTemplate {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn: string;
    }
    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    interface TemplateTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }
    /**
     * <p>A version of a template.</p>
     */
    interface TemplateVersion {
        /**
         * <p>The time that this template version was created.</p>
         */
        createdTime?: string;
        /**
         * <p>Schema of the dataset identified by the placeholder. Any dashboard created from this
         *             template should be bound to new datasets matching the same schema described through this
         *             API operation.</p>
         */
        dataSetConfigurations?: outputs.quicksight.TemplateDataSetConfiguration[];
        /**
         * <p>The description of the template.</p>
         */
        description?: string;
        /**
         * <p>Errors associated with this template version.</p>
         */
        errors?: outputs.quicksight.TemplateError[];
        /**
         * <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
         */
        sheets?: outputs.quicksight.TemplateSheet[];
        /**
         * <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this
         *             template.</p>
         */
        sourceEntityArn?: string;
        status?: enums.quicksight.TemplateResourceStatus;
        /**
         * <p>The ARN of the theme associated with this version of the template.</p>
         */
        themeArn?: string;
        /**
         * <p>The version number of the template version.</p>
         */
        versionNumber?: number;
    }
    /**
     * <p>The display options for tile borders for visuals.</p>
     */
    interface ThemeBorderStyle {
        /**
         * <p>The option to enable display of borders for visuals.</p>
         */
        show?: boolean;
    }
    /**
     * <p>The theme configuration. This configuration contains all of the display properties for
     *             a theme.</p>
     */
    interface ThemeConfiguration {
        dataColorPalette?: outputs.quicksight.ThemeDataColorPalette;
        sheet?: outputs.quicksight.ThemeSheetStyle;
        typography?: outputs.quicksight.ThemeTypography;
        uIColorPalette?: outputs.quicksight.ThemeUIColorPalette;
    }
    /**
     * <p>The theme colors that are used for data colors in charts. The colors description is a
     *             hexadecimal color code that consists of six alphanumerical characters, prefixed with
     *                 <code>#</code>, for example #37BFF5. </p>
     */
    interface ThemeDataColorPalette {
        /**
         * <p>The hexadecimal codes for the colors.</p>
         */
        colors?: string[];
        /**
         * <p>The hexadecimal code of a color that applies to charts where a lack of data is
         *             highlighted.</p>
         */
        emptyFillColor?: string;
        /**
         * <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
         */
        minMaxGradient?: string[];
    }
    /**
     * <p>Theme error.</p>
     */
    interface ThemeError {
        /**
         * <p>The error message.</p>
         */
        message?: string;
        type?: enums.quicksight.ThemeErrorType;
    }
    interface ThemeFont {
        fontFamily?: string;
    }
    /**
     * <p>The display options for gutter spacing between tiles on a sheet.</p>
     */
    interface ThemeGutterStyle {
        /**
         * <p>This Boolean value controls whether to display a gutter space between sheet tiles.
         *         </p>
         */
        show?: boolean;
    }
    /**
     * <p>The display options for margins around the outside edge of sheets.</p>
     */
    interface ThemeMarginStyle {
        /**
         * <p>This Boolean value controls whether to display sheet margins.</p>
         */
        show?: boolean;
    }
    /**
     * <p>Permission for the resource.</p>
     */
    interface ThemeResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }
    /**
     * <p>The theme display options for sheets. </p>
     */
    interface ThemeSheetStyle {
        tile?: outputs.quicksight.ThemeTileStyle;
        tileLayout?: outputs.quicksight.ThemeTileLayoutStyle;
    }
    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    interface ThemeTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }
    /**
     * <p>The display options for the layout of tiles on a sheet.</p>
     */
    interface ThemeTileLayoutStyle {
        gutter?: outputs.quicksight.ThemeGutterStyle;
        margin?: outputs.quicksight.ThemeMarginStyle;
    }
    /**
     * <p>Display options related to tiles on a sheet.</p>
     */
    interface ThemeTileStyle {
        border?: outputs.quicksight.ThemeBorderStyle;
    }
    /**
     * <p>The typeface for the theme.</p>
     */
    interface ThemeTypography {
        fontFamilies?: outputs.quicksight.ThemeFont[];
    }
    /**
     * <p>The theme colors that apply to UI and to charts, excluding data colors. The colors
     *             description is a hexadecimal color code that consists of six alphanumerical characters,
     *             prefixed with <code>#</code>, for example #37BFF5. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User
     *                 Guide.</i>
     *         </p>
     */
    interface ThemeUIColorPalette {
        /**
         * <p>This color is that applies to selected states and buttons.</p>
         */
        accent?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             accent color.</p>
         */
        accentForeground?: string;
        /**
         * <p>The color that applies to error messages.</p>
         */
        danger?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             error color.</p>
         */
        dangerForeground?: string;
        /**
         * <p>The color that applies to the names of fields that are identified as
         *             dimensions.</p>
         */
        dimension?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             dimension color.</p>
         */
        dimensionForeground?: string;
        /**
         * <p>The color that applies to the names of fields that are identified as measures.</p>
         */
        measure?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             measure color.</p>
         */
        measureForeground?: string;
        /**
         * <p>The background color that applies to visuals and other high emphasis UI.</p>
         */
        primaryBackground?: string;
        /**
         * <p>The color of text and other foreground elements that appear over the primary
         *             background regions, such as grid lines, borders, table banding, icons, and so on.</p>
         */
        primaryForeground?: string;
        /**
         * <p>The background color that applies to the sheet background and sheet controls.</p>
         */
        secondaryBackground?: string;
        /**
         * <p>The foreground color that applies to any sheet title, sheet control text, or UI that
         *             appears over the secondary background.</p>
         */
        secondaryForeground?: string;
        /**
         * <p>The color that applies to success messages, for example the check mark for a
         *             successful download.</p>
         */
        success?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             success color.</p>
         */
        successForeground?: string;
        /**
         * <p>This color that applies to warning and informational messages.</p>
         */
        warning?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             warning color.</p>
         */
        warningForeground?: string;
    }
    /**
     * <p>A version of a theme.</p>
     */
    interface ThemeVersion {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn?: string;
        /**
         * <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All
         *             themes initially inherit from a default QuickSight theme.</p>
         */
        baseThemeId?: string;
        configuration?: outputs.quicksight.ThemeConfiguration;
        /**
         * <p>The date and time that this theme version was created.</p>
         */
        createdTime?: string;
        /**
         * <p>The description of the theme.</p>
         */
        description?: string;
        /**
         * <p>Errors associated with the theme.</p>
         */
        errors?: outputs.quicksight.ThemeError[];
        status?: enums.quicksight.ThemeResourceStatus;
        /**
         * <p>The version number of the theme.</p>
         */
        versionNumber?: number;
    }
}
export declare namespace ram {
    interface ResourceShareTag {
        key: string;
        value: string;
    }
}
export declare namespace rds {
    interface DBClusterEndpoint {
        /**
         * The connection endpoint for the DB cluster.
         */
        address?: string;
        /**
         * The port number that will accept connections on this DB cluster.
         */
        port?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DBClusterParameterGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    interface DBClusterReadEndpoint {
        /**
         * The reader endpoint for the DB cluster.
         */
        address?: string;
    }
    /**
     * Describes an AWS Identity and Access Management (IAM) role that is associated with a DB cluster.
     */
    interface DBClusterRole {
        /**
         * The name of the feature associated with the AWS Identity and Access Management (IAM) role. For the list of supported feature names, see DBEngineVersion in the Amazon RDS API Reference.
         */
        featureName?: string;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
         */
        roleArn: string;
    }
    /**
     * The ScalingConfiguration property type specifies the scaling configuration of an Aurora Serverless DB cluster.
     */
    interface DBClusterScalingConfiguration {
        /**
         * A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections).
         */
        autoPause?: boolean;
        /**
         * The maximum capacity for an Aurora DB cluster in serverless DB engine mode.
         * For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
         * For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
         * The maximum capacity must be greater than or equal to the minimum capacity.
         */
        maxCapacity?: number;
        /**
         * The minimum capacity for an Aurora DB cluster in serverless DB engine mode.
         * For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
         * For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
         * The minimum capacity must be less than or equal to the maximum capacity.
         */
        minCapacity?: number;
        /**
         * The time, in seconds, before an Aurora DB cluster in serverless mode is paused.
         */
        secondsUntilAutoPause?: number;
        /**
         * The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.
         * ForceApplyCapacityChange sets the capacity to the specified value as soon as possible.
         * RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the timeout period.
         *
         * For more information, see Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
         */
        timeoutAction?: string;
    }
    /**
     * Contains the scaling configuration of an Aurora Serverless v2 DB cluster.
     */
    interface DBClusterServerlessV2ScalingConfiguration {
        /**
         * The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.
         */
        maxCapacity?: number;
        /**
         * The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.
         */
        minCapacity?: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DBClusterTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    interface DBInstanceEndpoint {
        /**
         * Specifies the DNS address of the DB instance.
         */
        address?: string;
        /**
         * Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
         */
        hostedZoneId?: string;
        /**
         * Specifies the port that the database engine is listening on.
         */
        port?: string;
    }
    interface DBInstanceProcessorFeature {
        /**
         * The name of the processor feature. Valid names are coreCount and threadsPerCore.
         */
        name?: enums.rds.DBInstanceProcessorFeatureName;
        /**
         * The value of a processor feature name.
         */
        value?: string;
    }
    interface DBInstanceRole {
        /**
         * The name of the feature associated with the AWS Identity and Access Management (IAM) role. IAM roles that are associated with a DB instance grant permission for the DB instance to access other AWS services on your behalf.
         */
        featureName: string;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.
         */
        roleArn: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DBInstanceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DBParameterGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    interface DBProxyAuthFormat {
        /**
         * The type of authentication that the proxy uses for connections from the proxy to the underlying database.
         */
        authScheme?: enums.rds.DBProxyAuthFormatAuthScheme;
        /**
         * A user-specified description about the authentication used by a proxy to log in as a specific database user.
         */
        description?: string;
        /**
         * Whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy. The ENABLED value is valid only for proxies with RDS for Microsoft SQL Server.
         */
        iAMAuth?: enums.rds.DBProxyAuthFormatIAMAuth;
        /**
         * The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
         */
        secretArn?: string;
        /**
         * The name of the database user to which the proxy connects.
         */
        userName?: string;
    }
    interface DBProxyEndpointTagFormat {
        key?: string;
        value?: string;
    }
    interface DBProxyTagFormat {
        key?: string;
        value?: string;
    }
    interface DBProxyTargetGroupConnectionPoolConfigurationInfoFormat {
        /**
         * The number of seconds for a proxy to wait for a connection to become available in the connection pool.
         */
        connectionBorrowTimeout?: number;
        /**
         * One or more SQL statements for the proxy to run when opening each new database connection.
         */
        initQuery?: string;
        /**
         * The maximum size of the connection pool for each target in a target group.
         */
        maxConnectionsPercent?: number;
        /**
         * Controls how actively the proxy closes idle database connections in the connection pool.
         */
        maxIdleConnectionsPercent?: number;
        /**
         * Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection.
         */
        sessionPinningFilters?: string[];
    }
    interface DBSecurityGroupIngress {
        cIDRIP?: string;
        eC2SecurityGroupId?: string;
        eC2SecurityGroupName?: string;
        eC2SecurityGroupOwnerId?: string;
    }
    interface DBSecurityGroupTag {
        key: string;
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DBSubnetGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface EventSubscriptionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
    /**
     * The OptionConfiguration property type specifies an individual option, and its settings, within an AWS::RDS::OptionGroup resource.
     */
    interface OptionGroupOptionConfiguration {
        /**
         * A list of DBSecurityGroupMembership name strings used for this option.
         */
        dBSecurityGroupMemberships?: string[];
        /**
         * The configuration of options to include in a group.
         */
        optionName: string;
        /**
         * The option settings to include in an option group.
         */
        optionSettings?: outputs.rds.OptionGroupOptionSetting[];
        /**
         * The version for the option.
         */
        optionVersion?: string;
        /**
         * The optional port for the option.
         */
        port?: number;
        /**
         * A list of VpcSecurityGroupMembership name strings used for this option.
         */
        vpcSecurityGroupMemberships?: string[];
    }
    /**
     * The OptionSetting property type specifies the value for an option within an OptionSetting property.
     */
    interface OptionGroupOptionSetting {
        /**
         * The name of the option that has settings that you can set.
         */
        name?: string;
        /**
         * The current value of the option setting.
         */
        value?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface OptionGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }
}
export declare namespace redshift {
    interface ClusterEndpoint {
        address?: string;
        port?: string;
    }
    interface ClusterLoggingProperties {
        bucketName: string;
        s3KeyPrefix?: string;
    }
    interface ClusterParameterGroupParameter {
        /**
         * The name of the parameter.
         */
        parameterName: string;
        /**
         * The value of the parameter. If `ParameterName` is `wlm_json_configuration`, then the maximum size of `ParameterValue` is 8000 characters.
         */
        parameterValue: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ClusterParameterGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ClusterSecurityGroupTag {
        key: string;
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ClusterSubnetGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ClusterTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Describes a network interface.
     */
    interface EndpointAccessNetworkInterface {
        /**
         * The Availability Zone.
         */
        availabilityZone?: string;
        /**
         * The network interface identifier.
         */
        networkInterfaceId?: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress?: string;
        /**
         * The subnet identifier.
         */
        subnetId?: string;
    }
    /**
     * Describes the members of a VPC security group.
     */
    interface EndpointAccessVpcSecurityGroup {
        /**
         * The status of the VPC security group.
         */
        status?: string;
        /**
         * The identifier of the VPC security group.
         */
        vpcSecurityGroupId?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface EventSubscriptionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ScheduledActionType {
    }
    /**
     * The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.
     */
    interface VpcEndpointProperties {
        /**
         * One or more network interfaces of the endpoint. Also known as an interface endpoint.
         */
        networkInterfaces?: outputs.redshift.EndpointAccessNetworkInterface[];
        /**
         * The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.
         */
        vpcEndpointId?: string;
        /**
         * The VPC identifier that the endpoint is associated.
         */
        vpcId?: string;
    }
}
export declare namespace redshiftserverless {
    interface Namespace {
        adminUsername?: string;
        creationDate?: string;
        dbName?: string;
        defaultIamRoleArn?: string;
        iamRoles?: string[];
        kmsKeyId?: string;
        logExports?: enums.redshiftserverless.NamespaceLogExport[];
        namespaceArn?: string;
        namespaceId?: string;
        namespaceName?: string;
        status?: enums.redshiftserverless.NamespaceStatus;
    }
    interface NamespaceTag {
        key: string;
        value: string;
    }
    interface Workgroup {
        baseCapacity?: number;
        configParameters?: outputs.redshiftserverless.WorkgroupConfigParameter[];
        creationDate?: string;
        endpoint?: outputs.redshiftserverless.WorkgroupEndpoint;
        enhancedVpcRouting?: boolean;
        namespaceName?: string;
        publiclyAccessible?: boolean;
        securityGroupIds?: string[];
        status?: enums.redshiftserverless.WorkgroupStatus;
        subnetIds?: string[];
        workgroupArn?: string;
        workgroupId?: string;
        workgroupName?: string;
    }
    interface WorkgroupConfigParameter {
        parameterKey?: string;
        parameterValue?: string;
    }
    interface WorkgroupEndpoint {
        address?: string;
        port?: number;
        vpcEndpoints?: outputs.redshiftserverless.WorkgroupVpcEndpoint[];
    }
    interface WorkgroupNetworkInterface {
        availabilityZone?: string;
        networkInterfaceId?: string;
        privateIpAddress?: string;
        subnetId?: string;
    }
    interface WorkgroupTag {
        key: string;
        value: string;
    }
    interface WorkgroupVpcEndpoint {
        networkInterfaces?: outputs.redshiftserverless.WorkgroupNetworkInterface[];
        vpcEndpointId?: string;
        vpcId?: string;
    }
}
export declare namespace refactorspaces {
    interface ApplicationApiGatewayProxyInput {
        endpointType?: enums.refactorspaces.ApplicationApiGatewayEndpointType;
        stageName?: string;
    }
    /**
     * A label for tagging Environment resource
     */
    interface ApplicationTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    /**
     * A label for tagging Environment resource
     */
    interface EnvironmentTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface RouteDefaultRouteInput {
        activationState: enums.refactorspaces.RouteActivationState;
    }
    /**
     * A label for tagging Environment resource
     */
    interface RouteTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface RouteUriPathRouteInput {
        activationState: enums.refactorspaces.RouteActivationState;
        includeChildPaths?: boolean;
        methods?: enums.refactorspaces.RouteMethod[];
        sourcePath?: string;
    }
    interface ServiceLambdaEndpointInput {
        arn: string;
    }
    /**
     * A label for tagging Environment resource
     */
    interface ServiceTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }
    interface ServiceUrlEndpointInput {
        healthUrl?: string;
        url: string;
    }
}
export declare namespace rekognition {
    /**
     * A key-value pair to associate with a resource.
     */
    interface CollectionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A bounding box denoting a region of interest in the frame to be analyzed.
     */
    interface StreamProcessorBoundingBox {
        height: number;
        left: number;
        top: number;
        width: number;
    }
    /**
     * Connected home settings to use on a streaming video. Note that either ConnectedHomeSettings or FaceSearchSettings should be set. Not both
     */
    interface StreamProcessorConnectedHomeSettings {
        labels: string[];
        /**
         * Minimum object class match confidence score that must be met to return a result for a recognized object.
         */
        minConfidence?: number;
    }
    /**
     * Indicates whether Rekognition is allowed to store the video stream data for model-training.
     */
    interface StreamProcessorDataSharingPreference {
        /**
         * Flag to enable data-sharing
         */
        optIn: boolean;
    }
    /**
     * Face search settings to use on a streaming video. Note that either FaceSearchSettings or ConnectedHomeSettings should be set. Not both
     */
    interface StreamProcessorFaceSearchSettings {
        /**
         * The ID of a collection that contains faces that you want to search for.
         */
        collectionId: string;
        /**
         * Minimum face match confidence score percentage that must be met to return a result for a recognized face. The default is 80. 0 is the lowest confidence. 100 is the highest confidence. Values between 0 and 100 are accepted.
         */
        faceMatchThreshold?: number;
    }
    /**
     * The Amazon Kinesis Data Stream stream to which the Amazon Rekognition stream processor streams the analysis results, as part of face search feature.
     */
    interface StreamProcessorKinesisDataStream {
        /**
         * ARN of the Kinesis Data Stream stream.
         */
        arn: string;
    }
    /**
     * The Kinesis Video Stream that streams the source video.
     */
    interface StreamProcessorKinesisVideoStream {
        /**
         * ARN of the Kinesis Video Stream that streams the source video.
         */
        arn: string;
    }
    /**
     * The ARN of the SNS notification channel where events of interests are published, as part of connected home feature.
     */
    interface StreamProcessorNotificationChannel {
        /**
         * ARN of the SNS topic.
         */
        arn: string;
    }
    /**
     * An (X, Y) cartesian coordinate denoting a point on the frame
     */
    interface StreamProcessorPoint {
        /**
         * The X coordinate of the point.
         */
        x: number;
        /**
         * The Y coordinate of the point.
         */
        y: number;
    }
    /**
     * The S3 location in customer's account where inference output & artifacts are stored, as part of connected home feature.
     */
    interface StreamProcessorS3Destination {
        /**
         * Name of the S3 bucket.
         */
        bucketName: string;
        /**
         * The object key prefix path where the results will be stored. Default is no prefix path
         */
        objectKeyPrefix?: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface StreamProcessorTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace resiliencehub {
    interface AppPhysicalResourceId {
        awsAccountId?: string;
        awsRegion?: string;
        identifier: string;
        type: string;
    }
    /**
     * Resource mapping is used to map logical resources from template to physical resource
     */
    interface AppResourceMapping {
        logicalStackName?: string;
        mappingType: string;
        physicalResourceId: outputs.resiliencehub.AppPhysicalResourceId;
        resourceName?: string;
        terraformSourceName?: string;
    }
    interface AppTagMap {
    }
    interface ResiliencyPolicyPolicyMap {
    }
    interface ResiliencyPolicyTagMap {
    }
}
export declare namespace resourcegroups {
    interface GroupConfigurationItem {
        parameters?: outputs.resourcegroups.GroupConfigurationParameter[];
        type?: string;
    }
    interface GroupConfigurationParameter {
        name?: string;
        values?: string[];
    }
    interface GroupQuery {
        resourceTypeFilters?: string[];
        stackIdentifier?: string;
        tagFilters?: outputs.resourcegroups.GroupTagFilter[];
    }
    interface GroupResourceQuery {
        query?: outputs.resourcegroups.GroupQuery;
        type?: enums.resourcegroups.GroupResourceQueryType;
    }
    interface GroupTag {
        key?: string;
        value?: string;
    }
    interface GroupTagFilter {
        key?: string;
        values?: string[];
    }
}
export declare namespace robomaker {
    /**
     * A key-value pair to associate with a resource.
     */
    interface FleetTags {
    }
    /**
     * The robot software suite used by the robot application.
     */
    interface RobotApplicationRobotSoftwareSuite {
        /**
         * The name of robot software suite.
         */
        name: enums.robomaker.RobotApplicationRobotSoftwareSuiteName;
        /**
         * The version of robot software suite.
         */
        version?: enums.robomaker.RobotApplicationRobotSoftwareSuiteVersion;
    }
    interface RobotApplicationSourceConfig {
        /**
         * The architecture of robot application.
         */
        architecture: enums.robomaker.RobotApplicationSourceConfigArchitecture;
        /**
         * The Arn of the S3Bucket that stores the robot application source.
         */
        s3Bucket: string;
        /**
         * The s3 key of robot application source.
         */
        s3Key: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface RobotApplicationTags {
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface RobotTags {
    }
    /**
     * Information about a rendering engine.
     */
    interface SimulationApplicationRenderingEngine {
        /**
         * The name of the rendering engine.
         */
        name: enums.robomaker.SimulationApplicationRenderingEngineName;
        /**
         * The version of the rendering engine.
         */
        version: string;
    }
    /**
     * Information about a robot software suite.
     */
    interface SimulationApplicationRobotSoftwareSuite {
        /**
         * The name of the robot software suite.
         */
        name: enums.robomaker.SimulationApplicationRobotSoftwareSuiteName;
        /**
         * The version of the robot software suite.
         */
        version?: enums.robomaker.SimulationApplicationRobotSoftwareSuiteVersion;
    }
    /**
     * Information about a simulation software suite.
     */
    interface SimulationApplicationSimulationSoftwareSuite {
        /**
         * The name of the simulation software suite.
         */
        name: enums.robomaker.SimulationApplicationSimulationSoftwareSuiteName;
        /**
         * The version of the simulation software suite.
         */
        version?: enums.robomaker.SimulationApplicationSimulationSoftwareSuiteVersion;
    }
    /**
     * Information about a source configuration.
     */
    interface SimulationApplicationSourceConfig {
        /**
         * The target processor architecture for the application.
         */
        architecture: enums.robomaker.SimulationApplicationSourceConfigArchitecture;
        /**
         * The Amazon S3 bucket name.
         */
        s3Bucket: string;
        /**
         * The s3 object key.
         */
        s3Key: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface SimulationApplicationTags {
    }
}
export declare namespace rolesanywhere {
    interface CRLTag {
        key: string;
        value: string;
    }
    interface ProfileTag {
        key: string;
        value: string;
    }
    interface TrustAnchorSource {
        sourceData?: outputs.rolesanywhere.TrustAnchorSourceData;
        sourceType?: enums.rolesanywhere.TrustAnchorType;
    }
    interface TrustAnchorSourceData {
    }
    interface TrustAnchorTag {
        key: string;
        value: string;
    }
}
export declare namespace route53 {
    interface CidrCollectionLocation {
        /**
         * A list of CIDR blocks.
         */
        cidrList: string[];
        /**
         * The name of the location that is associated with the CIDR collection.
         */
        locationName: string;
    }
    /**
     * A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
     */
    interface HealthCheckAlarmIdentifier {
        /**
         * The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
         */
        name: string;
        /**
         * For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
         */
        region: string;
    }
    /**
     * A complex type that contains information about the health check.
     */
    interface HealthCheckConfigProperties {
        alarmIdentifier?: outputs.route53.HealthCheckAlarmIdentifier;
        childHealthChecks?: string[];
        enableSNI?: boolean;
        failureThreshold?: number;
        fullyQualifiedDomainName?: string;
        healthThreshold?: number;
        iPAddress?: string;
        insufficientDataHealthStatus?: enums.route53.HealthCheckConfigPropertiesInsufficientDataHealthStatus;
        inverted?: boolean;
        measureLatency?: boolean;
        port?: number;
        regions?: string[];
        requestInterval?: number;
        resourcePath?: string;
        routingControlArn?: string;
        searchString?: string;
        type: enums.route53.HealthCheckConfigPropertiesType;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface HealthCheckTag {
        /**
         * The key name of the tag.
         */
        key: string;
        /**
         * The value for the tag.
         */
        value: string;
    }
    /**
     * A complex type that contains an optional comment.
     *
     * If you don't want to specify a comment, omit the HostedZoneConfig and Comment elements.
     */
    interface HostedZoneConfig {
        /**
         * Any comments that you want to include about the hosted zone.
         */
        comment?: string;
    }
    /**
     * A complex type that contains information about a configuration for DNS query logging.
     */
    interface HostedZoneQueryLoggingConfig {
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
         */
        cloudWatchLogsLogGroupArn: string;
    }
    /**
     * A complex type that contains information about a tag that you want to add or edit for the specified health check or hosted zone.
     */
    interface HostedZoneTag {
        /**
         * The key name of the tag.
         */
        key: string;
        /**
         * The value for the tag.
         */
        value: string;
    }
    /**
     * A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
     */
    interface HostedZoneVPC {
        /**
         * The ID of an Amazon VPC.
         */
        vPCId: string;
        /**
         * The region that an Amazon VPC was created in. See https://docs.aws.amazon.com/general/latest/gr/rande.html for a list of up to date regions.
         */
        vPCRegion: string;
    }
    interface RecordSetAliasTarget {
        dNSName: string;
        evaluateTargetHealth?: boolean;
        hostedZoneId: string;
    }
    interface RecordSetCidrRoutingConfig {
        collectionId: string;
        locationName: string;
    }
    interface RecordSetGeoLocation {
        continentCode?: string;
        countryCode?: string;
        subdivisionCode?: string;
    }
    interface RecordSetGroupAliasTarget {
        dNSName: string;
        evaluateTargetHealth?: boolean;
        hostedZoneId: string;
    }
    interface RecordSetGroupCidrRoutingConfig {
        collectionId: string;
        locationName: string;
    }
    interface RecordSetGroupGeoLocation {
        continentCode?: string;
        countryCode?: string;
        subdivisionCode?: string;
    }
    interface RecordSetGroupRecordSet {
        aliasTarget?: outputs.route53.RecordSetGroupAliasTarget;
        cidrRoutingConfig?: outputs.route53.RecordSetGroupCidrRoutingConfig;
        failover?: string;
        geoLocation?: outputs.route53.RecordSetGroupGeoLocation;
        healthCheckId?: string;
        hostedZoneId?: string;
        hostedZoneName?: string;
        multiValueAnswer?: boolean;
        name: string;
        region?: string;
        resourceRecords?: string[];
        setIdentifier?: string;
        tTL?: string;
        type: string;
        weight?: number;
    }
}
export declare namespace route53recoverycontrol {
    interface ClusterEndpoint {
        endpoint?: string;
        region?: string;
    }
    interface ClusterTag {
        key: string;
        value: string;
    }
    interface ControlPanelTag {
        key: string;
        value: string;
    }
    /**
     * An assertion rule enforces that, when a routing control state is changed, that the criteria set by the rule configuration is met. Otherwise, the change to the routing control is not accepted.
     */
    interface SafetyRuleAssertionRule {
        /**
         * The routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed. For example, you might include three routing controls, one for each of three AWS Regions.
         */
        assertedControls: string[];
        /**
         * An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
         */
        waitPeriodMs: number;
    }
    /**
     * A gating rule verifies that a set of gating controls evaluates as true, based on a rule configuration that you specify. If the gating rule evaluates to true, Amazon Route 53 Application Recovery Controller allows a set of routing control state changes to run and complete against the set of target controls.
     */
    interface SafetyRuleGatingRule {
        /**
         * The gating controls for the gating rule. That is, routing controls that are evaluated by the rule configuration that you specify.
         */
        gatingControls: string[];
        /**
         * Routing controls that can only be set or unset if the specified RuleConfig evaluates to true for the specified GatingControls. For example, say you have three gating controls, one for each of three AWS Regions. Now you specify AtLeast 2 as your RuleConfig. With these settings, you can only change (set or unset) the routing controls that you have specified as TargetControls if that rule evaluates to true.
         * In other words, your ability to change the routing controls that you have specified as TargetControls is gated by the rule that you set for the routing controls in GatingControls.
         */
        targetControls: string[];
        /**
         * An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
         */
        waitPeriodMs: number;
    }
    /**
     * The rule configuration for an assertion rule or gating rule. This is the criteria that you set for specific assertion controls (routing controls) or gating controls. This configuration specifies how many controls must be enabled after a transaction completes.
     */
    interface SafetyRuleRuleConfig {
        /**
         * Logical negation of the rule. If the rule would usually evaluate true, it's evaluated as false, and vice versa.
         */
        inverted: boolean;
        /**
         * The value of N, when you specify an ATLEAST rule type. That is, Threshold is the number of controls that must be set when you specify an ATLEAST type.
         */
        threshold: number;
        type: enums.route53recoverycontrol.SafetyRuleRuleType;
    }
    interface SafetyRuleTag {
        key: string;
        value: string;
    }
}
export declare namespace route53recoveryreadiness {
    interface CellTag {
        key: string;
        value: string;
    }
    interface ReadinessCheckTag {
        key: string;
        value: string;
    }
    interface RecoveryGroupTag {
        key: string;
        value: string;
    }
    /**
     * A component for DNS/routing control readiness checks.
     */
    interface ResourceSetDNSTargetResource {
        /**
         * The domain name that acts as an ingress point to a portion of the customer application.
         */
        domainName?: string;
        /**
         * The hosted zone Amazon Resource Name (ARN) that contains the DNS record with the provided name of the target resource.
         */
        hostedZoneArn?: string;
        /**
         * The Route 53 record set ID that will uniquely identify a DNS record, given a name and a type.
         */
        recordSetId?: string;
        /**
         * The type of DNS record of the target resource.
         */
        recordType?: string;
        targetResource?: outputs.route53recoveryreadiness.ResourceSetTargetResource;
    }
    /**
     * The Network Load Balancer resource that a DNS target resource points to.
     */
    interface ResourceSetNLBResource {
        /**
         * A Network Load Balancer resource Amazon Resource Name (ARN).
         */
        arn?: string;
    }
    /**
     * The Route 53 resource that a DNS target resource record points to.
     */
    interface ResourceSetR53ResourceRecord {
        /**
         * The DNS target domain name.
         */
        domainName?: string;
        /**
         * The Resource Record set id.
         */
        recordSetId?: string;
    }
    /**
     * The resource element of a ResourceSet
     */
    interface ResourceSetResource {
        /**
         * The component identifier of the resource, generated when DNS target resource is used.
         */
        componentId?: string;
        dnsTargetResource?: outputs.route53recoveryreadiness.ResourceSetDNSTargetResource;
        /**
         * A list of recovery group Amazon Resource Names (ARNs) and cell ARNs that this resource is contained within.
         */
        readinessScopes?: string[];
        /**
         * The Amazon Resource Name (ARN) of the AWS resource.
         */
        resourceArn?: string;
    }
    interface ResourceSetTag {
        key: string;
        value: string;
    }
    /**
     * The target resource that the Route 53 record points to.
     */
    interface ResourceSetTargetResource {
        nLBResource?: outputs.route53recoveryreadiness.ResourceSetNLBResource;
        r53Resource?: outputs.route53recoveryreadiness.ResourceSetR53ResourceRecord;
    }
}
export declare namespace route53resolver {
    /**
     * A key-value pair to associate with a resource.
     */
    interface FirewallDomainListTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface FirewallRuleGroupAssociationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Firewall Rule associating the Rule Group to a Domain List
     */
    interface FirewallRuleGroupFirewallRule {
        /**
         * Rule Action
         */
        action: enums.route53resolver.FirewallRuleGroupFirewallRuleAction;
        /**
         * BlockOverrideDnsType
         */
        blockOverrideDnsType?: enums.route53resolver.FirewallRuleGroupFirewallRuleBlockOverrideDnsType;
        /**
         * BlockOverrideDomain
         */
        blockOverrideDomain?: string;
        /**
         * BlockOverrideTtl
         */
        blockOverrideTtl?: number;
        /**
         * BlockResponse
         */
        blockResponse?: enums.route53resolver.FirewallRuleGroupFirewallRuleBlockResponse;
        /**
         * ResourceId
         */
        firewallDomainListId: string;
        /**
         * Rule Priority
         */
        priority: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface FirewallRuleGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ResolverEndpointIpAddressRequest {
        ip?: string;
        subnetId: string;
    }
    interface ResolverEndpointTag {
        key: string;
        value: string;
    }
    interface ResolverRuleTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface ResolverRuleTargetAddress {
        /**
         * One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses.
         */
        ip: string;
        /**
         * The port at Ip that you want to forward DNS queries to.
         */
        port?: string;
    }
}
export declare namespace rum {
    /**
     * AppMonitor configuration
     */
    interface AppMonitorConfiguration {
        /**
         * If you set this to true, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
         */
        allowCookies?: boolean;
        /**
         * If you set this to true, RUM enables xray tracing for the user sessions that RUM samples. RUM adds an xray trace header to allowed HTTP requests. It also records an xray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the xray console and the CW ServiceLens console.
         */
        enableXRay?: boolean;
        /**
         * A list of URLs in your website or application to exclude from RUM data collection. You can't include both ExcludedPages and IncludedPages in the same operation.
         */
        excludedPages?: string[];
        /**
         * A list of pages in the RUM console that are to be displayed with a favorite icon.
         */
        favoritePages?: string[];
        /**
         * The ARN of the guest IAM role that is attached to the identity pool that is used to authorize the sending of data to RUM.
         */
        guestRoleArn?: string;
        /**
         * The ID of the identity pool that is used to authorize the sending of data to RUM.
         */
        identityPoolId?: string;
        /**
         * If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. You can't include both ExcludedPages and IncludedPages in the same operation.
         */
        includedPages?: string[];
        /**
         * An array of structures which define the destinations and the metrics that you want to send.
         */
        metricDestinations?: outputs.rum.AppMonitorMetricDestination[];
        /**
         * Specifies the percentage of user sessions to use for RUM data collection. Choosing a higher percentage gives you more data but also incurs more costs. The number you specify is the percentage of user sessions that will be used. If you omit this parameter, the default of 10 is used.
         */
        sessionSampleRate?: number;
        /**
         * An array that lists the types of telemetry data that this app monitor is to collect.
         */
        telemetries?: enums.rum.AppMonitorTelemetry[];
    }
    /**
     * A single metric definition
     */
    interface AppMonitorMetricDefinition {
        /**
         * Use this field only if you are sending the metric to CloudWatch.
         *
         * This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:
         *
         * "metadata.pageId": "PageId"
         *
         * "metadata.browserName": "BrowserName"
         *
         * "metadata.deviceType": "DeviceType"
         *
         * "metadata.osName": "OSName"
         *
         * "metadata.countryCode": "CountryCode"
         *
         * "event_details.fileType": "FileType"
         *
         * All dimensions listed in this field must also be included in EventPattern.
         */
        dimensionKeys?: any;
        /**
         * The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.
         *
         * When you define extended metrics, the metric definition is not valid if EventPattern is omitted.
         *
         * Example event patterns:
         *
         * '{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'
         *
         * '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "<", 2000 ] }] } }'
         *
         * '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ ">=", 2000, "<", 8000 ] }] } }'
         *
         * If the metrics destination' is CloudWatch and the event also matches a value in DimensionKeys, then the metric is published with the specified dimensions.
         */
        eventPattern?: string;
        /**
         * The name for the metric that is defined in this structure. Valid values are the following:
         *
         * PerformanceNavigationDuration
         *
         * PerformanceResourceDuration
         *
         * NavigationSatisfiedTransaction
         *
         * NavigationToleratedTransaction
         *
         * NavigationFrustratedTransaction
         *
         * WebVitalsCumulativeLayoutShift
         *
         * WebVitalsFirstInputDelay
         *
         * WebVitalsLargestContentfulPaint
         *
         * JsErrorCount
         *
         * HttpErrorCount
         *
         * SessionCount
         */
        name: string;
        /**
         * The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.
         */
        unitLabel?: string;
        /**
         * The field within the event object that the metric value is sourced from.
         *
         * If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches.
         *
         * If this metric is sent to Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.
         */
        valueKey?: string;
    }
    /**
     * An structure which defines the destination and the metrics that you want to send.
     */
    interface AppMonitorMetricDestination {
        /**
         * Defines the destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the Evidently experiment that is to be the destination and an IAM role that has permission to write to the experiment.
         */
        destination: enums.rum.AppMonitorMetricDestinationDestination;
        /**
         * Use this parameter only if Destination is Evidently. This parameter specifies the ARN of the Evidently experiment that will receive the extended metrics.
         */
        destinationArn?: string;
        /**
         * This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter.
         *
         * This parameter specifies the ARN of an IAM role that RUM will assume to write to the Evidently experiment that you are sending metrics to. This role must have permission to write to that experiment.
         */
        iamRoleArn?: string;
        /**
         * An array of structures which define the metrics that you want to send.
         */
        metricDefinitions?: outputs.rum.AppMonitorMetricDefinition[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface AppMonitorTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace s3 {
    interface AccessPointPublicAccessBlockConfiguration {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: boolean;
    }
    /**
     * The Virtual Private Cloud (VPC) configuration for a bucket access point.
     */
    interface AccessPointVpcConfiguration {
        /**
         * If this field is specified, this access point will only allow connections from the specified VPC ID.
         */
        vpcId?: string;
    }
    /**
     * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload.
     */
    interface BucketAbortIncompleteMultipartUpload {
        /**
         * Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload.
         */
        daysAfterInitiation: number;
    }
    interface BucketAccelerateConfiguration {
        /**
         * Configures the transfer acceleration state for an Amazon S3 bucket.
         */
        accelerationStatus: enums.s3.BucketAccelerateConfigurationAccelerationStatus;
    }
    /**
     * Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
     */
    interface BucketAccessControlTranslation {
        owner: string;
    }
    /**
     * Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
     */
    interface BucketAnalyticsConfiguration {
        /**
         * The ID that identifies the analytics configuration.
         */
        id: string;
        /**
         * The prefix that an object must have to be included in the analytics results.
         */
        prefix?: string;
        storageClassAnalysis: outputs.s3.BucketStorageClassAnalysis;
        tagFilters?: outputs.s3.BucketTagFilter[];
    }
    interface BucketCorsConfiguration {
        corsRules: outputs.s3.BucketCorsRule[];
    }
    /**
     * A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
     */
    interface BucketCorsRule {
        /**
         * Headers that are specified in the Access-Control-Request-Headers header.
         */
        allowedHeaders?: string[];
        /**
         * An HTTP method that you allow the origin to execute.
         */
        allowedMethods: enums.s3.BucketCorsRuleAllowedMethodsItem[];
        /**
         * One or more origins you want customers to be able to access the bucket from.
         */
        allowedOrigins: string[];
        /**
         * One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
         */
        exposedHeaders?: string[];
        /**
         * A unique identifier for this rule.
         */
        id?: string;
        /**
         * The time in seconds that your browser is to cache the preflight response for the specified resource.
         */
        maxAge?: number;
    }
    /**
     * Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
     */
    interface BucketDataExport {
        destination: outputs.s3.BucketDestination;
        /**
         * The version of the output schema to use when exporting data.
         */
        outputSchemaVersion: string;
    }
    /**
     * The default retention period that you want to apply to new objects placed in the specified bucket.
     */
    interface BucketDefaultRetention {
        days?: number;
        mode?: enums.s3.BucketDefaultRetentionMode;
        years?: number;
    }
    interface BucketDeleteMarkerReplication {
        status?: enums.s3.BucketDeleteMarkerReplicationStatus;
    }
    /**
     * Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).
     */
    interface BucketDestination {
        /**
         * The account ID that owns the destination S3 bucket.
         */
        bucketAccountId?: string;
        /**
         * The Amazon Resource Name (ARN) of the bucket to which data is exported.
         */
        bucketArn: string;
        /**
         * Specifies the file format used when exporting data to Amazon S3.
         */
        format: enums.s3.BucketDestinationFormat;
        /**
         * The prefix to use when exporting data. The prefix is prepended to all results.
         */
        prefix?: string;
    }
    /**
     * Specifies default encryption for a bucket using server-side encryption with either Amazon S3-managed keys (SSE-S3) or AWS KMS-managed keys (SSE-KMS).
     */
    interface BucketEncryption {
        /**
         * Specifies the default server-side-encryption configuration.
         */
        serverSideEncryptionConfiguration: outputs.s3.BucketServerSideEncryptionRule[];
    }
    /**
     * Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
     */
    interface BucketEncryptionConfiguration {
        /**
         * Specifies the ID (Key ARN or Alias ARN) of the customer managed customer master key (CMK) stored in AWS Key Management Service (KMS) for the destination bucket.
         */
        replicaKmsKeyID: string;
    }
    /**
     * Describes the Amazon EventBridge notification configuration for an Amazon S3 bucket.
     */
    interface BucketEventBridgeConfiguration {
        /**
         * Specifies whether to send notifications to Amazon EventBridge when events occur in an Amazon S3 bucket.
         */
        eventBridgeEnabled: boolean;
    }
    /**
     * Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
     */
    interface BucketFilterRule {
        name: string;
        value: string;
    }
    interface BucketIntelligentTieringConfiguration {
        /**
         * The ID used to identify the S3 Intelligent-Tiering configuration.
         */
        id: string;
        /**
         * An object key name prefix that identifies the subset of objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Specifies the status of the configuration.
         */
        status: enums.s3.BucketIntelligentTieringConfigurationStatus;
        /**
         * A container for a key-value pair.
         */
        tagFilters?: outputs.s3.BucketTagFilter[];
        /**
         * Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration. At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: ARCHIVE_ACCESS and DEEP_ARCHIVE_ACCESS.
         */
        tierings: outputs.s3.BucketTiering[];
    }
    interface BucketInventoryConfiguration {
        destination: outputs.s3.BucketDestination;
        /**
         * Specifies whether the inventory is enabled or disabled.
         */
        enabled: boolean;
        /**
         * The ID used to identify the inventory configuration.
         */
        id: string;
        /**
         * Object versions to include in the inventory list.
         */
        includedObjectVersions: enums.s3.BucketInventoryConfigurationIncludedObjectVersions;
        /**
         * Contains the optional fields that are included in the inventory results.
         */
        optionalFields?: enums.s3.BucketInventoryConfigurationOptionalFieldsItem[];
        /**
         * The prefix that is prepended to all inventory results.
         */
        prefix?: string;
        /**
         * Specifies the schedule for generating inventory results.
         */
        scheduleFrequency: enums.s3.BucketInventoryConfigurationScheduleFrequency;
    }
    /**
     * Describes the AWS Lambda functions to invoke and the events for which to invoke them.
     */
    interface BucketLambdaConfiguration {
        /**
         * The Amazon S3 bucket event for which to invoke the AWS Lambda function.
         */
        event: string;
        /**
         * The filtering rules that determine which objects invoke the AWS Lambda function.
         */
        filter?: outputs.s3.BucketNotificationFilter;
        /**
         * The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the specified event type occurs.
         */
        function: string;
    }
    interface BucketLifecycleConfiguration {
        /**
         * A lifecycle rule for individual objects in an Amazon S3 bucket.
         */
        rules: outputs.s3.BucketRule[];
    }
    interface BucketLoggingConfiguration {
        /**
         * The name of an Amazon S3 bucket where Amazon S3 store server access log files. You can store log files in any bucket that you own. By default, logs are stored in the bucket where the LoggingConfiguration property is defined.
         */
        destinationBucketName?: string;
        logFilePrefix?: string;
    }
    interface BucketMetrics {
        eventThreshold?: outputs.s3.BucketReplicationTimeValue;
        status: enums.s3.BucketMetricsStatus;
    }
    interface BucketMetricsConfiguration {
        accessPointArn?: string;
        id: string;
        prefix?: string;
        tagFilters?: outputs.s3.BucketTagFilter[];
    }
    /**
     * Container for the expiration rule that describes when noncurrent objects are expired. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 expire noncurrent object versions at a specific period in the object's lifetime
     */
    interface BucketNoncurrentVersionExpiration {
        /**
         * Specified the number of newer noncurrent and current versions that must exists before performing the associated action
         */
        newerNoncurrentVersions?: number;
        /**
         * Specified the number of days an object is noncurrent before Amazon S3 can perform the associated action
         */
        noncurrentDays: number;
    }
    /**
     * Container for the transition rule that describes when noncurrent objects transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's lifetime.
     */
    interface BucketNoncurrentVersionTransition {
        /**
         * Specified the number of newer noncurrent and current versions that must exists before performing the associated action
         */
        newerNoncurrentVersions?: number;
        /**
         * The class of storage used to store the object.
         */
        storageClass: enums.s3.BucketNoncurrentVersionTransitionStorageClass;
        /**
         * Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
         */
        transitionInDays: number;
    }
    /**
     * Describes the notification configuration for an Amazon S3 bucket.
     */
    interface BucketNotificationConfiguration {
        eventBridgeConfiguration?: outputs.s3.BucketEventBridgeConfiguration;
        lambdaConfigurations?: outputs.s3.BucketLambdaConfiguration[];
        queueConfigurations?: outputs.s3.BucketQueueConfiguration[];
        topicConfigurations?: outputs.s3.BucketTopicConfiguration[];
    }
    /**
     * Specifies object key name filtering rules.
     */
    interface BucketNotificationFilter {
        s3Key: outputs.s3.BucketS3KeyFilter;
    }
    interface BucketObjectLockConfiguration {
        objectLockEnabled?: string;
        rule?: outputs.s3.BucketObjectLockRule;
    }
    /**
     * The Object Lock rule in place for the specified object.
     */
    interface BucketObjectLockRule {
        defaultRetention?: outputs.s3.BucketDefaultRetention;
    }
    interface BucketOwnershipControls {
        rules: outputs.s3.BucketOwnershipControlsRule[];
    }
    interface BucketOwnershipControlsRule {
        /**
         * Specifies an object ownership rule.
         */
        objectOwnership?: enums.s3.BucketOwnershipControlsRuleObjectOwnership;
    }
    /**
     * Configuration that defines how Amazon S3 handles public access.
     */
    interface BucketPublicAccessBlockConfiguration {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
         * Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
         * Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: boolean;
    }
    /**
     * The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
     */
    interface BucketQueueConfiguration {
        /**
         * The Amazon S3 bucket event about which you want to publish messages to Amazon SQS.
         */
        event: string;
        /**
         * The filtering rules that determine which objects trigger notifications.
         */
        filter?: outputs.s3.BucketNotificationFilter;
        /**
         * The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
         */
        queue: string;
    }
    /**
     * Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
     */
    interface BucketRedirectAllRequestsTo {
        /**
         * Name of the host where requests are redirected.
         */
        hostName: string;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        protocol?: enums.s3.BucketRedirectAllRequestsToProtocol;
    }
    /**
     * Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
     */
    interface BucketRedirectRule {
        /**
         * The host name to use in the redirect request.
         */
        hostName?: string;
        /**
         * The HTTP redirect code to use on the response. Not required if one of the siblings is present.
         */
        httpRedirectCode?: string;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        protocol?: enums.s3.BucketRedirectRuleProtocol;
        /**
         * The object key prefix to use in the redirect request.
         */
        replaceKeyPrefixWith?: string;
        /**
         * The specific object key to use in the redirect request.d
         */
        replaceKeyWith?: string;
    }
    interface BucketReplicaModifications {
        /**
         * Specifies whether Amazon S3 replicates modifications on replicas.
         */
        status: enums.s3.BucketReplicaModificationsStatus;
    }
    /**
     * A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
     */
    interface BucketReplicationConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects.
         */
        role: string;
        /**
         * A container for one or more replication rules.
         */
        rules: outputs.s3.BucketReplicationRule[];
    }
    /**
     * Specifies which Amazon S3 bucket to store replicated objects in and their storage class.
     */
    interface BucketReplicationDestination {
        accessControlTranslation?: outputs.s3.BucketAccessControlTranslation;
        account?: string;
        bucket: string;
        encryptionConfiguration?: outputs.s3.BucketEncryptionConfiguration;
        metrics?: outputs.s3.BucketMetrics;
        replicationTime?: outputs.s3.BucketReplicationTime;
        /**
         * The storage class to use when replicating objects, such as S3 Standard or reduced redundancy.
         */
        storageClass?: enums.s3.BucketReplicationDestinationStorageClass;
    }
    /**
     * Specifies which Amazon S3 objects to replicate and where to store the replicas.
     */
    interface BucketReplicationRule {
        deleteMarkerReplication?: outputs.s3.BucketDeleteMarkerReplication;
        destination: outputs.s3.BucketReplicationDestination;
        filter?: outputs.s3.BucketReplicationRuleFilter;
        /**
         * A unique identifier for the rule.
         */
        id?: string;
        /**
         * An object key name prefix that identifies the object or objects to which the rule applies.
         */
        prefix?: string;
        priority?: number;
        sourceSelectionCriteria?: outputs.s3.BucketSourceSelectionCriteria;
        /**
         * Specifies whether the rule is enabled.
         */
        status: enums.s3.BucketReplicationRuleStatus;
    }
    interface BucketReplicationRuleAndOperator {
        prefix?: string;
        tagFilters?: outputs.s3.BucketTagFilter[];
    }
    interface BucketReplicationRuleFilter {
        and?: outputs.s3.BucketReplicationRuleAndOperator;
        prefix?: string;
        tagFilter?: outputs.s3.BucketTagFilter;
    }
    interface BucketReplicationTime {
        status: enums.s3.BucketReplicationTimeStatus;
        time: outputs.s3.BucketReplicationTimeValue;
    }
    interface BucketReplicationTimeValue {
        minutes: number;
    }
    /**
     * Specifies the redirect behavior and when a redirect is applied.
     */
    interface BucketRoutingRule {
        /**
         * Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
         */
        redirectRule: outputs.s3.BucketRedirectRule;
        routingRuleCondition?: outputs.s3.BucketRoutingRuleCondition;
    }
    /**
     * A container for describing a condition that must be met for the specified redirect to apply.You must specify at least one of HttpErrorCodeReturnedEquals and KeyPrefixEquals
     */
    interface BucketRoutingRuleCondition {
        /**
         * The HTTP error code when the redirect is applied.
         */
        httpErrorCodeReturnedEquals?: string;
        /**
         * The object key name prefix when the redirect is applied.
         */
        keyPrefixEquals?: string;
    }
    /**
     * You must specify at least one of the following properties: AbortIncompleteMultipartUpload, ExpirationDate, ExpirationInDays, NoncurrentVersionExpirationInDays, NoncurrentVersionTransition, NoncurrentVersionTransitions, Transition, or Transitions.
     */
    interface BucketRule {
        abortIncompleteMultipartUpload?: outputs.s3.BucketAbortIncompleteMultipartUpload;
        expirationDate?: string;
        expirationInDays?: number;
        expiredObjectDeleteMarker?: boolean;
        id?: string;
        noncurrentVersionExpiration?: outputs.s3.BucketNoncurrentVersionExpiration;
        noncurrentVersionExpirationInDays?: number;
        noncurrentVersionTransition?: outputs.s3.BucketNoncurrentVersionTransition;
        noncurrentVersionTransitions?: outputs.s3.BucketNoncurrentVersionTransition[];
        objectSizeGreaterThan?: string;
        objectSizeLessThan?: string;
        prefix?: string;
        status: enums.s3.BucketRuleStatus;
        tagFilters?: outputs.s3.BucketTagFilter[];
        transition?: outputs.s3.BucketTransition;
        transitions?: outputs.s3.BucketTransition[];
    }
    /**
     * A container for object key name prefix and suffix filtering rules.
     */
    interface BucketS3KeyFilter {
        rules: outputs.s3.BucketFilterRule[];
    }
    /**
     * Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
     */
    interface BucketServerSideEncryptionByDefault {
        /**
         * "KMSMasterKeyID" can only be used when you set the value of SSEAlgorithm as aws:kms.
         */
        kMSMasterKeyID?: string;
        sSEAlgorithm: enums.s3.BucketServerSideEncryptionByDefaultSSEAlgorithm;
    }
    /**
     * Specifies the default server-side encryption configuration.
     */
    interface BucketServerSideEncryptionRule {
        /**
         * Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled.
         */
        bucketKeyEnabled?: boolean;
        serverSideEncryptionByDefault?: outputs.s3.BucketServerSideEncryptionByDefault;
    }
    /**
     * A container that describes additional filters for identifying the source objects that you want to replicate.
     */
    interface BucketSourceSelectionCriteria {
        /**
         * A filter that you can specify for selection for modifications on replicas.
         */
        replicaModifications?: outputs.s3.BucketReplicaModifications;
        /**
         * A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS.
         */
        sseKmsEncryptedObjects?: outputs.s3.BucketSseKmsEncryptedObjects;
    }
    /**
     * A container for filter information for the selection of S3 objects encrypted with AWS KMS.
     */
    interface BucketSseKmsEncryptedObjects {
        /**
         * Specifies whether Amazon S3 replicates objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service.
         */
        status: enums.s3.BucketSseKmsEncryptedObjectsStatus;
    }
    /**
     * Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
     */
    interface BucketStorageClassAnalysis {
        dataExport?: outputs.s3.BucketDataExport;
    }
    interface BucketTag {
        key: string;
        value: string;
    }
    /**
     * Tags to use to identify a subset of objects for an Amazon S3 bucket.
     */
    interface BucketTagFilter {
        key: string;
        value: string;
    }
    interface BucketTiering {
        /**
         * S3 Intelligent-Tiering access tier. See Storage class for automatically optimizing frequently and infrequently accessed objects for a list of access tiers in the S3 Intelligent-Tiering storage class.
         */
        accessTier: enums.s3.BucketTieringAccessTier;
        /**
         * The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
         */
        days: number;
    }
    /**
     * The topic to which notifications are sent and the events for which notifications are generated.
     */
    interface BucketTopicConfiguration {
        /**
         * The Amazon S3 bucket event about which to send notifications.
         */
        event: string;
        /**
         * The filtering rules that determine for which objects to send notifications.
         */
        filter?: outputs.s3.BucketNotificationFilter;
        /**
         * The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
         */
        topic: string;
    }
    /**
     * You must specify at least one of "TransitionDate" and "TransitionInDays"
     */
    interface BucketTransition {
        storageClass: enums.s3.BucketTransitionStorageClass;
        transitionDate?: string;
        transitionInDays?: number;
    }
    /**
     * Describes the versioning state of an Amazon S3 bucket.
     */
    interface BucketVersioningConfiguration {
        /**
         * The versioning state of the bucket.
         */
        status: enums.s3.BucketVersioningConfigurationStatus;
    }
    /**
     * Specifies website configuration parameters for an Amazon S3 bucket.
     */
    interface BucketWebsiteConfiguration {
        /**
         * The name of the error document for the website.
         */
        errorDocument?: string;
        /**
         * The name of the index document for the website.
         */
        indexDocument?: string;
        redirectAllRequestsTo?: outputs.s3.BucketRedirectAllRequestsTo;
        routingRules?: outputs.s3.BucketRoutingRule[];
    }
    interface MultiRegionAccessPointPublicAccessBlockConfiguration {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: boolean;
    }
    interface MultiRegionAccessPointRegion {
        bucket: string;
    }
    /**
     * The Policy Status associated with this Multi Region Access Point
     */
    interface PolicyStatusProperties {
        /**
         * Specifies whether the policy is public or not.
         */
        isPublic: enums.s3.MultiRegionAccessPointPolicyPolicyStatusPropertiesIsPublic;
    }
    /**
     * Account-level metrics configurations.
     */
    interface StorageLensAccountLevel {
        activityMetrics?: outputs.s3.StorageLensActivityMetrics;
        bucketLevel: outputs.s3.StorageLensBucketLevel;
    }
    /**
     * Enables activity metrics.
     */
    interface StorageLensActivityMetrics {
        /**
         * Specifies whether activity metrics are enabled or disabled.
         */
        isEnabled?: boolean;
    }
    /**
     * The AWS Organizations ARN to use in the Amazon S3 Storage Lens configuration.
     */
    interface StorageLensAwsOrg {
        arn: string;
    }
    /**
     * Bucket-level metrics configurations.
     */
    interface StorageLensBucketLevel {
        activityMetrics?: outputs.s3.StorageLensActivityMetrics;
        prefixLevel?: outputs.s3.StorageLensPrefixLevel;
    }
    /**
     * S3 buckets and Regions to include/exclude in the Amazon S3 Storage Lens configuration.
     */
    interface StorageLensBucketsAndRegions {
        buckets?: string[];
        regions?: string[];
    }
    /**
     * CloudWatch metrics settings for the Amazon S3 Storage Lens metrics export.
     */
    interface StorageLensCloudWatchMetrics {
        /**
         * Specifies whether CloudWatch metrics are enabled or disabled.
         */
        isEnabled: boolean;
    }
    /**
     * Specifies the details of Amazon S3 Storage Lens configuration.
     */
    interface StorageLensConfiguration {
        accountLevel: outputs.s3.StorageLensAccountLevel;
        awsOrg?: outputs.s3.StorageLensAwsOrg;
        dataExport?: outputs.s3.StorageLensDataExport;
        exclude?: outputs.s3.StorageLensBucketsAndRegions;
        id: string;
        include?: outputs.s3.StorageLensBucketsAndRegions;
        /**
         * Specifies whether the Amazon S3 Storage Lens configuration is enabled or disabled.
         */
        isEnabled: boolean;
        /**
         * The ARN for the Amazon S3 Storage Lens configuration.
         */
        storageLensArn?: string;
    }
    /**
     * Specifies how Amazon S3 Storage Lens metrics should be exported.
     */
    interface StorageLensDataExport {
        cloudWatchMetrics?: outputs.s3.StorageLensCloudWatchMetrics;
        s3BucketDestination?: outputs.s3.StorageLensS3BucketDestination;
    }
    /**
     * Configures the server-side encryption for Amazon S3 Storage Lens report files with either S3-managed keys (SSE-S3) or KMS-managed keys (SSE-KMS).
     */
    interface StorageLensEncryption {
    }
    /**
     * Prefix-level metrics configurations.
     */
    interface StorageLensPrefixLevel {
        storageMetrics: outputs.s3.StorageLensPrefixLevelStorageMetrics;
    }
    interface StorageLensPrefixLevelStorageMetrics {
        /**
         * Specifies whether prefix-level storage metrics are enabled or disabled.
         */
        isEnabled?: boolean;
        selectionCriteria?: outputs.s3.StorageLensSelectionCriteria;
    }
    /**
     * S3 bucket destination settings for the Amazon S3 Storage Lens metrics export.
     */
    interface StorageLensS3BucketDestination {
        /**
         * The AWS account ID that owns the destination S3 bucket.
         */
        accountId: string;
        /**
         * The ARN of the bucket to which Amazon S3 Storage Lens exports will be placed.
         */
        arn: string;
        encryption?: outputs.s3.StorageLensEncryption;
        /**
         * Specifies the file format to use when exporting Amazon S3 Storage Lens metrics export.
         */
        format: enums.s3.StorageLensS3BucketDestinationFormat;
        /**
         * The version of the output schema to use when exporting Amazon S3 Storage Lens metrics.
         */
        outputSchemaVersion: enums.s3.StorageLensS3BucketDestinationOutputSchemaVersion;
        /**
         * The prefix to use for Amazon S3 Storage Lens export.
         */
        prefix?: string;
    }
    /**
     * Selection criteria for prefix-level metrics.
     */
    interface StorageLensSelectionCriteria {
        /**
         * Delimiter to divide S3 key into hierarchy of prefixes.
         */
        delimiter?: string;
        /**
         * Max depth of prefixes of S3 key that Amazon S3 Storage Lens will analyze.
         */
        maxDepth?: number;
        /**
         * The minimum storage bytes threshold for the prefixes to be included in the analysis.
         */
        minStorageBytesPercentage?: number;
    }
    interface StorageLensTag {
        key: string;
        value: string;
    }
}
export declare namespace s3objectlambda {
    interface AccessPointAwsLambda {
        functionArn: string;
        functionPayload?: string;
    }
    /**
     * Configuration to be applied to this Object lambda Access Point. It specifies Supporting Access Point, Transformation Configurations. Customers can also set if they like to enable Cloudwatch metrics for accesses to this Object lambda Access Point. Default setting for Cloudwatch metrics is disable.
     */
    interface AccessPointObjectLambdaConfiguration {
        allowedFeatures?: string[];
        cloudWatchMetricsEnabled?: boolean;
        supportingAccessPoint: string;
        transformationConfigurations: outputs.s3objectlambda.AccessPointTransformationConfiguration[];
    }
    /**
     * The Public Access Block Configuration is used to block policies that would allow public access to this Object lambda Access Point. All public access to Object lambda Access Points are blocked by default, and any policy that would give public access to them will be also blocked. This behavior cannot be changed for Object lambda Access Points.
     */
    interface AccessPointPublicAccessBlockConfiguration {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) to this object lambda access point. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: boolean;
    }
    /**
     * Configuration to define what content transformation will be applied on which S3 Action.
     */
    interface AccessPointTransformationConfiguration {
        actions: string[];
        contentTransformation: outputs.s3objectlambda.AccessPointTransformationConfigurationContentTransformationProperties;
    }
    interface AccessPointTransformationConfigurationContentTransformationProperties {
        awsLambda: outputs.s3objectlambda.AccessPointAwsLambda;
    }
    interface PolicyStatusProperties {
        /**
         * Specifies whether the Object lambda Access Point Policy is Public or not. Object lambda Access Points are private by default.
         */
        isPublic?: boolean;
    }
}
export declare namespace s3outposts {
    interface AccessPointVpcConfiguration {
        /**
         * Virtual Private Cloud (VPC) Id from which AccessPoint will allow requests.
         */
        vpcId?: string;
    }
    /**
     * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3Outposts will wait before permanently removing all parts of the upload.
     */
    interface BucketAbortIncompleteMultipartUpload {
        /**
         * Specifies the number of days after which Amazon S3Outposts aborts an incomplete multipart upload.
         */
        daysAfterInitiation: number;
    }
    interface BucketFilterAndOperator {
    }
    /**
     * Tag used to identify a subset of objects for an Amazon S3Outposts bucket.
     */
    interface BucketFilterTag {
        key: string;
        value: string;
    }
    interface BucketLifecycleConfiguration {
        /**
         * A list of lifecycle rules for individual objects in an Amazon S3Outposts bucket.
         */
        rules: outputs.s3outposts.BucketRule[];
    }
    /**
     * Specifies lifecycle rules for an Amazon S3Outposts bucket. You must specify at least one of the following: AbortIncompleteMultipartUpload, ExpirationDate, ExpirationInDays.
     */
    interface BucketRule {
        /**
         * Specifies a lifecycle rule that stops incomplete multipart uploads to an Amazon S3Outposts bucket.
         */
        abortIncompleteMultipartUpload?: outputs.s3outposts.BucketAbortIncompleteMultipartUpload;
        /**
         * Indicates when objects are deleted from Amazon S3Outposts. The date value must be in ISO 8601 format. The time is always midnight UTC.
         */
        expirationDate?: string;
        /**
         * Indicates the number of days after creation when objects are deleted from Amazon S3Outposts.
         */
        expirationInDays?: number;
        /**
         * The container for the filter of the lifecycle rule.
         */
        filter?: outputs.s3outposts.BucketRuleFilterProperties;
        /**
         * Unique identifier for the lifecycle rule. The value can't be longer than 255 characters.
         */
        id?: string;
        status?: enums.s3outposts.BucketRuleStatus;
    }
    /**
     * The container for the filter of the lifecycle rule.
     */
    interface BucketRuleFilterProperties {
        /**
         * The container for the AND condition for the lifecycle rule. A combination of Prefix and 1 or more Tags OR a minimum of 2 or more tags.
         */
        andOperator?: outputs.s3outposts.BucketFilterAndOperator;
        /**
         * Object key prefix that identifies one or more objects to which this rule applies.
         */
        prefix?: string;
        /**
         * Specifies a tag used to identify a subset of objects for an Amazon S3Outposts bucket.
         */
        tag?: outputs.s3outposts.BucketFilterTag;
    }
    interface BucketTag {
        key: string;
        value: string;
    }
    /**
     * The container for the network interface.
     */
    interface EndpointNetworkInterface {
        networkInterfaceId: string;
    }
}
export declare namespace sagemaker {
    /**
     * The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
     */
    interface AppImageConfigFileSystemConfig {
        /**
         * The default POSIX group ID (GID). If not specified, defaults to 100.
         */
        defaultGid?: number;
        /**
         * The default POSIX user ID (UID). If not specified, defaults to 1000.
         */
        defaultUid?: number;
        /**
         * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
         */
        mountPath?: string;
    }
    /**
     * The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app.
     */
    interface AppImageConfigKernelGatewayImageConfig {
        /**
         * The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
         */
        fileSystemConfig?: outputs.sagemaker.AppImageConfigFileSystemConfig;
        /**
         * The specification of the Jupyter kernels in the image.
         */
        kernelSpecs: outputs.sagemaker.AppImageConfigKernelSpec[];
    }
    interface AppImageConfigKernelSpec {
        /**
         * The display name of the kernel.
         */
        displayName?: string;
        /**
         * The name of the kernel.
         */
        name: string;
    }
    interface AppImageConfigTag {
        key: string;
        value: string;
    }
    interface AppResourceSpec {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: enums.sagemaker.AppResourceSpecInstanceType;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: string;
    }
    interface AppTag {
        key: string;
        value: string;
    }
    interface CodeRepositoryGitConfig {
        branch?: string;
        repositoryUrl: string;
        secretArn?: string;
    }
    interface CodeRepositoryTag {
        key: string;
        value: string;
    }
    /**
     * The batch transform input for a monitoring job.
     */
    interface DataQualityJobDefinitionBatchTransformInput {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: string;
        datasetFormat: outputs.sagemaker.DataQualityJobDefinitionDatasetFormat;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.DataQualityJobDefinitionBatchTransformInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.DataQualityJobDefinitionBatchTransformInputS3InputMode;
    }
    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    interface DataQualityJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }
    /**
     * The baseline constraints resource for a monitoring job.
     */
    interface DataQualityJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }
    /**
     * The CSV format
     */
    interface DataQualityJobDefinitionCsv {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: boolean;
    }
    /**
     * Container image configuration object for the monitoring job.
     */
    interface DataQualityJobDefinitionDataQualityAppSpecification {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: string[];
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: string[];
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: string;
    }
    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    interface DataQualityJobDefinitionDataQualityBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.DataQualityJobDefinitionConstraintsResource;
        statisticsResource?: outputs.sagemaker.DataQualityJobDefinitionStatisticsResource;
    }
    /**
     * The inputs for a monitoring job.
     */
    interface DataQualityJobDefinitionDataQualityJobInput {
        batchTransformInput?: outputs.sagemaker.DataQualityJobDefinitionBatchTransformInput;
        endpointInput?: outputs.sagemaker.DataQualityJobDefinitionEndpointInput;
    }
    /**
     * The dataset format of the data to monitor
     */
    interface DataQualityJobDefinitionDatasetFormat {
        csv?: outputs.sagemaker.DataQualityJobDefinitionCsv;
        json?: outputs.sagemaker.DataQualityJobDefinitionJson;
        parquet?: boolean;
    }
    /**
     * The endpoint for a monitoring job.
     */
    interface DataQualityJobDefinitionEndpointInput {
        endpointName: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.DataQualityJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.DataQualityJobDefinitionEndpointInputS3InputMode;
    }
    /**
     * The Json format
     */
    interface DataQualityJobDefinitionJson {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: boolean;
    }
    /**
     * The output object for a monitoring job.
     */
    interface DataQualityJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.DataQualityJobDefinitionS3Output;
    }
    /**
     * The output configuration for monitoring jobs.
     */
    interface DataQualityJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.DataQualityJobDefinitionMonitoringOutput[];
    }
    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    interface DataQualityJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.DataQualityJobDefinitionClusterConfig;
    }
    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    interface DataQualityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.DataQualityJobDefinitionVpcConfig;
    }
    /**
     * Information about where and how to store the results of a monitoring job.
     */
    interface DataQualityJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.DataQualityJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    /**
     * The baseline statistics resource for a monitoring job.
     */
    interface DataQualityJobDefinitionStatisticsResource {
        /**
         * The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
         */
        s3Uri?: string;
    }
    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    interface DataQualityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface DataQualityJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    interface DataQualityJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }
    /**
     * Edge device you want to create
     */
    interface Device {
        /**
         * Description of the device
         */
        description?: string;
        /**
         * The name of the device
         */
        deviceName: string;
        /**
         * AWS Internet of Things (IoT) object name.
         */
        iotThingName?: string;
    }
    interface DeviceFleetEdgeOutputConfig {
        /**
         * The KMS key id used for encryption on the S3 bucket
         */
        kmsKeyId?: string;
        /**
         * The Amazon Simple Storage (S3) bucket URI
         */
        s3OutputLocation: string;
    }
    /**
     * Key-value pair to associate as a tag for the resource
     */
    interface DeviceFleetTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The key value of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface DeviceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The key value of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * A custom SageMaker image.
     */
    interface DomainCustomImage {
        /**
         * The Name of the AppImageConfig.
         */
        appImageConfigName: string;
        /**
         * The name of the CustomImage. Must be unique to your account.
         */
        imageName: string;
        /**
         * The version number of the CustomImage.
         */
        imageVersionNumber?: number;
    }
    /**
     * The JupyterServer app settings.
     */
    interface DomainJupyterServerAppSettings {
        defaultResourceSpec?: outputs.sagemaker.DomainResourceSpec;
    }
    /**
     * The kernel gateway app settings.
     */
    interface DomainKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: outputs.sagemaker.DomainCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainResourceSpec;
    }
    /**
     * A collection of settings that apply to an RSessionGateway app.
     */
    interface DomainRSessionAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: outputs.sagemaker.DomainCustomImage[];
        defaultResourceSpec?: outputs.sagemaker.DomainResourceSpec;
    }
    /**
     * A collection of settings that configure user interaction with the RStudioServerPro app.
     */
    interface DomainRStudioServerProAppSettings {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app.
         */
        accessStatus?: enums.sagemaker.DomainRStudioServerProAppSettingsAccessStatus;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
         */
        userGroup?: enums.sagemaker.DomainRStudioServerProAppSettingsUserGroup;
    }
    /**
     * A collection of settings that update the current configuration for the RStudioServerPro Domain-level app.
     */
    interface DomainRStudioServerProDomainSettings {
        defaultResourceSpec?: outputs.sagemaker.DomainResourceSpec;
        /**
         * The ARN of the execution role for the RStudioServerPro Domain-level app.
         */
        domainExecutionRoleArn: string;
        /**
         * A URL pointing to an RStudio Connect server.
         */
        rStudioConnectUrl?: string;
        /**
         * A URL pointing to an RStudio Package Manager server.
         */
        rStudioPackageManagerUrl?: string;
    }
    interface DomainResourceSpec {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: enums.sagemaker.DomainResourceSpecInstanceType;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the image version created on the instance.
         */
        sageMakerImageVersionArn?: string;
    }
    /**
     * A collection of Domain settings.
     */
    interface DomainSettings {
        rStudioServerProDomainSettings?: outputs.sagemaker.DomainRStudioServerProDomainSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
         */
        securityGroupIds?: string[];
    }
    /**
     * Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
     */
    interface DomainSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
         */
        notebookOutputOption?: enums.sagemaker.DomainSharingSettingsNotebookOutputOption;
        /**
         * When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
         */
        s3OutputPath?: string;
    }
    interface DomainTag {
        key: string;
        value: string;
    }
    /**
     * A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
     */
    interface DomainUserSettings {
        /**
         * The user profile Amazon Resource Name (ARN).
         */
        executionRole?: string;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: outputs.sagemaker.DomainJupyterServerAppSettings;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.DomainKernelGatewayAppSettings;
        rSessionAppSettings?: outputs.sagemaker.DomainRSessionAppSettings;
        rStudioServerProAppSettings?: outputs.sagemaker.DomainRStudioServerProAppSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
         */
        securityGroups?: string[];
        /**
         * The sharing settings.
         */
        sharingSettings?: outputs.sagemaker.DomainSharingSettings;
    }
    interface EndpointAlarm {
        alarmName: string;
    }
    interface EndpointAutoRollbackConfig {
        alarms: outputs.sagemaker.EndpointAlarm[];
    }
    interface EndpointBlueGreenUpdatePolicy {
        maximumExecutionTimeoutInSeconds?: number;
        terminationWaitInSeconds?: number;
        trafficRoutingConfiguration: outputs.sagemaker.EndpointTrafficRoutingConfig;
    }
    interface EndpointCapacitySize {
        type: string;
        value: number;
    }
    interface EndpointConfigAsyncInferenceClientConfig {
        maxConcurrentInvocationsPerInstance?: number;
    }
    interface EndpointConfigAsyncInferenceConfig {
        clientConfig?: outputs.sagemaker.EndpointConfigAsyncInferenceClientConfig;
        outputConfig: outputs.sagemaker.EndpointConfigAsyncInferenceOutputConfig;
    }
    interface EndpointConfigAsyncInferenceNotificationConfig {
        errorTopic?: string;
        successTopic?: string;
    }
    interface EndpointConfigAsyncInferenceOutputConfig {
        kmsKeyId?: string;
        notificationConfig?: outputs.sagemaker.EndpointConfigAsyncInferenceNotificationConfig;
        s3OutputPath: string;
    }
    interface EndpointConfigCaptureContentTypeHeader {
        csvContentTypes?: string[];
        jsonContentTypes?: string[];
    }
    interface EndpointConfigCaptureOption {
        captureMode: string;
    }
    interface EndpointConfigClarifyExplainerConfig {
        enableExplanations?: string;
        inferenceConfig?: outputs.sagemaker.EndpointConfigClarifyInferenceConfig;
        shapConfig: outputs.sagemaker.EndpointConfigClarifyShapConfig;
    }
    interface EndpointConfigClarifyFeatureType {
    }
    interface EndpointConfigClarifyHeader {
    }
    interface EndpointConfigClarifyInferenceConfig {
        contentTemplate?: string;
        featureHeaders?: outputs.sagemaker.EndpointConfigClarifyHeader[];
        featureTypes?: outputs.sagemaker.EndpointConfigClarifyFeatureType[];
        featuresAttribute?: string;
        labelAttribute?: string;
        labelHeaders?: outputs.sagemaker.EndpointConfigClarifyHeader[];
        labelIndex?: number;
        maxPayloadInMB?: number;
        maxRecordCount?: number;
        probabilityAttribute?: string;
        probabilityIndex?: number;
    }
    interface EndpointConfigClarifyShapBaselineConfig {
        mimeType?: string;
        shapBaseline?: string;
        shapBaselineUri?: string;
    }
    interface EndpointConfigClarifyShapConfig {
        numberOfSamples?: number;
        seed?: number;
        shapBaselineConfig: outputs.sagemaker.EndpointConfigClarifyShapBaselineConfig;
        textConfig?: outputs.sagemaker.EndpointConfigClarifyTextConfig;
        useLogit?: boolean;
    }
    interface EndpointConfigClarifyTextConfig {
        granularity: string;
        language: string;
    }
    interface EndpointConfigDataCaptureConfig {
        captureContentTypeHeader?: outputs.sagemaker.EndpointConfigCaptureContentTypeHeader;
        captureOptions: outputs.sagemaker.EndpointConfigCaptureOption[];
        destinationS3Uri: string;
        enableCapture?: boolean;
        initialSamplingPercentage: number;
        kmsKeyId?: string;
    }
    interface EndpointConfigExplainerConfig {
        clarifyExplainerConfig?: outputs.sagemaker.EndpointConfigClarifyExplainerConfig;
    }
    interface EndpointConfigProductionVariant {
        acceleratorType?: string;
        containerStartupHealthCheckTimeoutInSeconds?: number;
        initialInstanceCount?: number;
        initialVariantWeight: number;
        instanceType?: string;
        modelDataDownloadTimeoutInSeconds?: number;
        modelName: string;
        serverlessConfig?: outputs.sagemaker.EndpointConfigServerlessConfig;
        variantName: string;
        volumeSizeInGB?: number;
    }
    interface EndpointConfigServerlessConfig {
        maxConcurrency: number;
        memorySizeInMB: number;
    }
    interface EndpointConfigTag {
        key: string;
        value: string;
    }
    interface EndpointDeploymentConfig {
        autoRollbackConfiguration?: outputs.sagemaker.EndpointAutoRollbackConfig;
        blueGreenUpdatePolicy: outputs.sagemaker.EndpointBlueGreenUpdatePolicy;
    }
    interface EndpointTag {
        key: string;
        value: string;
    }
    interface EndpointTrafficRoutingConfig {
        canarySize?: outputs.sagemaker.EndpointCapacitySize;
        linearStepSize?: outputs.sagemaker.EndpointCapacitySize;
        type: string;
        waitIntervalInSeconds?: number;
    }
    interface EndpointVariantProperty {
        variantPropertyType?: string;
    }
    interface FeatureGroupDataCatalogConfig {
        catalog: string;
        database: string;
        tableName: string;
    }
    interface FeatureGroupFeatureDefinition {
        featureName: string;
        featureType: enums.sagemaker.FeatureGroupFeatureDefinitionFeatureType;
    }
    interface FeatureGroupOnlineStoreSecurityConfig {
        kmsKeyId?: string;
    }
    interface FeatureGroupS3StorageConfig {
        kmsKeyId?: string;
        s3Uri: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface FeatureGroupTag {
        key: string;
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ImageTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * The batch transform input for a monitoring job.
     */
    interface ModelBiasJobDefinitionBatchTransformInput {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: string;
        datasetFormat: outputs.sagemaker.ModelBiasJobDefinitionDatasetFormat;
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: string;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        probabilityThresholdAttribute?: number;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelBiasJobDefinitionBatchTransformInputS3InputMode;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: string;
    }
    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    interface ModelBiasJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }
    /**
     * The baseline constraints resource for a monitoring job.
     */
    interface ModelBiasJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }
    /**
     * The CSV format
     */
    interface ModelBiasJobDefinitionCsv {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: boolean;
    }
    /**
     * The dataset format of the data to monitor
     */
    interface ModelBiasJobDefinitionDatasetFormat {
        csv?: outputs.sagemaker.ModelBiasJobDefinitionCsv;
        json?: outputs.sagemaker.ModelBiasJobDefinitionJson;
        parquet?: boolean;
    }
    /**
     * The endpoint for a monitoring job.
     */
    interface ModelBiasJobDefinitionEndpointInput {
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: string;
        endpointName: string;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        probabilityThresholdAttribute?: number;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelBiasJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelBiasJobDefinitionEndpointInputS3InputMode;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: string;
    }
    /**
     * The Json format
     */
    interface ModelBiasJobDefinitionJson {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: boolean;
    }
    /**
     * Container image configuration object for the monitoring job.
     */
    interface ModelBiasJobDefinitionModelBiasAppSpecification {
        /**
         * The S3 URI to an analysis configuration file
         */
        configUri: string;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
    }
    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    interface ModelBiasJobDefinitionModelBiasBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.ModelBiasJobDefinitionConstraintsResource;
    }
    /**
     * The inputs for a monitoring job.
     */
    interface ModelBiasJobDefinitionModelBiasJobInput {
        batchTransformInput?: outputs.sagemaker.ModelBiasJobDefinitionBatchTransformInput;
        endpointInput?: outputs.sagemaker.ModelBiasJobDefinitionEndpointInput;
        groundTruthS3Input: outputs.sagemaker.ModelBiasJobDefinitionMonitoringGroundTruthS3Input;
    }
    /**
     * Ground truth input provided in S3
     */
    interface ModelBiasJobDefinitionMonitoringGroundTruthS3Input {
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    /**
     * The output object for a monitoring job.
     */
    interface ModelBiasJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.ModelBiasJobDefinitionS3Output;
    }
    /**
     * The output configuration for monitoring jobs.
     */
    interface ModelBiasJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.ModelBiasJobDefinitionMonitoringOutput[];
    }
    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    interface ModelBiasJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.ModelBiasJobDefinitionClusterConfig;
    }
    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    interface ModelBiasJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.ModelBiasJobDefinitionVpcConfig;
    }
    /**
     * Information about where and how to store the results of a monitoring job.
     */
    interface ModelBiasJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.ModelBiasJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    interface ModelBiasJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ModelBiasJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    interface ModelBiasJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }
    interface ModelContainerDefinition {
        containerHostname?: string;
        environment?: any;
        image?: string;
        imageConfig?: outputs.sagemaker.ModelImageConfig;
        inferenceSpecificationName?: string;
        mode?: string;
        modelDataUrl?: string;
        modelPackageName?: string;
        multiModelConfig?: outputs.sagemaker.ModelMultiModelConfig;
    }
    /**
     * The batch transform input for a monitoring job.
     */
    interface ModelExplainabilityJobDefinitionBatchTransformInput {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: string;
        datasetFormat: outputs.sagemaker.ModelExplainabilityJobDefinitionDatasetFormat;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode;
    }
    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    interface ModelExplainabilityJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }
    /**
     * The baseline constraints resource for a monitoring job.
     */
    interface ModelExplainabilityJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }
    /**
     * The CSV format
     */
    interface ModelExplainabilityJobDefinitionCsv {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: boolean;
    }
    /**
     * The dataset format of the data to monitor
     */
    interface ModelExplainabilityJobDefinitionDatasetFormat {
        csv?: outputs.sagemaker.ModelExplainabilityJobDefinitionCsv;
        json?: outputs.sagemaker.ModelExplainabilityJobDefinitionJson;
        parquet?: boolean;
    }
    /**
     * The endpoint for a monitoring job.
     */
    interface ModelExplainabilityJobDefinitionEndpointInput {
        endpointName: string;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelExplainabilityJobDefinitionEndpointInputS3InputMode;
    }
    /**
     * The Json format
     */
    interface ModelExplainabilityJobDefinitionJson {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: boolean;
    }
    /**
     * Container image configuration object for the monitoring job.
     */
    interface ModelExplainabilityJobDefinitionModelExplainabilityAppSpecification {
        /**
         * The S3 URI to an analysis configuration file
         */
        configUri: string;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
    }
    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    interface ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.ModelExplainabilityJobDefinitionConstraintsResource;
    }
    /**
     * The inputs for a monitoring job.
     */
    interface ModelExplainabilityJobDefinitionModelExplainabilityJobInput {
        batchTransformInput?: outputs.sagemaker.ModelExplainabilityJobDefinitionBatchTransformInput;
        endpointInput?: outputs.sagemaker.ModelExplainabilityJobDefinitionEndpointInput;
    }
    /**
     * The output object for a monitoring job.
     */
    interface ModelExplainabilityJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.ModelExplainabilityJobDefinitionS3Output;
    }
    /**
     * The output configuration for monitoring jobs.
     */
    interface ModelExplainabilityJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.ModelExplainabilityJobDefinitionMonitoringOutput[];
    }
    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    interface ModelExplainabilityJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.ModelExplainabilityJobDefinitionClusterConfig;
    }
    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    interface ModelExplainabilityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.ModelExplainabilityJobDefinitionVpcConfig;
    }
    /**
     * Information about where and how to store the results of a monitoring job.
     */
    interface ModelExplainabilityJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.ModelExplainabilityJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    interface ModelExplainabilityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ModelExplainabilityJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    interface ModelExplainabilityJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }
    interface ModelImageConfig {
        repositoryAccessMode: string;
        repositoryAuthConfig?: outputs.sagemaker.ModelRepositoryAuthConfig;
    }
    interface ModelInferenceExecutionConfig {
        mode: string;
    }
    interface ModelMultiModelConfig {
        modelCacheSetting?: string;
    }
    /**
     * Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package.AdditionalInferenceSpecifications can be added to existing model packages using AdditionalInferenceSpecificationsToAdd.
     */
    interface ModelPackageAdditionalInferenceSpecificationDefinition {
        /**
         * The Amazon ECR registry path of the Docker image that contains the inference code.
         */
        containers: outputs.sagemaker.ModelPackageContainerDefinition[];
        /**
         * A description of the additional Inference specification.
         */
        description?: string;
        /**
         * A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.
         */
        name: string;
        /**
         * The supported MIME types for the input data.
         */
        supportedContentTypes?: string[];
        /**
         * A list of the instance types that are used to generate inferences in real-time
         */
        supportedRealtimeInferenceInstanceTypes?: string[];
        /**
         * The supported MIME types for the output data.
         */
        supportedResponseMIMETypes?: string[];
        /**
         * A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
         */
        supportedTransformInstanceTypes?: string[];
    }
    /**
     * Contains bias metrics for a model.
     */
    interface ModelPackageBias {
        postTrainingReport?: outputs.sagemaker.ModelPackageMetricsSource;
        preTrainingReport?: outputs.sagemaker.ModelPackageMetricsSource;
        report?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * Describes the Docker container for the model package.
     */
    interface ModelPackageContainerDefinition {
        /**
         * The DNS host name for the Docker container.
         */
        containerHostname?: string;
        environment?: outputs.sagemaker.ModelPackageEnvironment;
        /**
         * The machine learning framework of the model package container image.
         */
        framework?: string;
        /**
         * The framework version of the Model Package Container Image.
         */
        frameworkVersion?: string;
        /**
         * The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
         */
        image: string;
        /**
         * An MD5 hash of the training algorithm that identifies the Docker image used for training.
         */
        imageDigest?: string;
        /**
         * A structure with Model Input details.
         */
        modelDataUrl?: string;
        modelInput?: outputs.sagemaker.ModelPackageContainerDefinitionModelInputProperties;
        /**
         * The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
         */
        nearestModelName?: string;
        /**
         * The AWS Marketplace product ID of the model package.
         */
        productId?: string;
    }
    interface ModelPackageContainerDefinitionModelInputProperties {
        /**
         * The input configuration object for the model.
         */
        dataInputConfig: string;
    }
    interface ModelPackageCreatedBy {
    }
    /**
     * The metadata properties associated with the model package versions.
     */
    interface ModelPackageCustomerMetadataProperties {
    }
    /**
     * Describes the input source of a transform job and the way the transform job consumes it.
     */
    interface ModelPackageDataSource {
        s3DataSource: outputs.sagemaker.ModelPackageS3DataSource;
    }
    /**
     * Represents the drift check baselines that can be used when the model monitor is set using the model package.
     */
    interface ModelPackageDriftCheckBaselines {
        bias?: outputs.sagemaker.ModelPackageDriftCheckBias;
        explainability?: outputs.sagemaker.ModelPackageDriftCheckExplainability;
        modelDataQuality?: outputs.sagemaker.ModelPackageDriftCheckModelDataQuality;
        modelQuality?: outputs.sagemaker.ModelPackageDriftCheckModelQuality;
    }
    /**
     * Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
     */
    interface ModelPackageDriftCheckBias {
        configFile?: outputs.sagemaker.ModelPackageFileSource;
        postTrainingConstraints?: outputs.sagemaker.ModelPackageMetricsSource;
        preTrainingConstraints?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * Contains explainability metrics for a model.
     */
    interface ModelPackageDriftCheckExplainability {
        configFile?: outputs.sagemaker.ModelPackageFileSource;
        constraints?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * Represents the drift check data quality baselines that can be used when the model monitor is set using the model package.
     */
    interface ModelPackageDriftCheckModelDataQuality {
        constraints?: outputs.sagemaker.ModelPackageMetricsSource;
        statistics?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
     */
    interface ModelPackageDriftCheckModelQuality {
        constraints?: outputs.sagemaker.ModelPackageMetricsSource;
        statistics?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * Sets the environment variables in the Docker container
     */
    interface ModelPackageEnvironment {
    }
    /**
     * Contains explainability metrics for a model.
     */
    interface ModelPackageExplainability {
        report?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * Represents a File Source Object.
     */
    interface ModelPackageFileSource {
        /**
         * The digest of the file source.
         */
        contentDigest?: string;
        /**
         * The type of content stored in the file source.
         */
        contentType?: string;
        /**
         * The Amazon S3 URI for the file source.
         */
        s3Uri: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ModelPackageGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Details about inference jobs that can be run with models based on this model package.
     */
    interface ModelPackageInferenceSpecification {
        /**
         * The Amazon ECR registry path of the Docker image that contains the inference code.
         */
        containers: outputs.sagemaker.ModelPackageContainerDefinition[];
        /**
         * The supported MIME types for the input data.
         */
        supportedContentTypes: string[];
        /**
         * A list of the instance types that are used to generate inferences in real-time
         */
        supportedRealtimeInferenceInstanceTypes?: string[];
        /**
         * The supported MIME types for the output data.
         */
        supportedResponseMIMETypes: string[];
        /**
         * A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
         */
        supportedTransformInstanceTypes?: string[];
    }
    interface ModelPackageLastModifiedBy {
    }
    /**
     * Metadata properties of the tracking entity, trial, or trial component.
     */
    interface ModelPackageMetadataProperties {
        /**
         * The commit ID.
         */
        commitId?: string;
        /**
         * The entity this entity was generated by.
         */
        generatedBy?: string;
        /**
         * The project ID metadata.
         */
        projectId?: string;
        /**
         * The repository metadata.
         */
        repository?: string;
    }
    /**
     * Represents a Metric Source Object.
     */
    interface ModelPackageMetricsSource {
        /**
         * The digest of the metric source.
         */
        contentDigest?: string;
        /**
         * The type of content stored in the metric source.
         */
        contentType: string;
        /**
         * The Amazon S3 URI for the metric source.
         */
        s3Uri: string;
    }
    /**
     * Metrics that measure the quality of the input data for a model.
     */
    interface ModelPackageModelDataQuality {
        constraints?: outputs.sagemaker.ModelPackageMetricsSource;
        statistics?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * A structure that contains model metrics reports.
     */
    interface ModelPackageModelMetrics {
        bias?: outputs.sagemaker.ModelPackageBias;
        explainability?: outputs.sagemaker.ModelPackageExplainability;
        modelDataQuality?: outputs.sagemaker.ModelPackageModelDataQuality;
        modelQuality?: outputs.sagemaker.ModelPackageModelQuality;
    }
    /**
     * Metrics that measure the quality of a model.
     */
    interface ModelPackageModelQuality {
        constraints?: outputs.sagemaker.ModelPackageMetricsSource;
        statistics?: outputs.sagemaker.ModelPackageMetricsSource;
    }
    /**
     * Describes the S3 data source.
     */
    interface ModelPackageS3DataSource {
        /**
         * The S3 Data Source Type
         */
        s3DataType: enums.sagemaker.ModelPackageS3DataSourceS3DataType;
        /**
         * Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.
         */
        s3Uri: string;
    }
    /**
     * Specifies an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
     */
    interface ModelPackageSourceAlgorithm {
        /**
         * The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
         */
        algorithmName: string;
        /**
         * The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
         */
        modelDataUrl?: string;
    }
    /**
     * Details about the algorithm that was used to create the model package.
     */
    interface ModelPackageSourceAlgorithmSpecification {
        /**
         * A list of algorithms that were used to create a model package.
         */
        sourceAlgorithms: outputs.sagemaker.ModelPackageSourceAlgorithm[];
    }
    /**
     * Details about the current status of the model package.
     */
    interface ModelPackageStatusDetails {
        imageScanStatuses?: outputs.sagemaker.ModelPackageStatusItem[];
        validationStatuses: outputs.sagemaker.ModelPackageStatusItem[];
    }
    /**
     * Represents the overall status of a model package.
     */
    interface ModelPackageStatusItem {
        /**
         * If the overall status is Failed, the reason for the failure.
         */
        failureReason?: string;
        /**
         * The name of the model package for which the overall status is being reported.
         */
        name: string;
        /**
         * The current status.
         */
        status: enums.sagemaker.ModelPackageStatusItemStatus;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ModelPackageTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Describes the input source of a transform job and the way the transform job consumes it.
     */
    interface ModelPackageTransformInput {
        /**
         * If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
         */
        compressionType?: enums.sagemaker.ModelPackageTransformInputCompressionType;
        /**
         * The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
         */
        contentType?: string;
        dataSource: outputs.sagemaker.ModelPackageDataSource;
        /**
         * The method to use to split the transform job's data files into smaller batches.
         */
        splitType?: enums.sagemaker.ModelPackageTransformInputSplitType;
    }
    /**
     * Defines the input needed to run a transform job using the inference specification specified in the algorithm.
     */
    interface ModelPackageTransformJobDefinition {
        /**
         * A string that determines the number of records included in a single mini-batch.
         */
        batchStrategy?: enums.sagemaker.ModelPackageTransformJobDefinitionBatchStrategy;
        environment?: outputs.sagemaker.ModelPackageEnvironment;
        /**
         * The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
         */
        maxConcurrentTransforms?: number;
        /**
         * The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
         */
        maxPayloadInMB?: number;
        transformInput: outputs.sagemaker.ModelPackageTransformInput;
        transformOutput: outputs.sagemaker.ModelPackageTransformOutput;
        transformResources: outputs.sagemaker.ModelPackageTransformResources;
    }
    /**
     * Describes the results of a transform job.
     */
    interface ModelPackageTransformOutput {
        /**
         * The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
         */
        accept?: string;
        /**
         * Defines how to assemble the results of the transform job as a single S3 object.
         */
        assembleWith?: enums.sagemaker.ModelPackageTransformOutputAssembleWith;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.
         */
        s3OutputPath: string;
    }
    /**
     * Describes the resources, including ML instance types and ML instance count, to use for transform job.
     */
    interface ModelPackageTransformResources {
        /**
         * The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the transform job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.
         */
        volumeKmsKeyId?: string;
    }
    /**
     * Contains data, such as the inputs and targeted instance types that are used in the process of validating the model package.
     */
    interface ModelPackageValidationProfile {
        /**
         * The name of the profile for the model package.
         */
        profileName: string;
        transformJobDefinition: outputs.sagemaker.ModelPackageTransformJobDefinition;
    }
    /**
     * Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.
     */
    interface ModelPackageValidationSpecification {
        validationProfiles: outputs.sagemaker.ModelPackageValidationProfile[];
        /**
         * The IAM roles to be used for the validation of the model package.
         */
        validationRole: string;
    }
    /**
     * The batch transform input for a monitoring job.
     */
    interface ModelQualityJobDefinitionBatchTransformInput {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: string;
        datasetFormat: outputs.sagemaker.ModelQualityJobDefinitionDatasetFormat;
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        probabilityThresholdAttribute?: number;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelQualityJobDefinitionBatchTransformInputS3InputMode;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: string;
    }
    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    interface ModelQualityJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }
    /**
     * The baseline constraints resource for a monitoring job.
     */
    interface ModelQualityJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }
    /**
     * The CSV format
     */
    interface ModelQualityJobDefinitionCsv {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: boolean;
    }
    /**
     * The dataset format of the data to monitor
     */
    interface ModelQualityJobDefinitionDatasetFormat {
        csv?: outputs.sagemaker.ModelQualityJobDefinitionCsv;
        json?: outputs.sagemaker.ModelQualityJobDefinitionJson;
        parquet?: boolean;
    }
    /**
     * The endpoint for a monitoring job.
     */
    interface ModelQualityJobDefinitionEndpointInput {
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: string;
        endpointName: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        probabilityThresholdAttribute?: number;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelQualityJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelQualityJobDefinitionEndpointInputS3InputMode;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: string;
    }
    /**
     * The Json format
     */
    interface ModelQualityJobDefinitionJson {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: boolean;
    }
    /**
     * Container image configuration object for the monitoring job.
     */
    interface ModelQualityJobDefinitionModelQualityAppSpecification {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: string[];
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: string[];
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        problemType: enums.sagemaker.ModelQualityJobDefinitionProblemType;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: string;
    }
    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    interface ModelQualityJobDefinitionModelQualityBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.ModelQualityJobDefinitionConstraintsResource;
    }
    /**
     * The inputs for a monitoring job.
     */
    interface ModelQualityJobDefinitionModelQualityJobInput {
        batchTransformInput?: outputs.sagemaker.ModelQualityJobDefinitionBatchTransformInput;
        endpointInput?: outputs.sagemaker.ModelQualityJobDefinitionEndpointInput;
        groundTruthS3Input: outputs.sagemaker.ModelQualityJobDefinitionMonitoringGroundTruthS3Input;
    }
    /**
     * Ground truth input provided in S3
     */
    interface ModelQualityJobDefinitionMonitoringGroundTruthS3Input {
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    /**
     * The output object for a monitoring job.
     */
    interface ModelQualityJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.ModelQualityJobDefinitionS3Output;
    }
    /**
     * The output configuration for monitoring jobs.
     */
    interface ModelQualityJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.ModelQualityJobDefinitionMonitoringOutput[];
    }
    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    interface ModelQualityJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.ModelQualityJobDefinitionClusterConfig;
    }
    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    interface ModelQualityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.ModelQualityJobDefinitionVpcConfig;
    }
    /**
     * Information about where and how to store the results of a monitoring job.
     */
    interface ModelQualityJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.ModelQualityJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    interface ModelQualityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ModelQualityJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    interface ModelQualityJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }
    interface ModelRepositoryAuthConfig {
        repositoryCredentialsProviderArn: string;
    }
    interface ModelTag {
        key: string;
        value: string;
    }
    interface ModelVpcConfig {
        securityGroupIds: string[];
        subnets: string[];
    }
    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    interface MonitoringScheduleBaselineConfig {
        constraintsResource?: outputs.sagemaker.MonitoringScheduleConstraintsResource;
        statisticsResource?: outputs.sagemaker.MonitoringScheduleStatisticsResource;
    }
    /**
     * The batch transform input for a monitoring job.
     */
    interface MonitoringScheduleBatchTransformInput {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: string;
        datasetFormat: outputs.sagemaker.MonitoringScheduleDatasetFormat;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.MonitoringScheduleBatchTransformInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.MonitoringScheduleBatchTransformInputS3InputMode;
    }
    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    interface MonitoringScheduleClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }
    /**
     * The configuration object that specifies the monitoring schedule and defines the monitoring job.
     */
    interface MonitoringScheduleConfig {
        monitoringJobDefinition?: outputs.sagemaker.MonitoringScheduleMonitoringJobDefinition;
        /**
         * Name of the job definition
         */
        monitoringJobDefinitionName?: string;
        monitoringType?: enums.sagemaker.MonitoringScheduleMonitoringType;
        scheduleConfig?: outputs.sagemaker.MonitoringScheduleScheduleConfig;
    }
    /**
     * The baseline constraints resource for a monitoring job.
     */
    interface MonitoringScheduleConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }
    /**
     * The CSV format
     */
    interface MonitoringScheduleCsv {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: boolean;
    }
    /**
     * The dataset format of the data to monitor
     */
    interface MonitoringScheduleDatasetFormat {
        csv?: outputs.sagemaker.MonitoringScheduleCsv;
        json?: outputs.sagemaker.MonitoringScheduleJson;
        parquet?: boolean;
    }
    /**
     * The endpoint for a monitoring job.
     */
    interface MonitoringScheduleEndpointInput {
        endpointName: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.MonitoringScheduleEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.MonitoringScheduleEndpointInputS3InputMode;
    }
    /**
     * The Json format
     */
    interface MonitoringScheduleJson {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: boolean;
    }
    /**
     * Container image configuration object for the monitoring job.
     */
    interface MonitoringScheduleMonitoringAppSpecification {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: string[];
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: string[];
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: string;
    }
    /**
     * Summary of information about monitoring job
     */
    interface MonitoringScheduleMonitoringExecutionSummary {
        /**
         * The time at which the monitoring job was created.
         */
        creationTime: string;
        endpointName?: string;
        /**
         * Contains the reason a monitoring job failed, if it failed.
         */
        failureReason?: string;
        /**
         * A timestamp that indicates the last time the monitoring job was modified.
         */
        lastModifiedTime: string;
        /**
         * The status of the monitoring job.
         */
        monitoringExecutionStatus: enums.sagemaker.MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus;
        monitoringScheduleName: string;
        /**
         * The Amazon Resource Name (ARN) of the monitoring job.
         */
        processingJobArn?: string;
        /**
         * The time the monitoring job was scheduled.
         */
        scheduledTime: string;
    }
    /**
     * The inputs for a monitoring job.
     */
    interface MonitoringScheduleMonitoringInput {
        batchTransformInput?: outputs.sagemaker.MonitoringScheduleBatchTransformInput;
        endpointInput?: outputs.sagemaker.MonitoringScheduleEndpointInput;
    }
    /**
     * Defines the monitoring job.
     */
    interface MonitoringScheduleMonitoringJobDefinition {
        baselineConfig?: outputs.sagemaker.MonitoringScheduleBaselineConfig;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        monitoringAppSpecification: outputs.sagemaker.MonitoringScheduleMonitoringAppSpecification;
        monitoringInputs: outputs.sagemaker.MonitoringScheduleMonitoringInput[];
        monitoringOutputConfig: outputs.sagemaker.MonitoringScheduleMonitoringOutputConfig;
        monitoringResources: outputs.sagemaker.MonitoringScheduleMonitoringResources;
        networkConfig?: outputs.sagemaker.MonitoringScheduleNetworkConfig;
        /**
         * The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
         */
        roleArn: string;
        stoppingCondition?: outputs.sagemaker.MonitoringScheduleStoppingCondition;
    }
    /**
     * The output object for a monitoring job.
     */
    interface MonitoringScheduleMonitoringOutput {
        s3Output: outputs.sagemaker.MonitoringScheduleS3Output;
    }
    /**
     * The output configuration for monitoring jobs.
     */
    interface MonitoringScheduleMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.MonitoringScheduleMonitoringOutput[];
    }
    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    interface MonitoringScheduleMonitoringResources {
        clusterConfig: outputs.sagemaker.MonitoringScheduleClusterConfig;
    }
    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    interface MonitoringScheduleNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.MonitoringScheduleVpcConfig;
    }
    /**
     * Information about where and how to store the results of a monitoring job.
     */
    interface MonitoringScheduleS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.MonitoringScheduleS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    /**
     * Configuration details about the monitoring schedule.
     */
    interface MonitoringScheduleScheduleConfig {
        /**
         * A cron expression that describes details about the monitoring schedule.
         */
        scheduleExpression: string;
    }
    /**
     * The baseline statistics resource for a monitoring job.
     */
    interface MonitoringScheduleStatisticsResource {
        /**
         * The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
         */
        s3Uri?: string;
    }
    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    interface MonitoringScheduleStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface MonitoringScheduleTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    interface MonitoringScheduleVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }
    interface NotebookInstanceInstanceMetadataServiceConfiguration {
        minimumInstanceMetadataServiceVersion: string;
    }
    interface NotebookInstanceLifecycleConfigNotebookInstanceLifecycleHook {
        content?: string;
    }
    interface NotebookInstanceTag {
        key: string;
        value: string;
    }
    interface OfflineStoreConfigProperties {
        dataCatalogConfig?: outputs.sagemaker.FeatureGroupDataCatalogConfig;
        disableGlueTableCreation?: boolean;
        s3StorageConfig: outputs.sagemaker.FeatureGroupS3StorageConfig;
    }
    interface OnlineStoreConfigProperties {
        enableOnlineStore?: boolean;
        securityConfig?: outputs.sagemaker.FeatureGroupOnlineStoreSecurityConfig;
    }
    interface ParallelismConfigurationProperties {
        /**
         * Maximum parallel execution steps
         */
        maxParallelExecutionSteps: number;
    }
    interface PipelineDefinition0Properties {
        /**
         * A specification that defines the pipeline in JSON format.
         */
        pipelineDefinitionBody: string;
    }
    interface PipelineDefinition1Properties {
        pipelineDefinitionS3Location: outputs.sagemaker.PipelineS3Location;
    }
    interface PipelineS3Location {
        /**
         * The name of the S3 bucket where the PipelineDefinition file is stored.
         */
        bucket: string;
        /**
         * The Amazon S3 ETag (a file checksum) of the PipelineDefinition file. If you don't specify a value, SageMaker skips ETag validation of your PipelineDefinition file.
         */
        eTag?: string;
        /**
         * The file name of the PipelineDefinition file (Amazon S3 object name).
         */
        key: string;
        /**
         * For versioning-enabled buckets, a specific version of the PipelineDefinition file.
         */
        version?: string;
    }
    interface PipelineTag {
        key: string;
        value: string;
    }
    /**
     * Information about a parameter used to provision a product.
     */
    interface ProjectProvisioningParameter {
        /**
         * The parameter key.
         */
        key: string;
        /**
         * The parameter value.
         */
        value: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface ProjectTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Provisioned ServiceCatalog  Details
     */
    interface ServiceCatalogProvisionedProductDetailsProperties {
        provisionedProductId?: string;
        provisionedProductStatusMessage?: string;
    }
    /**
     * Input ServiceCatalog Provisioning Details
     */
    interface ServiceCatalogProvisioningDetailsProperties {
        pathId?: string;
        productId: string;
        provisioningArtifactId?: string;
        /**
         * Parameters specified by the administrator that are required for provisioning the product.
         */
        provisioningParameters?: outputs.sagemaker.ProjectProvisioningParameter[];
    }
    /**
     * A custom SageMaker image.
     */
    interface UserProfileCustomImage {
        /**
         * The Name of the AppImageConfig.
         */
        appImageConfigName: string;
        /**
         * The name of the CustomImage. Must be unique to your account.
         */
        imageName: string;
        /**
         * The version number of the CustomImage.
         */
        imageVersionNumber?: number;
    }
    /**
     * The JupyterServer app settings.
     */
    interface UserProfileJupyterServerAppSettings {
        defaultResourceSpec?: outputs.sagemaker.UserProfileResourceSpec;
    }
    /**
     * The kernel gateway app settings.
     */
    interface UserProfileKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: outputs.sagemaker.UserProfileCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileResourceSpec;
    }
    /**
     * A collection of settings that configure user interaction with the RStudioServerPro app.
     */
    interface UserProfileRStudioServerProAppSettings {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app.
         */
        accessStatus?: enums.sagemaker.UserProfileRStudioServerProAppSettingsAccessStatus;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
         */
        userGroup?: enums.sagemaker.UserProfileRStudioServerProAppSettingsUserGroup;
    }
    interface UserProfileResourceSpec {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: enums.sagemaker.UserProfileResourceSpecInstanceType;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: string;
    }
    /**
     * Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
     */
    interface UserProfileSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
         */
        notebookOutputOption?: enums.sagemaker.UserProfileSharingSettingsNotebookOutputOption;
        /**
         * When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
         */
        s3OutputPath?: string;
    }
    interface UserProfileTag {
        key: string;
        value: string;
    }
    /**
     * A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
     */
    interface UserProfileUserSettings {
        /**
         * The user profile Amazon Resource Name (ARN).
         */
        executionRole?: string;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: outputs.sagemaker.UserProfileJupyterServerAppSettings;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.UserProfileKernelGatewayAppSettings;
        rStudioServerProAppSettings?: outputs.sagemaker.UserProfileRStudioServerProAppSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
         */
        securityGroups?: string[];
        /**
         * The sharing settings.
         */
        sharingSettings?: outputs.sagemaker.UserProfileSharingSettings;
    }
    interface WorkteamCognitoMemberDefinition {
        cognitoClientId: string;
        cognitoUserGroup: string;
        cognitoUserPool: string;
    }
    interface WorkteamMemberDefinition {
        cognitoMemberDefinition?: outputs.sagemaker.WorkteamCognitoMemberDefinition;
        oidcMemberDefinition?: outputs.sagemaker.WorkteamOidcMemberDefinition;
    }
    interface WorkteamNotificationConfiguration {
        notificationTopicArn: string;
    }
    interface WorkteamOidcMemberDefinition {
        oidcGroups: string[];
    }
    interface WorkteamTag {
        key: string;
        value: string;
    }
}
export declare namespace secretsmanager {
    interface RotationScheduleHostedRotationLambda {
        excludeCharacters?: string;
        kmsKeyArn?: string;
        masterSecretArn?: string;
        masterSecretKmsKeyArn?: string;
        rotationLambdaName?: string;
        rotationType: string;
        superuserSecretArn?: string;
        superuserSecretKmsKeyArn?: string;
        vpcSecurityGroupIds?: string;
        vpcSubnetIds?: string;
    }
    interface RotationScheduleRotationRules {
        automaticallyAfterDays?: number;
        duration?: string;
        scheduleExpression?: string;
    }
    interface SecretGenerateSecretString {
        excludeCharacters?: string;
        excludeLowercase?: boolean;
        excludeNumbers?: boolean;
        excludePunctuation?: boolean;
        excludeUppercase?: boolean;
        generateStringKey?: string;
        includeSpace?: boolean;
        passwordLength?: number;
        requireEachIncludedType?: boolean;
        secretStringTemplate?: string;
    }
    interface SecretReplicaRegion {
        kmsKeyId?: string;
        region: string;
    }
    interface SecretTag {
        key: string;
        value: string;
    }
}
export declare namespace servicecatalog {
    interface CloudFormationProductProvisioningArtifactProperties {
        description?: string;
        disableTemplateValidation?: boolean;
        info: any;
        name?: string;
    }
    interface CloudFormationProductTag {
        key: string;
        value: string;
    }
    interface CloudFormationProvisionedProductProvisioningParameter {
        key: string;
        value: string;
    }
    interface CloudFormationProvisionedProductProvisioningPreferences {
        stackSetAccounts?: string[];
        stackSetFailureToleranceCount?: number;
        stackSetFailureTolerancePercentage?: number;
        stackSetMaxConcurrencyCount?: number;
        stackSetMaxConcurrencyPercentage?: number;
        stackSetOperationType?: enums.servicecatalog.CloudFormationProvisionedProductProvisioningPreferencesStackSetOperationType;
        stackSetRegions?: string[];
    }
    interface CloudFormationProvisionedProductTag {
        key: string;
        value: string;
    }
    interface PortfolioTag {
        key: string;
        value: string;
    }
    interface ServiceActionDefinitionParameter {
        key: string;
        value: string;
    }
}
export declare namespace servicecatalogappregistry {
    interface ApplicationTags {
    }
    interface AttributeGroupTags {
    }
}
export declare namespace servicediscovery {
    interface HttpNamespaceTag {
        key: string;
        value: string;
    }
    interface PrivateDnsNamespacePrivateDnsPropertiesMutable {
        sOA?: outputs.servicediscovery.PrivateDnsNamespaceSOA;
    }
    interface PrivateDnsNamespaceProperties {
        dnsProperties?: outputs.servicediscovery.PrivateDnsNamespacePrivateDnsPropertiesMutable;
    }
    interface PrivateDnsNamespaceSOA {
        tTL?: number;
    }
    interface PrivateDnsNamespaceTag {
        key: string;
        value: string;
    }
    interface PublicDnsNamespaceProperties {
        dnsProperties?: outputs.servicediscovery.PublicDnsNamespacePublicDnsPropertiesMutable;
    }
    interface PublicDnsNamespacePublicDnsPropertiesMutable {
        sOA?: outputs.servicediscovery.PublicDnsNamespaceSOA;
    }
    interface PublicDnsNamespaceSOA {
        tTL?: number;
    }
    interface PublicDnsNamespaceTag {
        key: string;
        value: string;
    }
    interface ServiceDnsConfig {
        dnsRecords: outputs.servicediscovery.ServiceDnsRecord[];
        namespaceId?: string;
        routingPolicy?: string;
    }
    interface ServiceDnsRecord {
        tTL: number;
        type: string;
    }
    interface ServiceHealthCheckConfig {
        failureThreshold?: number;
        resourcePath?: string;
        type: string;
    }
    interface ServiceHealthCheckCustomConfig {
        failureThreshold?: number;
    }
    interface ServiceTag {
        key: string;
        value: string;
    }
}
export declare namespace ses {
    /**
     * An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
     */
    interface ConfigurationSetDeliveryOptions {
        /**
         * The name of the dedicated IP pool to associate with the configuration set.
         */
        sendingPoolName?: string;
        /**
         * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require , messages are only delivered if a TLS connection can be established. If the value is Optional , messages can be delivered in plain text if a TLS connection can't be established.
         */
        tlsPolicy?: string;
    }
    /**
     * An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
     */
    interface ConfigurationSetEventDestinationCloudWatchDestination {
        /**
         * A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
         */
        dimensionConfigurations?: outputs.ses.ConfigurationSetEventDestinationDimensionConfiguration[];
    }
    /**
     * A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
     */
    interface ConfigurationSetEventDestinationDimensionConfiguration {
        /**
         * The default value of the dimension that is published to Amazon CloudWatch if you do not provide the value of the dimension when you send an email.
         */
        defaultDimensionValue: string;
        /**
         * The name of an Amazon CloudWatch dimension associated with an email sending metric.
         */
        dimensionName: string;
        /**
         * The place where Amazon SES finds the value of a dimension to publish to Amazon CloudWatch. To use the message tags that you specify using an X-SES-MESSAGE-TAGS header or a parameter to the SendEmail/SendRawEmail API, specify messageTag. To use your own email headers, specify emailHeader. To put a custom tag on any link included in your email, specify linkTag.
         */
        dimensionValueSource: string;
    }
    interface ConfigurationSetEventDestinationEventDestination {
        /**
         * An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
         */
        cloudWatchDestination?: outputs.ses.ConfigurationSetEventDestinationCloudWatchDestination;
        /**
         * Sets whether Amazon SES publishes events to this destination when you send an email with the associated configuration set. Set to true to enable publishing to this destination; set to false to prevent publishing to this destination. The default value is false.
         */
        enabled?: boolean;
        /**
         * An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
         */
        kinesisFirehoseDestination?: outputs.ses.ConfigurationSetEventDestinationKinesisFirehoseDestination;
        /**
         * The type of email sending events, send, reject, bounce, complaint, delivery, open, click, renderingFailure, deliveryDelay, and subscription.
         */
        matchingEventTypes: string[];
        /**
         * The name of the event destination set.
         */
        name?: string;
        /**
         * An object that contains SNS topic ARN associated event destination.
         */
        snsDestination?: outputs.ses.ConfigurationSetEventDestinationSnsDestination;
    }
    /**
     * An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
     */
    interface ConfigurationSetEventDestinationKinesisFirehoseDestination {
        /**
         * The ARN of the Amazon Kinesis Firehose stream that email sending events should be published to.
         */
        deliveryStreamARN: string;
        /**
         * The ARN of the IAM role under which Amazon SES publishes email sending events to the Amazon Kinesis Firehose stream.
         */
        iAMRoleARN: string;
    }
    /**
     * An object that contains SNS topic ARN associated event destination.
     */
    interface ConfigurationSetEventDestinationSnsDestination {
        topicARN: string;
    }
    /**
     * An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
     */
    interface ConfigurationSetReputationOptions {
        /**
         * If true , tracking of reputation metrics is enabled for the configuration set. If false , tracking of reputation metrics is disabled for the configuration set.
         */
        reputationMetricsEnabled?: boolean;
    }
    /**
     * An object that defines whether or not Amazon SES can send email that you send using the configuration set.
     */
    interface ConfigurationSetSendingOptions {
        sendingEnabled?: boolean;
    }
    /**
     * An object that contains information about the suppression list preferences for your account.
     */
    interface ConfigurationSetSuppressionOptions {
        /**
         * A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
         */
        suppressedReasons?: string[];
    }
    /**
     * An object that defines the open and click tracking options for emails that you send using the configuration set.
     */
    interface ConfigurationSetTrackingOptions {
        /**
         * The domain to use for tracking open and click events.
         */
        customRedirectDomain?: string;
    }
    interface ContactListTag {
        key: string;
        value: string;
    }
    interface ContactListTopic {
        defaultSubscriptionStatus: string;
        /**
         * The description of the topic.
         */
        description?: string;
        /**
         * The display name of the topic.
         */
        displayName: string;
        /**
         * The name of the topic.
         */
        topicName: string;
    }
    /**
     * Used to associate a configuration set with an email identity.
     */
    interface EmailIdentityConfigurationSetAttributes {
        /**
         * The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
         */
        configurationSetName?: string;
    }
    /**
     * Used to enable or disable DKIM authentication for an email identity.
     */
    interface EmailIdentityDkimAttributes {
        /**
         * Sets the DKIM signing configuration for the identity. When you set this value true, then the messages that are sent from the identity are signed using DKIM. If you set this value to false, your messages are sent without DKIM signing.
         */
        signingEnabled?: boolean;
    }
    /**
     * If your request includes this object, Amazon SES configures the identity to use Bring Your Own DKIM (BYODKIM) for DKIM authentication purposes, or, configures the key length to be used for Easy DKIM.
     */
    interface EmailIdentityDkimSigningAttributes {
        /**
         * [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
         */
        domainSigningPrivateKey?: string;
        /**
         * [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
         */
        domainSigningSelector?: string;
        /**
         * [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
         */
        nextSigningKeyLength?: string;
    }
    /**
     * Used to enable or disable feedback forwarding for an identity.
     */
    interface EmailIdentityFeedbackAttributes {
        /**
         * If the value is true, you receive email notifications when bounce or complaint events occur
         */
        emailForwardingEnabled?: boolean;
    }
    /**
     * Used to enable or disable the custom Mail-From domain configuration for an email identity.
     */
    interface EmailIdentityMailFromAttributes {
        /**
         * The action to take if the required MX record isn't found when you send an email. When you set this value to UseDefaultValue , the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to RejectMessage , the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email.
         */
        behaviorOnMxFailure?: string;
        /**
         * The custom MAIL FROM domain that you want the verified identity to use
         */
        mailFromDomain?: string;
    }
    interface ReceiptFilterFilter {
        ipFilter: outputs.ses.ReceiptFilterIpFilter;
        name?: string;
    }
    interface ReceiptFilterIpFilter {
        cidr: string;
        policy: string;
    }
    interface ReceiptRuleAction {
        addHeaderAction?: outputs.ses.ReceiptRuleAddHeaderAction;
        bounceAction?: outputs.ses.ReceiptRuleBounceAction;
        lambdaAction?: outputs.ses.ReceiptRuleLambdaAction;
        s3Action?: outputs.ses.ReceiptRuleS3Action;
        sNSAction?: outputs.ses.ReceiptRuleSNSAction;
        stopAction?: outputs.ses.ReceiptRuleStopAction;
        workmailAction?: outputs.ses.ReceiptRuleWorkmailAction;
    }
    interface ReceiptRuleAddHeaderAction {
        headerName: string;
        headerValue: string;
    }
    interface ReceiptRuleBounceAction {
        message: string;
        sender: string;
        smtpReplyCode: string;
        statusCode?: string;
        topicArn?: string;
    }
    interface ReceiptRuleLambdaAction {
        functionArn: string;
        invocationType?: string;
        topicArn?: string;
    }
    interface ReceiptRuleRule {
        actions?: outputs.ses.ReceiptRuleAction[];
        enabled?: boolean;
        name?: string;
        recipients?: string[];
        scanEnabled?: boolean;
        tlsPolicy?: string;
    }
    interface ReceiptRuleS3Action {
        bucketName: string;
        kmsKeyArn?: string;
        objectKeyPrefix?: string;
        topicArn?: string;
    }
    interface ReceiptRuleSNSAction {
        encoding?: string;
        topicArn?: string;
    }
    interface ReceiptRuleStopAction {
        scope: string;
        topicArn?: string;
    }
    interface ReceiptRuleWorkmailAction {
        organizationArn: string;
        topicArn?: string;
    }
    /**
     * The content of the email, composed of a subject line, an HTML part, and a text-only part
     */
    interface Template {
        /**
         * The HTML body of the email.
         */
        htmlPart?: string;
        /**
         * The subject line of the email.
         */
        subjectPart: string;
        /**
         * The name of the template.
         */
        templateName?: string;
        /**
         * The email body that is visible to recipients whose email clients do not display HTML content.
         */
        textPart?: string;
    }
}
export declare namespace signer {
    interface SigningProfileSignatureValidityPeriod {
        type?: enums.signer.SigningProfileSignatureValidityPeriodType;
        value?: number;
    }
    interface SigningProfileTag {
        key?: string;
        value?: string;
    }
}
export declare namespace sns {
    interface TopicSubscription {
        endpoint: string;
        protocol: string;
    }
    interface TopicTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, `_`, `.`, `/`, `=`, `+`, and `-`.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 characters in length.
         */
        value: string;
    }
}
export declare namespace sqs {
    interface QueueTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace ssm {
    interface AssociationInstanceAssociationOutputLocation {
        s3Location?: outputs.ssm.AssociationS3OutputLocation;
    }
    interface AssociationS3OutputLocation {
        outputS3BucketName?: string;
        outputS3KeyPrefix?: string;
        outputS3Region?: string;
    }
    interface AssociationTarget {
        key: string;
        values: string[];
    }
    interface DocumentAttachmentsSource {
        /**
         * The key of a key-value pair that identifies the location of an attachment to a document.
         */
        key?: enums.ssm.DocumentAttachmentsSourceKey;
        /**
         * The name of the document attachment file.
         */
        name?: string;
        /**
         * The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
         */
        values?: string[];
    }
    interface DocumentRequires {
        /**
         * The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
         */
        name?: string;
        /**
         * The document version required by the current document.
         */
        version?: string;
    }
    interface DocumentTag {
        /**
         * The name of the tag.
         */
        key?: string;
        /**
         * The value of the tag.
         */
        value?: string;
    }
    interface MaintenanceWindowTag {
        key: string;
        value: string;
    }
    interface MaintenanceWindowTargetTargets {
        key: string;
        values: string[];
    }
    interface MaintenanceWindowTaskCloudWatchOutputConfig {
        cloudWatchLogGroupName?: string;
        cloudWatchOutputEnabled?: boolean;
    }
    interface MaintenanceWindowTaskLoggingInfo {
        region: string;
        s3Bucket: string;
        s3Prefix?: string;
    }
    interface MaintenanceWindowTaskMaintenanceWindowAutomationParameters {
        documentVersion?: string;
        parameters?: any;
    }
    interface MaintenanceWindowTaskMaintenanceWindowLambdaParameters {
        clientContext?: string;
        payload?: string;
        qualifier?: string;
    }
    interface MaintenanceWindowTaskMaintenanceWindowRunCommandParameters {
        cloudWatchOutputConfig?: outputs.ssm.MaintenanceWindowTaskCloudWatchOutputConfig;
        comment?: string;
        documentHash?: string;
        documentHashType?: string;
        documentVersion?: string;
        notificationConfig?: outputs.ssm.MaintenanceWindowTaskNotificationConfig;
        outputS3BucketName?: string;
        outputS3KeyPrefix?: string;
        parameters?: any;
        serviceRoleArn?: string;
        timeoutSeconds?: number;
    }
    interface MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters {
        input?: string;
        name?: string;
    }
    interface MaintenanceWindowTaskNotificationConfig {
        notificationArn: string;
        notificationEvents?: string[];
        notificationType?: string;
    }
    interface MaintenanceWindowTaskTarget {
        key: string;
        values: string[];
    }
    interface MaintenanceWindowTaskTaskInvocationParameters {
        maintenanceWindowAutomationParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowAutomationParameters;
        maintenanceWindowLambdaParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowLambdaParameters;
        maintenanceWindowRunCommandParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowRunCommandParameters;
        maintenanceWindowStepFunctionsParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters;
    }
    interface PatchBaselinePatchFilter {
        key?: string;
        values?: string[];
    }
    interface PatchBaselinePatchFilterGroup {
        patchFilters?: outputs.ssm.PatchBaselinePatchFilter[];
    }
    interface PatchBaselinePatchSource {
        configuration?: string;
        name?: string;
        products?: string[];
    }
    interface PatchBaselinePatchStringDate {
    }
    interface PatchBaselineRule {
        approveAfterDays?: number;
        approveUntilDate?: outputs.ssm.PatchBaselinePatchStringDate;
        complianceLevel?: string;
        enableNonSecurity?: boolean;
        patchFilterGroup?: outputs.ssm.PatchBaselinePatchFilterGroup;
    }
    interface PatchBaselineRuleGroup {
        patchRules?: outputs.ssm.PatchBaselineRule[];
    }
    interface PatchBaselineTag {
        key: string;
        value: string;
    }
    interface ResourceDataSyncAwsOrganizationsSource {
        organizationSourceType: string;
        organizationalUnits?: string[];
    }
    interface ResourceDataSyncS3Destination {
        bucketName: string;
        bucketPrefix?: string;
        bucketRegion: string;
        kMSKeyArn?: string;
        syncFormat: string;
    }
    interface ResourceDataSyncSyncSource {
        awsOrganizationsSource?: outputs.ssm.ResourceDataSyncAwsOrganizationsSource;
        includeFutureRegions?: boolean;
        sourceRegions: string[];
        sourceType: string;
    }
}
export declare namespace ssmcontacts {
    /**
     * Information about the contact channel that SSM Incident Manager uses to engage the contact.
     */
    interface ContactChannelTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact channel.
         */
        channelId: string;
        /**
         * The number of minutes to wait to retry sending engagement in the case the engagement initially fails.
         */
        retryIntervalInMinutes: number;
    }
    /**
     * A set amount of time that an escalation plan or engagement plan engages the specified contacts or contact methods.
     */
    interface ContactStage {
        /**
         * The time to wait until beginning the next stage.
         */
        durationInMinutes: number;
        /**
         * The contacts or contact methods that the escalation plan or engagement plan is engaging.
         */
        targets?: outputs.ssmcontacts.ContactTargets[];
    }
    /**
     * The contact that SSM Incident Manager is engaging during an incident.
     */
    interface ContactTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact.
         */
        contactId: string;
        /**
         * A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
         */
        isEssential: boolean;
    }
    /**
     * The contacts or contact methods that the escalation plan or engagement plan is engaging.
     */
    interface ContactTargets {
        channelTargetInfo?: outputs.ssmcontacts.ContactChannelTargetInfo;
        contactTargetInfo?: outputs.ssmcontacts.ContactTargetInfo;
    }
}
export declare namespace ssmincidents {
    /**
     * The ReplicationSet regional configuration.
     */
    interface ReplicationSetRegionConfiguration {
        sseKmsKeyId: string;
    }
    /**
     * The ReplicationSet regional configuration.
     */
    interface ReplicationSetReplicationRegion {
        regionConfiguration?: outputs.ssmincidents.ReplicationSetRegionConfiguration;
        regionName?: string;
    }
    /**
     * The automation configuration to launch.
     */
    interface ResponsePlanAction {
        ssmAutomation?: outputs.ssmincidents.ResponsePlanSsmAutomation;
    }
    /**
     * The chat channel configuration.
     */
    interface ResponsePlanChatChannel {
        chatbotSns?: string[];
    }
    /**
     * A parameter with a dynamic value to set when starting the SSM automation document.
     */
    interface ResponsePlanDynamicSsmParameter {
        key: string;
        value: outputs.ssmincidents.ResponsePlanDynamicSsmParameterValue;
    }
    /**
     * Value of the dynamic parameter to set when starting the SSM automation document.
     */
    interface ResponsePlanDynamicSsmParameterValue {
        variable?: enums.ssmincidents.ResponsePlanVariableType;
    }
    /**
     * The incident template configuration.
     */
    interface ResponsePlanIncidentTemplate {
        /**
         * The deduplication string.
         */
        dedupeString?: string;
        /**
         * The impact value.
         */
        impact: number;
        /**
         * Tags that get applied to incidents created by the StartIncident API action.
         */
        incidentTags?: outputs.ssmincidents.ResponsePlanTag[];
        /**
         * The list of notification targets.
         */
        notificationTargets?: outputs.ssmincidents.ResponsePlanNotificationTargetItem[];
        /**
         * The summary string.
         */
        summary?: string;
        /**
         * The title string.
         */
        title: string;
    }
    /**
     * A notification target.
     */
    interface ResponsePlanNotificationTargetItem {
        snsTopicArn?: string;
    }
    /**
     * The configuration to use when starting the SSM automation document.
     */
    interface ResponsePlanSsmAutomation {
        /**
         * The document name to use when starting the SSM automation document.
         */
        documentName: string;
        /**
         * The version of the document to use when starting the SSM automation document.
         */
        documentVersion?: string;
        /**
         * The parameters with dynamic values to set when starting the SSM automation document.
         */
        dynamicParameters?: outputs.ssmincidents.ResponsePlanDynamicSsmParameter[];
        /**
         * The parameters to set when starting the SSM automation document.
         */
        parameters?: outputs.ssmincidents.ResponsePlanSsmParameter[];
        /**
         * The role ARN to use when starting the SSM automation document.
         */
        roleArn: string;
        /**
         * The account type to use when starting the SSM automation document.
         */
        targetAccount?: enums.ssmincidents.ResponsePlanSsmAutomationTargetAccount;
    }
    /**
     * A parameter to set when starting the SSM automation document.
     */
    interface ResponsePlanSsmParameter {
        key: string;
        values: string[];
    }
    /**
     * A key-value pair to tag a resource.
     */
    interface ResponsePlanTag {
        key: string;
        value: string;
    }
}
export declare namespace sso {
    interface InstanceAccessControlAttributeConfigurationAccessControlAttribute {
        key: string;
        value: outputs.sso.InstanceAccessControlAttributeConfigurationAccessControlAttributeValue;
    }
    interface InstanceAccessControlAttributeConfigurationAccessControlAttributeValue {
        source: string[];
    }
    /**
     * The InstanceAccessControlAttributeConfiguration property has been deprecated but is still supported for backwards compatibility purposes. We recomend that you use  AccessControlAttributes property instead.
     */
    interface InstanceAccessControlAttributeConfigurationProperties {
        accessControlAttributes: outputs.sso.InstanceAccessControlAttributeConfigurationAccessControlAttribute[];
    }
    interface PermissionSetCustomerManagedPolicyReference {
        name: string;
        path?: string;
    }
    interface PermissionSetPermissionsBoundary {
        customerManagedPolicyReference?: outputs.sso.PermissionSetCustomerManagedPolicyReference;
        managedPolicyArn?: string;
    }
    /**
     * The metadata that you apply to the permission set to help you categorize and organize them.
     */
    interface PermissionSetTag {
        key: string;
        value: string;
    }
}
export declare namespace stepfunctions {
    interface ActivityTagsEntry {
        key: string;
        value: string;
    }
    interface StateMachineCloudWatchLogsLogGroup {
        logGroupArn?: string;
    }
    interface StateMachineDefinition {
    }
    interface StateMachineDefinitionSubstitutions {
    }
    interface StateMachineLogDestination {
        cloudWatchLogsLogGroup?: outputs.stepfunctions.StateMachineCloudWatchLogsLogGroup;
    }
    interface StateMachineLoggingConfiguration {
        destinations?: outputs.stepfunctions.StateMachineLogDestination[];
        includeExecutionData?: boolean;
        level?: enums.stepfunctions.StateMachineLoggingConfigurationLevel;
    }
    interface StateMachineS3Location {
        bucket: string;
        key: string;
        version?: string;
    }
    interface StateMachineTagsEntry {
        key: string;
        value: string;
    }
    interface StateMachineTracingConfiguration {
        enabled?: boolean;
    }
}
export declare namespace synthetics {
    interface CanaryArtifactConfig {
        /**
         * Encryption configuration for uploading artifacts to S3
         */
        s3Encryption?: outputs.synthetics.CanaryS3Encryption;
    }
    interface CanaryBaseScreenshot {
        /**
         * List of coordinates of rectangles to be ignored during visual testing
         */
        ignoreCoordinates?: string[];
        /**
         * Name of the screenshot to be used as base reference for visual testing
         */
        screenshotName: string;
    }
    interface CanaryCode {
        handler: string;
        s3Bucket?: string;
        s3Key?: string;
        s3ObjectVersion?: string;
        script?: string;
    }
    interface CanaryRunConfig {
        /**
         * Enable active tracing if set to true
         */
        activeTracing?: boolean;
        /**
         * Environment variable key-value pairs.
         */
        environmentVariables?: any;
        /**
         * Provide maximum memory available for canary in MB
         */
        memoryInMB?: number;
        /**
         * Provide maximum canary timeout per run in seconds
         */
        timeoutInSeconds?: number;
    }
    interface CanaryS3Encryption {
        /**
         * Encryption mode for encrypting artifacts when uploading to S3. Valid values: SSE_S3 and SSE_KMS.
         */
        encryptionMode?: string;
        /**
         * KMS key Arn for encrypting artifacts when uploading to S3. You must specify KMS key Arn for SSE_KMS encryption mode only.
         */
        kmsKeyArn?: string;
    }
    interface CanarySchedule {
        durationInSeconds?: string;
        expression: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface CanaryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    interface CanaryVPCConfig {
        securityGroupIds: string[];
        subnetIds: string[];
        vpcId?: string;
    }
    interface CanaryVisualReference {
        /**
         * Canary run id to be used as base reference for visual testing
         */
        baseCanaryRunId: string;
        /**
         * List of screenshots used as base reference for visual testing
         */
        baseScreenshots?: outputs.synthetics.CanaryBaseScreenshot[];
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface GroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
}
export declare namespace timestream {
    /**
     * You can use the Resource Tags property to apply tags to resources, which can help you identify and categorize those resources.
     */
    interface DatabaseTag {
        key?: string;
        value?: string;
    }
    /**
     * The properties that determine whether magnetic store writes are enabled.
     */
    interface MagneticStoreWritePropertiesProperties {
        /**
         * Boolean flag indicating whether magnetic store writes are enabled.
         */
        enableMagneticStoreWrites: boolean;
        /**
         * Location to store information about records that were asynchronously rejected during magnetic store writes.
         */
        magneticStoreRejectedDataLocation?: outputs.timestream.MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationProperties;
    }
    /**
     * Location to store information about records that were asynchronously rejected during magnetic store writes.
     */
    interface MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationProperties {
        /**
         * S3 configuration for location to store rejections from magnetic store writes
         */
        s3Configuration?: outputs.timestream.MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationProperties;
    }
    /**
     * S3 configuration for location to store rejections from magnetic store writes
     */
    interface MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationProperties {
        /**
         * The bucket name used to store the data.
         */
        bucketName: string;
        /**
         * Either SSE_KMS or SSE_S3.
         */
        encryptionOption: string;
        /**
         * Must be provided if SSE_KMS is specified as the encryption option
         */
        kmsKeyId?: string;
        /**
         * String used to prefix all data in the bucket.
         */
        objectKeyPrefix?: string;
    }
    /**
     * The retention duration of the memory store and the magnetic store.
     */
    interface RetentionPropertiesProperties {
        /**
         * The duration for which data must be stored in the magnetic store.
         */
        magneticStoreRetentionPeriodInDays?: string;
        /**
         * The duration for which data must be stored in the memory store.
         */
        memoryStoreRetentionPeriodInHours?: string;
    }
    /**
     * This type is used to map column(s) from the query result to a dimension in the destination table.
     */
    interface ScheduledQueryDimensionMapping {
        dimensionValueType: enums.timestream.ScheduledQueryDimensionValueType;
        name: string;
    }
    /**
     * Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.
     */
    interface ScheduledQueryErrorReportConfiguration {
        s3Configuration: outputs.timestream.ScheduledQueryS3Configuration;
    }
    /**
     * MixedMeasureMappings are mappings that can be used to ingest data into a mixture of narrow and multi measures in the derived table.
     */
    interface ScheduledQueryMixedMeasureMapping {
        measureName?: string;
        measureValueType: enums.timestream.ScheduledQueryMixedMeasureMappingMeasureValueType;
        multiMeasureAttributeMappings?: outputs.timestream.ScheduledQueryMultiMeasureAttributeMapping[];
        sourceColumn?: string;
        targetMeasureName?: string;
    }
    /**
     * An attribute mapping to be used for mapping query results to ingest data for multi-measure attributes.
     */
    interface ScheduledQueryMultiMeasureAttributeMapping {
        measureValueType: enums.timestream.ScheduledQueryMultiMeasureAttributeMappingMeasureValueType;
        sourceColumn: string;
        targetMultiMeasureAttributeName?: string;
    }
    /**
     * Only one of MixedMeasureMappings or MultiMeasureMappings is to be provided. MultiMeasureMappings can be used to ingest data as multi measures in the derived table.
     */
    interface ScheduledQueryMultiMeasureMappings {
        multiMeasureAttributeMappings: outputs.timestream.ScheduledQueryMultiMeasureAttributeMapping[];
        targetMultiMeasureName?: string;
    }
    /**
     * Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.
     */
    interface ScheduledQueryNotificationConfiguration {
        snsConfiguration: outputs.timestream.ScheduledQuerySnsConfiguration;
    }
    /**
     * Details on S3 location for error reports that result from running a query.
     */
    interface ScheduledQueryS3Configuration {
        bucketName: string;
        encryptionOption?: enums.timestream.ScheduledQueryEncryptionOption;
        objectKeyPrefix?: string;
    }
    /**
     * Configuration for when the scheduled query is executed.
     */
    interface ScheduledQueryScheduleConfiguration {
        scheduleExpression: string;
    }
    /**
     * SNS configuration for notification upon scheduled query execution.
     */
    interface ScheduledQuerySnsConfiguration {
        topicArn: string;
    }
    /**
     * A key-value pair to label the scheduled query.
     */
    interface ScheduledQueryTag {
        key: string;
        value: string;
    }
    /**
     * Configuration of target store where scheduled query results are written to.
     */
    interface ScheduledQueryTargetConfiguration {
        timestreamConfiguration: outputs.timestream.ScheduledQueryTimestreamConfiguration;
    }
    /**
     * Configuration needed to write data into the Timestream database and table.
     */
    interface ScheduledQueryTimestreamConfiguration {
        databaseName: string;
        dimensionMappings: outputs.timestream.ScheduledQueryDimensionMapping[];
        measureNameColumn?: string;
        mixedMeasureMappings?: outputs.timestream.ScheduledQueryMixedMeasureMapping[];
        multiMeasureMappings?: outputs.timestream.ScheduledQueryMultiMeasureMappings;
        tableName: string;
        timeColumn: string;
    }
    /**
     * You can use the Resource Tags property to apply tags to resources, which can help you identify and categorize those resources.
     */
    interface TableTag {
        key?: string;
        value?: string;
    }
}
export declare namespace transfer {
    /**
     * Creates a key-value pair for a specific resource.
     */
    interface AgreementTag {
        /**
         * The name assigned to the tag that you create.
         */
        key: string;
        /**
         * Contains one or more values that you assigned to the key name you create.
         */
        value: string;
    }
    /**
     * Configuration for an AS2 connector.
     */
    interface As2ConfigProperties {
        /**
         * Compression setting for this AS2 connector configuration.
         */
        compression?: enums.transfer.ConnectorAs2ConfigPropertiesCompression;
        /**
         * Encryption algorithm for this AS2 connector configuration.
         */
        encryptionAlgorithm?: enums.transfer.ConnectorAs2ConfigPropertiesEncryptionAlgorithm;
        /**
         * A unique identifier for the local profile.
         */
        localProfileId?: string;
        /**
         * MDN Response setting for this AS2 connector configuration.
         */
        mdnResponse?: enums.transfer.ConnectorAs2ConfigPropertiesMdnResponse;
        /**
         * MDN Signing algorithm for this AS2 connector configuration.
         */
        mdnSigningAlgorithm?: enums.transfer.ConnectorAs2ConfigPropertiesMdnSigningAlgorithm;
        /**
         * The message subject for this AS2 connector configuration.
         */
        messageSubject?: string;
        /**
         * A unique identifier for the partner profile.
         */
        partnerProfileId?: string;
        /**
         * Signing algorithm for this AS2 connector configuration.
         */
        signingAlgorithm?: enums.transfer.ConnectorAs2ConfigPropertiesSigningAlgorithm;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface CertificateTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }
    /**
     * Creates a key-value pair for a specific resource.
     */
    interface ConnectorTag {
        /**
         * The name assigned to the tag that you create.
         */
        key: string;
        /**
         * Contains one or more values that you assigned to the key name you create.
         */
        value: string;
    }
    /**
     * Creates a key-value pair for a specific resource.
     */
    interface ProfileTag {
        /**
         * The name assigned to the tag that you create.
         */
        key: string;
        /**
         * Contains one or more values that you assigned to the key name you create.
         */
        value: string;
    }
    interface ServerAs2Transport {
    }
    interface ServerEndpointDetails {
        addressAllocationIds?: string[];
        securityGroupIds?: string[];
        subnetIds?: string[];
        vpcEndpointId?: string;
        vpcId?: string;
    }
    interface ServerIdentityProviderDetails {
        directoryId?: string;
        function?: string;
        invocationRole?: string;
        url?: string;
    }
    interface ServerProtocol {
    }
    interface ServerProtocolDetails {
        as2Transports?: outputs.transfer.ServerAs2Transport[];
        passiveIp?: string;
        setStatOption?: string;
        tlsSessionResumptionMode?: string;
    }
    interface ServerTag {
        key: string;
        value: string;
    }
    interface ServerWorkflowDetail {
        executionRole: string;
        workflowId: string;
    }
    interface ServerWorkflowDetails {
        onPartialUpload?: outputs.transfer.ServerWorkflowDetail[];
        onUpload?: outputs.transfer.ServerWorkflowDetail[];
    }
    interface UserHomeDirectoryMapEntry {
        entry: string;
        target: string;
    }
    interface UserPosixProfile {
        gid: number;
        secondaryGids?: number[];
        uid: number;
    }
    interface UserSshPublicKey {
    }
    interface UserTag {
        key: string;
        value: string;
    }
    /**
     * Specifies the location for the file being copied. Only applicable for the Copy type of workflow steps.
     */
    interface WorkflowInputFileLocation {
        s3FileLocation?: outputs.transfer.WorkflowS3InputFileLocation;
    }
    /**
     * Specifies the details for the S3 file being copied.
     */
    interface WorkflowS3InputFileLocation {
        /**
         * Specifies the S3 bucket that contains the file being copied.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }
    /**
     * Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
     */
    interface WorkflowS3Tag {
        /**
         * The name assigned to the tag that you create.
         */
        key: string;
        /**
         * The value that corresponds to the key.
         */
        value: string;
    }
    /**
     * The basic building block of a workflow.
     */
    interface WorkflowStep {
        /**
         * Details for a step that performs a file copy.
         */
        copyStepDetails?: outputs.transfer.WorkflowStepCopyStepDetailsProperties;
        /**
         * Details for a step that invokes a lambda function.
         */
        customStepDetails?: outputs.transfer.WorkflowStepCustomStepDetailsProperties;
        /**
         * Details for a step that deletes the file.
         */
        deleteStepDetails?: outputs.transfer.WorkflowStepDeleteStepDetailsProperties;
        /**
         * Details for a step that creates one or more tags.
         */
        tagStepDetails?: outputs.transfer.WorkflowStepTagStepDetailsProperties;
        type?: enums.transfer.WorkflowStepType;
    }
    /**
     * Details for a step that performs a file copy.
     */
    interface WorkflowStepCopyStepDetailsProperties {
        destinationFileLocation?: outputs.transfer.WorkflowInputFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE.
         */
        overwriteExisting?: enums.transfer.WorkflowStepCopyStepDetailsPropertiesOverwriteExisting;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: string;
    }
    /**
     * Details for a step that invokes a lambda function.
     */
    interface WorkflowStepCustomStepDetailsProperties {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: string;
        /**
         * The ARN for the lambda function that is being called.
         */
        target?: string;
        /**
         * Timeout, in seconds, for the step.
         */
        timeoutSeconds?: number;
    }
    /**
     * Details for a step that deletes the file.
     */
    interface WorkflowStepDeleteStepDetailsProperties {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: string;
    }
    /**
     * Details for a step that creates one or more tags.
     */
    interface WorkflowStepTagStepDetailsProperties {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: string;
        /**
         * Array that contains from 1 to 10 key/value pairs.
         */
        tags?: outputs.transfer.WorkflowS3Tag[];
    }
    /**
     * Creates a key-value pair for a specific resource.
     */
    interface WorkflowTag {
        /**
         * The name assigned to the tag that you create.
         */
        key: string;
        /**
         * Contains one or more values that you assigned to the key name you create.
         */
        value: string;
    }
}
export declare namespace voiceid {
    interface DomainServerSideEncryptionConfiguration {
        kmsKeyId: string;
    }
    interface DomainTag {
        key: string;
        value: string;
    }
}
export declare namespace waf {
    interface ByteMatchSetByteMatchTuple {
        fieldToMatch: outputs.waf.ByteMatchSetFieldToMatch;
        positionalConstraint: string;
        targetString?: string;
        targetStringBase64?: string;
        textTransformation: string;
    }
    interface ByteMatchSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface IPSetDescriptor {
        type: string;
        value: string;
    }
    interface RulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }
    interface SizeConstraintSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface SizeConstraintSetSizeConstraint {
        comparisonOperator: string;
        fieldToMatch: outputs.waf.SizeConstraintSetFieldToMatch;
        size: number;
        textTransformation: string;
    }
    interface SqlInjectionMatchSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        fieldToMatch: outputs.waf.SqlInjectionMatchSetFieldToMatch;
        textTransformation: string;
    }
    interface WebACLActivatedRule {
        action?: outputs.waf.WebACLWafAction;
        priority: number;
        ruleId: string;
    }
    interface WebACLWafAction {
        type: string;
    }
    interface XssMatchSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface XssMatchSetXssMatchTuple {
        fieldToMatch: outputs.waf.XssMatchSetFieldToMatch;
        textTransformation: string;
    }
}
export declare namespace wafregional {
    interface ByteMatchSetByteMatchTuple {
        fieldToMatch: outputs.wafregional.ByteMatchSetFieldToMatch;
        positionalConstraint: string;
        targetString?: string;
        targetStringBase64?: string;
        textTransformation: string;
    }
    interface ByteMatchSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface GeoMatchSetGeoMatchConstraint {
        type: string;
        value: string;
    }
    interface IPSetDescriptor {
        type: string;
        value: string;
    }
    interface RateBasedRulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }
    interface RulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }
    interface SizeConstraintSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface SizeConstraintSetSizeConstraint {
        comparisonOperator: string;
        fieldToMatch: outputs.wafregional.SizeConstraintSetFieldToMatch;
        size: number;
        textTransformation: string;
    }
    interface SqlInjectionMatchSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        fieldToMatch: outputs.wafregional.SqlInjectionMatchSetFieldToMatch;
        textTransformation: string;
    }
    interface WebACLAction {
        type: string;
    }
    interface WebACLRule {
        action: outputs.wafregional.WebACLAction;
        priority: number;
        ruleId: string;
    }
    interface XssMatchSetFieldToMatch {
        data?: string;
        type: string;
    }
    interface XssMatchSetXssMatchTuple {
        fieldToMatch: outputs.wafregional.XssMatchSetFieldToMatch;
        textTransformation: string;
    }
}
export declare namespace wafv2 {
    interface IPSetTag {
        key?: string;
        value?: string;
    }
    interface LoggingConfigurationCondition {
        /**
         * A single action condition.
         */
        actionCondition?: outputs.wafv2.LoggingConfigurationConditionActionConditionProperties;
        /**
         * A single label name condition.
         */
        labelNameCondition?: outputs.wafv2.LoggingConfigurationConditionLabelNameConditionProperties;
    }
    /**
     * A single action condition.
     */
    interface LoggingConfigurationConditionActionConditionProperties {
        /**
         * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
         */
        action: enums.wafv2.LoggingConfigurationConditionActionConditionPropertiesAction;
    }
    /**
     * A single label name condition.
     */
    interface LoggingConfigurationConditionLabelNameConditionProperties {
        /**
         * The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.
         */
        labelName: string;
    }
    /**
     * A key-value pair to associate with a resource.
     */
    interface LoggingConfigurationFieldToMatch {
        /**
         * Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
         */
        jsonBody?: outputs.wafv2.LoggingConfigurationFieldToMatchJsonBodyProperties;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: any;
        /**
         * Inspect the query string. This is the part of a URL that appears after a ? character, if any.
         */
        queryString?: any;
        /**
         * Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
         */
        singleHeader?: outputs.wafv2.LoggingConfigurationFieldToMatchSingleHeaderProperties;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
         */
        uriPath?: any;
    }
    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
     */
    interface LoggingConfigurationFieldToMatchJsonBodyProperties {
        /**
         * What AWS WAF should do if it fails to completely parse the JSON body.
         */
        invalidFallbackBehavior?: enums.wafv2.LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior;
        /**
         * The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
         */
        matchPattern: outputs.wafv2.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties;
        /**
         * The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values.
         */
        matchScope: enums.wafv2.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope;
    }
    /**
     * The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
     */
    interface LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties {
        /**
         * Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
         */
        all?: any;
        /**
         * Match only the specified include paths. See also MatchScope in JsonBody.
         */
        includedPaths?: string[];
    }
    /**
     * Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
     */
    interface LoggingConfigurationFieldToMatchSingleHeaderProperties {
        /**
         * The name of the query header to inspect.
         */
        name: string;
    }
    interface LoggingConfigurationFilter {
        /**
         * How to handle logs that satisfy the filter's conditions and requirement.
         */
        behavior: enums.wafv2.LoggingConfigurationFilterBehavior;
        /**
         * Match conditions for the filter.
         */
        conditions: outputs.wafv2.LoggingConfigurationCondition[];
        /**
         * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
         */
        requirement: enums.wafv2.LoggingConfigurationFilterRequirement;
    }
    /**
     * Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
     */
    interface LoggingFilterProperties {
        /**
         * Default handling for logs that don't match any of the specified filtering conditions.
         */
        defaultBehavior: enums.wafv2.LoggingConfigurationLoggingFilterPropertiesDefaultBehavior;
        /**
         * The filters that you want to apply to the logs.
         */
        filters: outputs.wafv2.LoggingConfigurationFilter[];
    }
    interface RegexPatternSetTag {
        key?: string;
        value?: string;
    }
    interface RuleGroupAndStatement {
        statements: outputs.wafv2.RuleGroupStatement[];
    }
    /**
     * The body of a web request. This immediately follows the request headers.
     */
    interface RuleGroupBody {
        oversizeHandling?: enums.wafv2.RuleGroupOversizeHandling;
    }
    /**
     * Byte Match statement.
     */
    interface RuleGroupByteMatchStatement {
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        positionalConstraint: enums.wafv2.RuleGroupPositionalConstraint;
        searchString?: string;
        searchStringBase64?: string;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }
    interface RuleGroupCaptchaConfig {
        immunityTimeProperty?: outputs.wafv2.RuleGroupImmunityTimeProperty;
    }
    /**
     * The pattern to look for in the request cookies.
     */
    interface RuleGroupCookieMatchPattern {
        /**
         * Inspect all parts of the web request cookies.
         */
        all?: any;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    /**
     * Includes headers of a web request.
     */
    interface RuleGroupCookies {
        matchPattern: outputs.wafv2.RuleGroupCookieMatchPattern;
        matchScope: enums.wafv2.RuleGroupMapMatchScope;
        oversizeHandling: enums.wafv2.RuleGroupOversizeHandling;
    }
    /**
     * HTTP header.
     */
    interface RuleGroupCustomHTTPHeader {
        name: string;
        value: string;
    }
    /**
     * Custom request handling.
     */
    interface RuleGroupCustomRequestHandling {
        /**
         * Collection of HTTP headers.
         */
        insertHeaders: outputs.wafv2.RuleGroupCustomHTTPHeader[];
    }
    /**
     * Custom response.
     */
    interface RuleGroupCustomResponse {
        /**
         * Custom response body key.
         */
        customResponseBodyKey?: string;
        responseCode: number;
        /**
         * Collection of HTTP headers.
         */
        responseHeaders?: outputs.wafv2.RuleGroupCustomHTTPHeader[];
    }
    /**
     * Custom response key and body map.
     */
    interface RuleGroupCustomResponseBodies {
    }
    /**
     * Field of the request to match.
     */
    interface RuleGroupFieldToMatch {
        /**
         * All query arguments of a web request.
         */
        allQueryArguments?: any;
        body?: outputs.wafv2.RuleGroupBody;
        cookies?: outputs.wafv2.RuleGroupCookies;
        headers?: outputs.wafv2.RuleGroupHeaders;
        jsonBody?: outputs.wafv2.RuleGroupJsonBody;
        /**
         * The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: any;
        /**
         * The query string of a web request. This is the part of a URL that appears after a ? character, if any.
         */
        queryString?: any;
        singleHeader?: outputs.wafv2.RuleGroupFieldToMatchSingleHeaderProperties;
        /**
         * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupFieldToMatchSingleQueryArgumentProperties;
        /**
         * The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
         */
        uriPath?: any;
    }
    interface RuleGroupFieldToMatchSingleHeaderProperties {
        name: string;
    }
    /**
     * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
     */
    interface RuleGroupFieldToMatchSingleQueryArgumentProperties {
        name: string;
    }
    interface RuleGroupForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.RuleGroupForwardedIPConfigurationFallbackBehavior;
        headerName: string;
    }
    interface RuleGroupGeoMatchStatement {
        countryCodes?: string[];
        forwardedIPConfig?: outputs.wafv2.RuleGroupForwardedIPConfiguration;
    }
    /**
     * The pattern to look for in the request headers.
     */
    interface RuleGroupHeaderMatchPattern {
        /**
         * Inspect all parts of the web request headers.
         */
        all?: any;
        excludedHeaders?: string[];
        includedHeaders?: string[];
    }
    /**
     * Includes headers of a web request.
     */
    interface RuleGroupHeaders {
        matchPattern: outputs.wafv2.RuleGroupHeaderMatchPattern;
        matchScope: enums.wafv2.RuleGroupMapMatchScope;
        oversizeHandling: enums.wafv2.RuleGroupOversizeHandling;
    }
    interface RuleGroupIPSetForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.RuleGroupIPSetForwardedIPConfigurationFallbackBehavior;
        headerName: string;
        position: enums.wafv2.RuleGroupIPSetForwardedIPConfigurationPosition;
    }
    interface RuleGroupIPSetReferenceStatement {
        arn: string;
        iPSetForwardedIPConfig?: outputs.wafv2.RuleGroupIPSetForwardedIPConfiguration;
    }
    interface RuleGroupImmunityTimeProperty {
        immunityTime: number;
    }
    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers.
     */
    interface RuleGroupJsonBody {
        invalidFallbackBehavior?: enums.wafv2.RuleGroupBodyParsingFallbackBehavior;
        matchPattern: outputs.wafv2.RuleGroupJsonMatchPattern;
        matchScope: enums.wafv2.RuleGroupJsonMatchScope;
        oversizeHandling?: enums.wafv2.RuleGroupOversizeHandling;
    }
    /**
     * The pattern to look for in the JSON body.
     */
    interface RuleGroupJsonMatchPattern {
        /**
         * Inspect all parts of the web request's JSON body.
         */
        all?: any;
        includedPaths?: string[];
    }
    interface RuleGroupLabel {
        name: string;
    }
    interface RuleGroupLabelMatchStatement {
        key: string;
        scope: enums.wafv2.RuleGroupLabelMatchScope;
    }
    interface RuleGroupLabelSummary {
        name?: string;
    }
    interface RuleGroupNotStatement {
        statement: outputs.wafv2.RuleGroupStatement;
    }
    interface RuleGroupOrStatement {
        statements: outputs.wafv2.RuleGroupStatement[];
    }
    interface RuleGroupRateBasedStatement {
        aggregateKeyType: enums.wafv2.RuleGroupRateBasedStatementAggregateKeyType;
        forwardedIPConfig?: outputs.wafv2.RuleGroupForwardedIPConfiguration;
        limit: number;
        scopeDownStatement?: outputs.wafv2.RuleGroupStatement;
    }
    interface RuleGroupRegexMatchStatement {
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        regexString: string;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }
    interface RuleGroupRegexPatternSetReferenceStatement {
        arn: string;
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }
    /**
     * Rule of RuleGroup that contains condition and action.
     */
    interface RuleGroupRule {
        action?: outputs.wafv2.RuleGroupRuleAction;
        captchaConfig?: outputs.wafv2.RuleGroupCaptchaConfig;
        name: string;
        priority: number;
        /**
         * Collection of Rule Labels.
         */
        ruleLabels?: outputs.wafv2.RuleGroupLabel[];
        statement: outputs.wafv2.RuleGroupStatement;
        visibilityConfig: outputs.wafv2.RuleGroupVisibilityConfig;
    }
    /**
     * Action taken when Rule matches its condition.
     */
    interface RuleGroupRuleAction {
        /**
         * Allow traffic towards application.
         */
        allow?: outputs.wafv2.RuleGroupRuleActionAllowProperties;
        /**
         * Block traffic towards application.
         */
        block?: outputs.wafv2.RuleGroupRuleActionBlockProperties;
        /**
         * Checks valid token exists with request.
         */
        captcha?: outputs.wafv2.RuleGroupRuleActionCaptchaProperties;
        /**
         * Count traffic towards application.
         */
        count?: outputs.wafv2.RuleGroupRuleActionCountProperties;
    }
    /**
     * Allow traffic towards application.
     */
    interface RuleGroupRuleActionAllowProperties {
        customRequestHandling?: outputs.wafv2.RuleGroupCustomRequestHandling;
    }
    /**
     * Block traffic towards application.
     */
    interface RuleGroupRuleActionBlockProperties {
        customResponse?: outputs.wafv2.RuleGroupCustomResponse;
    }
    /**
     * Checks valid token exists with request.
     */
    interface RuleGroupRuleActionCaptchaProperties {
        customRequestHandling?: outputs.wafv2.RuleGroupCustomRequestHandling;
    }
    /**
     * Count traffic towards application.
     */
    interface RuleGroupRuleActionCountProperties {
        customRequestHandling?: outputs.wafv2.RuleGroupCustomRequestHandling;
    }
    /**
     * Size Constraint statement.
     */
    interface RuleGroupSizeConstraintStatement {
        comparisonOperator: enums.wafv2.RuleGroupSizeConstraintStatementComparisonOperator;
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        size: number;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }
    /**
     * Sqli Match Statement.
     */
    interface RuleGroupSqliMatchStatement {
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        sensitivityLevel?: enums.wafv2.RuleGroupSensitivityLevel;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }
    /**
     * First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
     */
    interface RuleGroupStatement {
        andStatement?: outputs.wafv2.RuleGroupAndStatement;
        byteMatchStatement?: outputs.wafv2.RuleGroupByteMatchStatement;
        geoMatchStatement?: outputs.wafv2.RuleGroupGeoMatchStatement;
        iPSetReferenceStatement?: outputs.wafv2.RuleGroupIPSetReferenceStatement;
        labelMatchStatement?: outputs.wafv2.RuleGroupLabelMatchStatement;
        notStatement?: outputs.wafv2.RuleGroupNotStatement;
        orStatement?: outputs.wafv2.RuleGroupOrStatement;
        rateBasedStatement?: outputs.wafv2.RuleGroupRateBasedStatement;
        regexMatchStatement?: outputs.wafv2.RuleGroupRegexMatchStatement;
        regexPatternSetReferenceStatement?: outputs.wafv2.RuleGroupRegexPatternSetReferenceStatement;
        sizeConstraintStatement?: outputs.wafv2.RuleGroupSizeConstraintStatement;
        sqliMatchStatement?: outputs.wafv2.RuleGroupSqliMatchStatement;
        xssMatchStatement?: outputs.wafv2.RuleGroupXssMatchStatement;
    }
    interface RuleGroupTag {
        key?: string;
        value?: string;
    }
    /**
     * Text Transformation on the Search String before match.
     */
    interface RuleGroupTextTransformation {
        priority: number;
        type: enums.wafv2.RuleGroupTextTransformationType;
    }
    /**
     * Visibility Metric of the RuleGroup.
     */
    interface RuleGroupVisibilityConfig {
        cloudWatchMetricsEnabled: boolean;
        metricName: string;
        sampledRequestsEnabled: boolean;
    }
    /**
     * Xss Match Statement.
     */
    interface RuleGroupXssMatchStatement {
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }
    /**
     * Allow traffic towards application.
     */
    interface WebACLAllowAction {
        customRequestHandling?: outputs.wafv2.WebACLCustomRequestHandling;
    }
    interface WebACLAndStatement {
        statements: outputs.wafv2.WebACLStatement[];
    }
    /**
     * Block traffic towards application.
     */
    interface WebACLBlockAction {
        customResponse?: outputs.wafv2.WebACLCustomResponse;
    }
    /**
     * The body of a web request. This immediately follows the request headers.
     */
    interface WebACLBody {
        oversizeHandling?: enums.wafv2.WebACLOversizeHandling;
    }
    /**
     * Byte Match statement.
     */
    interface WebACLByteMatchStatement {
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        positionalConstraint: enums.wafv2.WebACLPositionalConstraint;
        searchString?: string;
        searchStringBase64?: string;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }
    /**
     * Checks valid token exists with request.
     */
    interface WebACLCaptchaAction {
        customRequestHandling?: outputs.wafv2.WebACLCustomRequestHandling;
    }
    interface WebACLCaptchaConfig {
        immunityTimeProperty?: outputs.wafv2.WebACLImmunityTimeProperty;
    }
    /**
     * The pattern to look for in the request cookies.
     */
    interface WebACLCookieMatchPattern {
        /**
         * Inspect all parts of the web request cookies.
         */
        all?: any;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    /**
     * Includes headers of a web request.
     */
    interface WebACLCookies {
        matchPattern: outputs.wafv2.WebACLCookieMatchPattern;
        matchScope: enums.wafv2.WebACLMapMatchScope;
        oversizeHandling: enums.wafv2.WebACLOversizeHandling;
    }
    /**
     * Allow traffic towards application.
     */
    interface WebACLCountAction {
        customRequestHandling?: outputs.wafv2.WebACLCustomRequestHandling;
    }
    /**
     * HTTP header.
     */
    interface WebACLCustomHTTPHeader {
        name: string;
        value: string;
    }
    /**
     * Custom request handling.
     */
    interface WebACLCustomRequestHandling {
        /**
         * Collection of HTTP headers.
         */
        insertHeaders: outputs.wafv2.WebACLCustomHTTPHeader[];
    }
    /**
     * Custom response.
     */
    interface WebACLCustomResponse {
        /**
         * Custom response body key.
         */
        customResponseBodyKey?: string;
        responseCode: number;
        /**
         * Collection of HTTP headers.
         */
        responseHeaders?: outputs.wafv2.WebACLCustomHTTPHeader[];
    }
    /**
     * Custom response key and body map.
     */
    interface WebACLCustomResponseBodies {
    }
    /**
     * Default Action WebACL will take against ingress traffic when there is no matching Rule.
     */
    interface WebACLDefaultAction {
        allow?: outputs.wafv2.WebACLAllowAction;
        block?: outputs.wafv2.WebACLBlockAction;
    }
    /**
     * Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
     */
    interface WebACLExcludedRule {
        name: string;
    }
    interface WebACLFieldIdentifier {
        identifier: string;
    }
    /**
     * Field of the request to match.
     */
    interface WebACLFieldToMatch {
        /**
         * All query arguments of a web request.
         */
        allQueryArguments?: any;
        body?: outputs.wafv2.WebACLBody;
        cookies?: outputs.wafv2.WebACLCookies;
        headers?: outputs.wafv2.WebACLHeaders;
        jsonBody?: outputs.wafv2.WebACLJsonBody;
        /**
         * The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: any;
        /**
         * The query string of a web request. This is the part of a URL that appears after a ? character, if any.
         */
        queryString?: any;
        singleHeader?: outputs.wafv2.WebACLFieldToMatchSingleHeaderProperties;
        /**
         * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
         */
        singleQueryArgument?: outputs.wafv2.WebACLFieldToMatchSingleQueryArgumentProperties;
        /**
         * The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
         */
        uriPath?: any;
    }
    interface WebACLFieldToMatchSingleHeaderProperties {
        name: string;
    }
    /**
     * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
     */
    interface WebACLFieldToMatchSingleQueryArgumentProperties {
        name: string;
    }
    interface WebACLForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.WebACLForwardedIPConfigurationFallbackBehavior;
        headerName: string;
    }
    interface WebACLGeoMatchStatement {
        countryCodes?: string[];
        forwardedIPConfig?: outputs.wafv2.WebACLForwardedIPConfiguration;
    }
    /**
     * The pattern to look for in the request headers.
     */
    interface WebACLHeaderMatchPattern {
        /**
         * Inspect all parts of the web request headers.
         */
        all?: any;
        excludedHeaders?: string[];
        includedHeaders?: string[];
    }
    /**
     * Includes headers of a web request.
     */
    interface WebACLHeaders {
        matchPattern: outputs.wafv2.WebACLHeaderMatchPattern;
        matchScope: enums.wafv2.WebACLMapMatchScope;
        oversizeHandling: enums.wafv2.WebACLOversizeHandling;
    }
    interface WebACLIPSetForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.WebACLIPSetForwardedIPConfigurationFallbackBehavior;
        headerName: string;
        position: enums.wafv2.WebACLIPSetForwardedIPConfigurationPosition;
    }
    interface WebACLIPSetReferenceStatement {
        arn: string;
        iPSetForwardedIPConfig?: outputs.wafv2.WebACLIPSetForwardedIPConfiguration;
    }
    interface WebACLImmunityTimeProperty {
        immunityTime: number;
    }
    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers.
     */
    interface WebACLJsonBody {
        invalidFallbackBehavior?: enums.wafv2.WebACLBodyParsingFallbackBehavior;
        matchPattern: outputs.wafv2.WebACLJsonMatchPattern;
        matchScope: enums.wafv2.WebACLJsonMatchScope;
        oversizeHandling?: enums.wafv2.WebACLOversizeHandling;
    }
    /**
     * The pattern to look for in the JSON body.
     */
    interface WebACLJsonMatchPattern {
        /**
         * Inspect all parts of the web request's JSON body.
         */
        all?: any;
        includedPaths?: string[];
    }
    interface WebACLLabel {
        name: string;
    }
    interface WebACLLabelMatchStatement {
        key: string;
        scope: enums.wafv2.WebACLLabelMatchScope;
    }
    /**
     * ManagedRuleGroupConfig.
     */
    interface WebACLManagedRuleGroupConfig {
        loginPath?: string;
        passwordField?: outputs.wafv2.WebACLFieldIdentifier;
        payloadType?: enums.wafv2.WebACLManagedRuleGroupConfigPayloadType;
        usernameField?: outputs.wafv2.WebACLFieldIdentifier;
    }
    interface WebACLManagedRuleGroupStatement {
        excludedRules?: outputs.wafv2.WebACLExcludedRule[];
        /**
         * Collection of ManagedRuleGroupConfig.
         */
        managedRuleGroupConfigs?: outputs.wafv2.WebACLManagedRuleGroupConfig[];
        name: string;
        scopeDownStatement?: outputs.wafv2.WebACLStatement;
        vendorName: string;
        version?: string;
    }
    interface WebACLNotStatement {
        statement: outputs.wafv2.WebACLStatement;
    }
    interface WebACLOrStatement {
        statements: outputs.wafv2.WebACLStatement[];
    }
    /**
     * Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
     */
    interface WebACLOverrideAction {
        /**
         * Count traffic towards application.
         */
        count?: any;
        /**
         * Keep the RuleGroup or ManagedRuleGroup behavior as is.
         */
        none?: any;
    }
    interface WebACLRateBasedStatement {
        aggregateKeyType: enums.wafv2.WebACLRateBasedStatementAggregateKeyType;
        forwardedIPConfig?: outputs.wafv2.WebACLForwardedIPConfiguration;
        limit: number;
        scopeDownStatement?: outputs.wafv2.WebACLStatement;
    }
    interface WebACLRegexMatchStatement {
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        regexString: string;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }
    interface WebACLRegexPatternSetReferenceStatement {
        arn: string;
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }
    /**
     * Rule of WebACL that contains condition and action.
     */
    interface WebACLRule {
        action?: outputs.wafv2.WebACLRuleAction;
        captchaConfig?: outputs.wafv2.WebACLCaptchaConfig;
        name: string;
        overrideAction?: outputs.wafv2.WebACLOverrideAction;
        priority: number;
        /**
         * Collection of Rule Labels.
         */
        ruleLabels?: outputs.wafv2.WebACLLabel[];
        statement: outputs.wafv2.WebACLStatement;
        visibilityConfig: outputs.wafv2.WebACLVisibilityConfig;
    }
    /**
     * Action taken when Rule matches its condition.
     */
    interface WebACLRuleAction {
        allow?: outputs.wafv2.WebACLAllowAction;
        block?: outputs.wafv2.WebACLBlockAction;
        captcha?: outputs.wafv2.WebACLCaptchaAction;
        count?: outputs.wafv2.WebACLCountAction;
    }
    interface WebACLRuleGroupReferenceStatement {
        arn: string;
        excludedRules?: outputs.wafv2.WebACLExcludedRule[];
    }
    /**
     * Size Constraint statement.
     */
    interface WebACLSizeConstraintStatement {
        comparisonOperator: enums.wafv2.WebACLSizeConstraintStatementComparisonOperator;
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        size: number;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }
    /**
     * Sqli Match Statement.
     */
    interface WebACLSqliMatchStatement {
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        sensitivityLevel?: enums.wafv2.WebACLSensitivityLevel;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }
    /**
     * First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
     */
    interface WebACLStatement {
        andStatement?: outputs.wafv2.WebACLAndStatement;
        byteMatchStatement?: outputs.wafv2.WebACLByteMatchStatement;
        geoMatchStatement?: outputs.wafv2.WebACLGeoMatchStatement;
        iPSetReferenceStatement?: outputs.wafv2.WebACLIPSetReferenceStatement;
        labelMatchStatement?: outputs.wafv2.WebACLLabelMatchStatement;
        managedRuleGroupStatement?: outputs.wafv2.WebACLManagedRuleGroupStatement;
        notStatement?: outputs.wafv2.WebACLNotStatement;
        orStatement?: outputs.wafv2.WebACLOrStatement;
        rateBasedStatement?: outputs.wafv2.WebACLRateBasedStatement;
        regexMatchStatement?: outputs.wafv2.WebACLRegexMatchStatement;
        regexPatternSetReferenceStatement?: outputs.wafv2.WebACLRegexPatternSetReferenceStatement;
        ruleGroupReferenceStatement?: outputs.wafv2.WebACLRuleGroupReferenceStatement;
        sizeConstraintStatement?: outputs.wafv2.WebACLSizeConstraintStatement;
        sqliMatchStatement?: outputs.wafv2.WebACLSqliMatchStatement;
        xssMatchStatement?: outputs.wafv2.WebACLXssMatchStatement;
    }
    interface WebACLTag {
        key?: string;
        value?: string;
    }
    /**
     * Text Transformation on the Search String before match.
     */
    interface WebACLTextTransformation {
        priority: number;
        type: enums.wafv2.WebACLTextTransformationType;
    }
    /**
     * Visibility Metric of the WebACL.
     */
    interface WebACLVisibilityConfig {
        cloudWatchMetricsEnabled: boolean;
        metricName: string;
        sampledRequestsEnabled: boolean;
    }
    /**
     * Xss Match Statement.
     */
    interface WebACLXssMatchStatement {
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }
}
export declare namespace wisdom {
    interface AssistantAssociationAssociationData {
        knowledgeBaseId: string;
    }
    interface AssistantAssociationTag {
        key: string;
        value: string;
    }
    interface AssistantServerSideEncryptionConfiguration {
        kmsKeyId?: string;
    }
    interface AssistantTag {
        key: string;
        value: string;
    }
    interface KnowledgeBaseAppIntegrationsConfiguration {
        appIntegrationArn: string;
        objectFields: string[];
    }
    interface KnowledgeBaseRenderingConfiguration {
        templateUri?: string;
    }
    interface KnowledgeBaseServerSideEncryptionConfiguration {
        kmsKeyId?: string;
    }
    interface KnowledgeBaseSourceConfiguration {
        appIntegrations?: outputs.wisdom.KnowledgeBaseAppIntegrationsConfiguration;
    }
    interface KnowledgeBaseTag {
        key: string;
        value: string;
    }
}
export declare namespace workspaces {
    interface ConnectionAliasAssociation {
        associatedAccountId?: string;
        associationStatus?: enums.workspaces.ConnectionAliasAssociationAssociationStatus;
        connectionIdentifier?: string;
        resourceId?: string;
    }
    interface ConnectionAliasTag {
        key: string;
        value: string;
    }
    interface WorkspaceProperties {
        computeTypeName?: string;
        rootVolumeSizeGib?: number;
        runningMode?: string;
        runningModeAutoStopTimeoutInMinutes?: number;
        userVolumeSizeGib?: number;
    }
    interface WorkspaceTag {
        key: string;
        value: string;
    }
}
export declare namespace xray {
    interface GroupInsightsConfiguration {
        /**
         * Set the InsightsEnabled value to true to enable insights or false to disable insights.
         */
        insightsEnabled?: boolean;
        /**
         * Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
         */
        notificationsEnabled?: boolean;
    }
    interface SamplingRule {
        /**
         * Matches attributes derived from the request.
         */
        attributes?: any;
        /**
         * The percentage of matching requests to instrument, after the reservoir is exhausted.
         */
        fixedRate?: number;
        /**
         * Matches the HTTP method from a request URL.
         */
        hTTPMethod?: string;
        /**
         * Matches the hostname from a request URL.
         */
        host?: string;
        /**
         * The priority of the sampling rule.
         */
        priority?: number;
        /**
         * A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
         */
        reservoirSize?: number;
        /**
         * Matches the ARN of the AWS resource on which the service runs.
         */
        resourceARN?: string;
        ruleARN?: string;
        ruleName?: string;
        /**
         * Matches the name that the service uses to identify itself in segments.
         */
        serviceName?: string;
        /**
         * Matches the origin that the service uses to identify its type in segments.
         */
        serviceType?: string;
        /**
         * Matches the path from a request URL.
         */
        uRLPath?: string;
        /**
         * The version of the sampling rule format (1)
         */
        version?: number;
    }
    interface SamplingRuleRecord {
        /**
         * When the rule was created, in Unix time seconds.
         */
        createdAt?: string;
        /**
         * When the rule was modified, in Unix time seconds.
         */
        modifiedAt?: string;
        samplingRule?: outputs.xray.SamplingRule;
    }
    interface SamplingRuleUpdate {
        /**
         * Matches attributes derived from the request.
         */
        attributes?: any;
        /**
         * The percentage of matching requests to instrument, after the reservoir is exhausted.
         */
        fixedRate?: number;
        /**
         * Matches the HTTP method from a request URL.
         */
        hTTPMethod?: string;
        /**
         * Matches the hostname from a request URL.
         */
        host?: string;
        /**
         * The priority of the sampling rule.
         */
        priority?: number;
        /**
         * A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
         */
        reservoirSize?: number;
        /**
         * Matches the ARN of the AWS resource on which the service runs.
         */
        resourceARN?: string;
        ruleARN?: string;
        ruleName?: string;
        /**
         * Matches the name that the service uses to identify itself in segments.
         */
        serviceName?: string;
        /**
         * Matches the origin that the service uses to identify its type in segments.
         */
        serviceType?: string;
        /**
         * Matches the path from a request URL.
         */
        uRLPath?: string;
    }
    interface TagsItemProperties {
        key: string;
        value: string;
    }
}
